<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroid Screensaver </title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
// ===== asteroid.js =====
/**
 * Generate an irregular polygon shape for an asteroid.
 * Returns an array of [x, y] vertex pairs centered at origin.
 * Vertices are ordered by increasing angle (no crossed edges).
 */function generateShape(radius) {
  const vertexCount = 8 + Math.floor(Math.random() * 7); // 8–14
  const step = (Math.PI * 2) / vertexCount;
  const vertices = [];

  for (let i = 0; i < vertexCount; i++) {
    const angle = -Math.PI + step * i; // start at -PI so angles are monotonically increasing
    const r = radius * (0.6 + Math.random() * 0.4); // 0.6–1.0 of radius
    vertices.push([r * Math.cos(angle), r * Math.sin(angle)]);
  }

  return vertices;
}

/**
 * Determine stroke width from asteroid radius (size class).
 */
function getStrokeWidth(radius) {
  if (radius >= 50) return 2.0;  // large
  if (radius >= 25) return 1.5;  // medium
  return 1.0;                     // small
}

/**
 * Create an asteroid object.
 */function createAsteroid({ x, y, vx, vy, radius }) {
  // Angular velocity scaled inversely to radius: smaller = faster spin
  const maxAngVel = 0.5 * (20 / Math.max(radius, 10));
  const angularVelocity = (Math.random() * 2 - 1) * Math.min(maxAngVel, 0.5);

  const shape = generateShape(radius);

  // Compute effective collision radius as average vertex distance from center
  const collisionRadius = shape.reduce(
    (sum, [px, py]) => sum + Math.sqrt(px * px + py * py), 0
  ) / shape.length;

  return {
    x,
    y,
    vx,
    vy,
    radius,
    collisionRadius,
    rotation: 0,
    angularVelocity,
    shape,
    strokeWidth: getStrokeWidth(radius),
  };
}

/**
 * Update asteroid position and rotation by delta time.
 */function updateAsteroid(asteroid, dt) {
  asteroid.x += asteroid.vx * dt;
  asteroid.y += asteroid.vy * dt;
  asteroid.rotation += asteroid.angularVelocity * dt;
}

/**
 * Draw an asteroid as a white wireframe polygon on a canvas 2D context.
 */function drawAsteroid(ctx, asteroid) {
  const { x, y, rotation, shape, strokeWidth } = asteroid;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = strokeWidth;

  ctx.beginPath();
  ctx.moveTo(shape[0][0], shape[0][1]);
  for (let i = 1; i < shape.length; i++) {
    ctx.lineTo(shape[i][0], shape[i][1]);
  }
  ctx.closePath();
  ctx.stroke();

  ctx.restore();
}

// ===== energy.js =====
/**
 * Compute kinetic energy for a single asteroid.
 * KE = 0.5 * mass * speed², where mass = collisionRadius²
 */
function computeKE(asteroid) {
  const mass = asteroid.collisionRadius * asteroid.collisionRadius;
  return 0.5 * mass * (asteroid.vx * asteroid.vx + asteroid.vy * asteroid.vy);
}

/**
 * Sum kinetic energy across all asteroids.
 */
function computeTotalKE(asteroids) {
  let total = 0;
  for (const a of asteroids) {
    total += computeKE(a);
  }
  return total;
}

/**
 * Compute a speed multiplier for new spawns to sustain system energy.
 * Returns clamp(sqrt(targetKE / actualKE), 1.0, 1.5).
 */
function computeSpeedBoost(baselineKEPerAsteroid, targetCount, asteroids) {
  const targetKE = baselineKEPerAsteroid * targetCount;
  if (targetKE <= 0) return 1.0;

  const actualKE = computeTotalKE(asteroids);
  if (actualKE <= 0) return 1.5;
  if (actualKE >= targetKE) return 1.0;

  return Math.min(Math.sqrt(targetKE / actualKE), 1.5);
}

// ===== main.js =====

/**
 * Calculate delta time in seconds between two timestamps (ms).
 * Caps at 0.1s to avoid spiral-of-death after tab backgrounding.
 * Never returns negative values.
 */function calculateDeltaTime(currentTimestamp, previousTimestamp) {
  const dtSeconds = (currentTimestamp - previousTimestamp) / 1000;
  return Math.min(Math.max(dtSeconds, 0), 0.1);
}

/**
 * Create an animation loop state object.
 * Call loop.tick(timestamp) each frame from requestAnimationFrame.
 * First tick returns dt=0 (no previous frame to diff against).
 */function createLoop() {
  let started = false;

  const state = {
    frameCount: 0,
    lastTimestamp: 0,

    tick(timestamp) {
      let dt = 0;
      if (started) {
        dt = calculateDeltaTime(timestamp, state.lastTimestamp);
      }
      started = true;
      state.lastTimestamp = timestamp;
      state.frameCount++;
      return dt;
    },
  };
  return state;
}

/**
 * Bootstrap the application: set up canvas, resize handling, and start the loop.
 */function startApp() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  let logicalSize = setupHiDPICanvas(canvas, ctx, window.innerWidth, window.innerHeight, dpr);

  const loop = createLoop();
  let starLayers = createParallaxLayers(logicalSize.width, logicalSize.height);
  const sim = createSimulation(logicalSize.width, logicalSize.height);
  const loaded = loadSettings();
  const settings = createSettings(loaded);
  let elapsedTime = 0;

  // Settings UI
  const ui = createSettingsUI(document.body, settings);
  // Apply loaded settings to simulation and starfield
  sim.targetCount = settings.asteroidCount;
  if (settings.starLayers !== 3) {
    starLayers = createParallaxLayers(logicalSize.width, logicalSize.height, settings.starLayers);
  }
  if (settings.starDirection !== 'left') {
    redistributeStars(starLayers, logicalSize.width, logicalSize.height, settings.starDirection);
  }

  ui.onChange = (name, value) => {
    settings[name] = value;
    if (name === 'asteroidCount') {
      sim.targetCount = value;
    }
    if (name === 'starLayers') {
      starLayers = createParallaxLayers(logicalSize.width, logicalSize.height, value);
    }
    if (name === 'starDirection') {
      redistributeStars(starLayers, logicalSize.width, logicalSize.height, value);
    }
    saveSettings(settings);
  };

  // Resize: update canvas with HiDPI and redistribute stars
  window.addEventListener('resize', () => {
    logicalSize = setupHiDPICanvas(canvas, ctx, window.innerWidth, window.innerHeight, dpr);
    redistributeStars(starLayers, logicalSize.width, logicalSize.height, settings.starDirection);
  });

  // Auto-hide: reset gear timer on any mouse movement
  window.addEventListener('mousemove', () => {
    settings.gearTimer = 0;
    if (settings.panelOpen) {
      settings.panelTimer = 0;
    }
  });

  function frame(timestamp) {
    const dt = loop.tick(timestamp);
    elapsedTime += dt;

    // Apply speed multiplier to simulation dt
    const scaledDt = dt * settings.speedMultiplier;

    updateAutoHide(settings, dt);

    // When panel is open, button acts as close icon — always fully visible
    if (settings.panelOpen) {
      ui.gearButton.style.opacity = '0.8';
      ui.gearButton.style.pointerEvents = 'auto';
    } else {
      ui.gearButton.style.opacity = settings.gearVisible
        ? (settings.gearHovered ? '0.8' : '0.3')
        : '0';
      ui.gearButton.style.pointerEvents = settings.gearVisible ? 'auto' : 'none';
    }
    ui.panel.style.display = settings.panelOpen ? 'block' : 'none';
    ui.gearButton.textContent = settings.panelOpen ? '\u2715' : '\u2630';

    for (const layer of starLayers) {
      updateStarLayerDirectional(layer, scaledDt, logicalSize.width, logicalSize.height, settings.starDirection);
    }
    updateSimulation(sim, scaledDt, logicalSize.width, logicalSize.height);

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, logicalSize.width, logicalSize.height);

    drawParallaxLayers(ctx, starLayers, elapsedTime);

    for (const asteroid of sim.asteroids) {
      drawAsteroid(ctx, asteroid);
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

// ===== physics.js =====
/**
 * Detect all colliding asteroid pairs using circle-circle collision.
 * Returns an array of [asteroidA, asteroidB] pairs.
 * A collision occurs when distance between centers < sum of collision radii.
 * Exactly touching (distance === sum) is NOT a collision.
 */function detectCollisions(asteroids) {
  const pairs = [];
  for (let i = 0; i < asteroids.length; i++) {
    for (let j = i + 1; j < asteroids.length; j++) {
      const a = asteroids[i];
      const b = asteroids[j];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const radiiSum = a.collisionRadius + b.collisionRadius;
      if (dist < radiiSum) {
        pairs.push([a, b]);
      }
    }
  }
  return pairs;
}

/**
 * Separate two overlapping asteroids along the collision normal.
 * Lighter asteroid (smaller collisionRadius²) is pushed proportionally more.
 */function separateOverlap(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist === 0) {
    // Perfectly coincident — push apart along arbitrary axis
    b.x += a.collisionRadius + b.collisionRadius;
    return;
  }

  const overlap = (a.collisionRadius + b.collisionRadius) - dist;
  if (overlap <= 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const massA = a.collisionRadius * a.collisionRadius;
  const massB = b.collisionRadius * b.collisionRadius;
  const totalMass = massA + massB;

  // Lighter asteroid moves more
  const pushA = overlap * (massB / totalMass);
  const pushB = overlap * (massA / totalMass);

  a.x -= nx * pushA;
  a.y -= ny * pushA;
  b.x += nx * pushB;
  b.y += ny * pushB;
}

/**
 * Resolve an elastic collision between two asteroids.
 * Uses 2D elastic collision formula with mass = collisionRadius².
 * Applies ±1% random perturbation and angular velocity nudge.
 */function resolveCollision(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist === 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const massA = a.collisionRadius * a.collisionRadius;
  const massB = b.collisionRadius * b.collisionRadius;

  // Relative velocity along collision normal
  const dvx = a.vx - b.vx;
  const dvy = a.vy - b.vy;
  const dvDotN = dvx * nx + dvy * ny;

  // Don't resolve if asteroids are moving apart
  if (dvDotN <= 0) return;

  const totalMass = massA + massB;

  // 2D elastic collision impulse with ±1% perturbation on magnitude.
  // Using a single factor for both asteroids preserves momentum exactly
  // while adding enough variation to prevent repeating collision patterns.
  // Kept at ±1% to maintain KE conservation within 5%.
  const perturbation = 1 + (Math.random() * 0.02 - 0.01);
  const impulseA = (2 * massB / totalMass) * dvDotN * perturbation;
  const impulseB = (2 * massA / totalMass) * dvDotN * perturbation;

  a.vx -= impulseA * nx;
  a.vy -= impulseA * ny;
  b.vx += impulseB * nx;
  b.vy += impulseB * ny;

  // Nudge angular velocity slightly on impact
  const angularNudge = () => (Math.random() * 0.2 - 0.1);
  a.angularVelocity += angularNudge();
  b.angularVelocity += angularNudge();
}

// ===== renderer.js =====
/**
 * Set up a canvas for HiDPI rendering.
 * Sets internal resolution to CSS size × dpr, applies CSS size,
 * and scales the context so all drawing uses CSS (logical) coordinates.
 * Returns the logical size { width, height } for use by game systems.
 */function setupHiDPICanvas(canvas, ctx, cssWidth, cssHeight, dpr) {
  canvas.width = cssWidth * dpr;
  canvas.height = cssHeight * dpr;
  canvas.style.width = cssWidth + 'px';
  canvas.style.height = cssHeight + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { width: cssWidth, height: cssHeight };
}

// ===== settings.js =====
/**
 * Configuration for each setting: range, step, default, and display label.
 */const SETTINGS_CONFIG = {
  asteroidCount: { min: 5, max: 50, step: 1, default: 20, label: 'Asteroids' },
  speedMultiplier: { min: 0.2, max: 3.0, step: 0.1, default: 1.0, label: 'Speed' },
  starLayers: { min: 3, max: 6, step: 1, default: 3, label: 'Star Layers' },
  starDirection: { options: ['left', 'right', 'up', 'down', 'radial'], default: 'left', label: 'Direction' },
};

const STORAGE_KEY = 'asteroidSettings';

/**
 * Create settings state with defaults, optionally applying overrides.
 */function createSettings(overrides = {}) {
  return {
    asteroidCount: overrides.asteroidCount ?? SETTINGS_CONFIG.asteroidCount.default,
    speedMultiplier: overrides.speedMultiplier ?? SETTINGS_CONFIG.speedMultiplier.default,
    starLayers: overrides.starLayers ?? SETTINGS_CONFIG.starLayers.default,
    starDirection: overrides.starDirection ?? SETTINGS_CONFIG.starDirection.default,
    panelOpen: false,
    gearVisible: true,
    gearHovered: false,
    gearTimer: 0,
    panelTimer: 0,
  };
}

/**
 * Save the 3 tunable settings to localStorage.
 */function saveSettings(settings) {
  const data = {
    asteroidCount: settings.asteroidCount,
    speedMultiplier: settings.speedMultiplier,
    starLayers: settings.starLayers,
    starDirection: settings.starDirection,
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

/**
 * Load settings from localStorage. Returns an object with tunable values.
 * Falls back to defaults if storage is empty, corrupt, or contains invalid values.
 */function loadSettings() {
  const defaults = {
    asteroidCount: SETTINGS_CONFIG.asteroidCount.default,
    speedMultiplier: SETTINGS_CONFIG.speedMultiplier.default,
    starLayers: SETTINGS_CONFIG.starLayers.default,
    starDirection: SETTINGS_CONFIG.starDirection.default,
  };

  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw === null) return defaults;

    const parsed = JSON.parse(raw);
    if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
      return defaults;
    }

    const result = {};
    for (const name of Object.keys(defaults)) {
      const config = SETTINGS_CONFIG[name];
      const val = parsed[name];

      if (config.options) {
        // String enum setting (e.g. starDirection)
        result[name] = config.options.includes(val) ? val : defaults[name];
      } else if (typeof val === 'number' && !isNaN(val)) {
        result[name] = clampSetting(name, val);
      } else {
        result[name] = defaults[name];
      }
    }
    return result;
  } catch {
    return defaults;
  }
}

/**
 * Clamp a setting value to its valid range.
 * Integer settings (step=1) are rounded to the nearest integer.
 */function clampSetting(name, value) {
  const config = SETTINGS_CONFIG[name];
  let v = Number(value);
  if (config.step >= 1) v = Math.round(v);
  return Math.min(config.max, Math.max(config.min, v));
}

/**
 * Update auto-hide timers. Call each frame with dt.
 * - Gear hides after 3s of no mouse movement (caller resets gearTimer to 0 on mouse move)
 * - Panel closes after 4s of no mouse activity over it (caller resets panelTimer to 0)
 */function updateAutoHide(settings, dt) {
  settings.gearTimer += dt;
  if (settings.gearTimer < 3) {
    settings.gearVisible = true;
  } else {
    settings.gearVisible = false;
  }

  if (settings.panelOpen) {
    settings.panelTimer += dt;
    if (settings.panelTimer >= 4) {
      settings.panelOpen = false;
    }
  }
}

/**
 * Format a setting value for display.
 */
function formatValue(name, value) {
  if (name === 'speedMultiplier') return value.toFixed(1) + 'x';
  return String(value);
}

/**
 * Create the settings UI: gear button, panel with sliders.
 * Returns { gearButton, panel, sliders, valueDisplays, onChange }.
 */function createSettingsUI(container, settings) {
  // Hamburger menu button
  const gearButton = document.createElement('button');
  gearButton.textContent = '\u2630';
  gearButton.style.cssText =
    'position:fixed;top:20px;left:20px;background:none;border:none;' +
    'color:#fff;font-size:28px;cursor:pointer;opacity:0.3;z-index:1001;' +
    'padding:8px;line-height:1;transition:opacity 0.2s;';
  gearButton.addEventListener('mouseenter', () => {
    settings.gearHovered = true;
    gearButton.style.opacity = '0.8';
  });
  gearButton.addEventListener('mouseleave', () => {
    settings.gearHovered = false;
    gearButton.style.opacity = '0.3';
  });
  container.appendChild(gearButton);

  // Panel
  const panel = document.createElement('div');
  panel.style.cssText =
    'position:fixed;top:0;left:0;width:260px;height:100%;' +
    'background:rgba(0,0,0,0.85);color:#fff;font-family:"Courier New",monospace;' +
    'font-size:14px;padding:70px 20px 24px;box-sizing:border-box;z-index:1000;' +
    'display:none;';
  container.appendChild(panel);

  const title = document.createElement('div');
  title.textContent = 'Settings';
  title.style.cssText = 'font-size:18px;margin-bottom:24px;';
  panel.appendChild(title);

  let _onChange = () => {};

  const sliders = {};
  const valueDisplays = {};

  let directionSelect;

  for (const [name, config] of Object.entries(SETTINGS_CONFIG)) {
    if (config.options) {
      // Enum setting — render as a <select> dropdown
      const row = document.createElement('div');
      row.style.cssText = 'margin-bottom:20px;';

      const label = document.createElement('label');
      label.style.cssText = 'display:block;margin-bottom:6px;';
      label.textContent = config.label;

      const select = document.createElement('select');
      select.style.cssText = 'width:100%;background:#222;color:#fff;border:1px solid #555;' +
        'padding:4px;font-family:"Courier New",monospace;font-size:14px;';
      for (const opt of config.options) {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        select.appendChild(option);
      }
      select.value = settings[name];
      directionSelect = select;

      select.addEventListener('change', () => {
        _onChange(name, select.value);
      });

      row.appendChild(label);
      row.appendChild(select);
      panel.appendChild(row);
      continue;
    }

    // Numeric setting — render as a slider
    const row = document.createElement('div');
    row.style.cssText = 'margin-bottom:20px;';

    const label = document.createElement('label');
    label.style.cssText = 'display:block;margin-bottom:6px;';

    const labelText = document.createElement('span');
    labelText.textContent = config.label;

    const valueSpan = document.createElement('span');
    valueSpan.textContent = formatValue(name, settings[name]);
    valueSpan.style.cssText = 'float:right;';
    valueDisplays[name] = valueSpan;

    label.appendChild(labelText);
    label.appendChild(valueSpan);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = String(config.min);
    slider.max = String(config.max);
    slider.step = String(config.step);
    slider.value = String(settings[name]);
    slider.style.cssText = 'width:100%;';
    sliders[name] = slider;

    slider.addEventListener('input', () => {
      const val = clampSetting(name, slider.value);
      valueSpan.textContent = formatValue(name, val);
      _onChange(name, val);
    });

    row.appendChild(label);
    row.appendChild(slider);
    panel.appendChild(row);
  }

  // Button click toggles panel; swap icon between ☰ and ✕
  gearButton.addEventListener('click', () => {
    settings.panelOpen = !settings.panelOpen;
    settings.panelTimer = 0;
    panel.style.display = settings.panelOpen ? 'block' : 'none';
    gearButton.textContent = settings.panelOpen ? '\u2715' : '\u2630';
  });

  // Escape closes panel
  const onKeydown = (e) => {
    if (e.key === 'Escape') {
      settings.panelOpen = false;
      panel.style.display = 'none';
      gearButton.textContent = '\u2630';
    }
  };
  document.addEventListener('keydown', onKeydown);

  return {
    gearButton,
    panel,
    sliders,
    valueDisplays,
    directionSelect,
    set onChange(fn) { _onChange = fn; },
    get onChange() { return _onChange; },
    destroy() {
      document.removeEventListener('keydown', onKeydown);
    },
  };
}

// ===== simulation.js =====

const SPAWN_STAGGER = 0.3; // seconds between spawns
const MARGIN = 5; // px margin beyond radius for off-screen detection

/**
 * Check if an asteroid is fully off-screen (center + radius + margin past all edges).
 */function isOffScreen(asteroid, canvasWidth, canvasHeight) {
  const { x, y, radius } = asteroid;
  return (
    x + radius + MARGIN < 0 ||
    x - radius - MARGIN > canvasWidth ||
    y + radius + MARGIN < 0 ||
    y - radius - MARGIN > canvasHeight
  );
}

/**
 * Pick a random size class with the spec distribution:
 * ~20% large (50–80), ~40% medium (25–49), ~40% small (10–24)
 */
function randomRadius() {
  const roll = Math.random();
  if (roll < 0.2) {
    // Large: 50–80
    return 50 + Math.random() * 30;
  } else if (roll < 0.6) {
    // Medium: 25–49
    return 25 + Math.random() * 24;
  } else {
    // Small: 10–24
    return 10 + Math.random() * 14;
  }
}

/**
 * Get speed range for a given radius.
 * Large (50–80): 15–30 px/s
 * Medium (25–49): 30–60 px/s
 * Small (10–24): 60–120 px/s
 */
function speedForRadius(radius) {
  if (radius >= 50) return 15 + Math.random() * 15;
  if (radius >= 25) return 30 + Math.random() * 30;
  return 60 + Math.random() * 60;
}

/**
 * Spawn a new asteroid from a random screen edge, aimed roughly inward.
 * Optional speedMultiplier scales the base speed (default 1.0).
 */function spawnAsteroidFromEdge(canvasWidth, canvasHeight, speedMultiplier = 1.0) {
  const radius = randomRadius();
  const speed = speedForRadius(radius) * speedMultiplier;
  const edge = Math.floor(Math.random() * 4); // 0=left, 1=right, 2=top, 3=bottom

  let x, y, baseAngle;

  switch (edge) {
    case 0: // left
      x = -radius - 1;
      y = Math.random() * canvasHeight;
      baseAngle = 0; // aiming right
      break;
    case 1: // right
      x = canvasWidth + radius + 1;
      y = Math.random() * canvasHeight;
      baseAngle = Math.PI; // aiming left
      break;
    case 2: // top
      x = Math.random() * canvasWidth;
      y = -radius - 1;
      baseAngle = Math.PI / 2; // aiming down
      break;
    default: // bottom
      x = Math.random() * canvasWidth;
      y = canvasHeight + radius + 1;
      baseAngle = -Math.PI / 2; // aiming up
      break;
  }

  // Add angular spread of ±30° (±PI/6)
  const spread = (Math.random() * 2 - 1) * (Math.PI / 6);
  const angle = baseAngle + spread;

  return createAsteroid({
    x,
    y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius,
  });
}

/**
 * Create the simulation state with an initial population of asteroids.
 */function createSimulation(canvasWidth, canvasHeight, targetCount = 20) {
  const asteroids = [];
  for (let i = 0; i < targetCount; i++) {
    asteroids.push(spawnAsteroidFromEdge(canvasWidth, canvasHeight));
  }

  const baselineKEPerAsteroid = computeTotalKE(asteroids) / asteroids.length;

  return {
    asteroids,
    targetCount,
    spawnTimer: 0,
    baselineKEPerAsteroid,
  };
}

/**
 * Update the simulation: move asteroids, remove off-screen ones, spawn replacements.
 */function updateSimulation(sim, dt, canvasWidth, canvasHeight) {
  // Update all asteroids
  for (const a of sim.asteroids) {
    updateAsteroid(a, dt);
  }

  // Detect and resolve collisions
  const pairs = detectCollisions(sim.asteroids);
  for (const [a, b] of pairs) {
    separateOverlap(a, b);
    resolveCollision(a, b);
  }

  // Remove off-screen asteroids
  sim.asteroids = sim.asteroids.filter(a => !isOffScreen(a, canvasWidth, canvasHeight));

  // Spawn new asteroids if below target (staggered), with energy-sustaining boost
  sim.spawnTimer += dt;
  if (sim.asteroids.length < sim.targetCount && sim.spawnTimer >= SPAWN_STAGGER) {
    const boost = computeSpeedBoost(
      sim.baselineKEPerAsteroid, sim.targetCount, sim.asteroids
    );
    sim.asteroids.push(spawnAsteroidFromEdge(canvasWidth, canvasHeight, boost));
    sim.spawnTimer = 0;
  }
}

// ===== starfield.js =====
/**
 * Create a single star with random position, size, and brightness.
 */function createStar(canvasWidth, canvasHeight, options = {}) {
  const minSize = options.minSize ?? 1;
  const maxSize = options.maxSize ?? 2;
  const minBrightness = options.minBrightness ?? 0.3;
  const maxBrightness = options.maxBrightness ?? 1.0;

  const brightness = minBrightness + Math.random() * (maxBrightness - minBrightness);

  const star = {
    x: Math.random() * canvasWidth,
    y: Math.random() * canvasHeight,
    size: minSize + Math.random() * (maxSize - minSize),
    brightness,
  };

  if (options.twinkle) {
    star.twinklePhase = Math.random() * Math.PI * 2;
    star.twinkleFreq = 0.3 + Math.random() * 2.7;           // 0.3–3.0 Hz
    star.twinkleAmplitude = brightness * (0.1 + Math.random() * 0.2); // 10–30% of base
  }

  return star;
}

/**
 * Create a star layer: a collection of stars that scroll together at a given speed.
 */function createStarLayer(count, canvasWidth, canvasHeight, options = {}) {
  const stars = [];
  for (let i = 0; i < count; i++) {
    stars.push(createStar(canvasWidth, canvasHeight, options));
  }
  return {
    stars,
    speed: options.speed ?? 10,
  };
}

/**
 * Update a star layer: move all stars leftward by speed * dt.
 * Stars that exit the left edge wrap to the right edge with a new random y.
 */function updateStarLayer(layer, dt, canvasWidth, canvasHeight) {
  const dx = layer.speed * dt;
  for (const star of layer.stars) {
    star.x -= dx;
    if (star.x < 0) {
      star.x = canvasWidth + star.x;
      star.y = Math.random() * canvasHeight;
    }
  }
}

/**
 * Compute the effective brightness of a star at a given elapsed time.
 * Stars without twinkle properties return their base brightness.
 * Formula: base + amplitude * sin(time * freq * 2π + phase), clamped to [0, 1].
 */function applyTwinkle(star, elapsedTime) {
  if (star.twinklePhase == null) return star.brightness;
  const value = star.brightness + star.twinkleAmplitude * Math.sin(elapsedTime * star.twinkleFreq * Math.PI * 2 + star.twinklePhase);
  return Math.min(1.0, Math.max(0, value));
}

// Layer presets for the default 3-layer parallax (far, mid, near).
// Base star counts are calibrated for 1920×1080; scaled by canvas area ratio.
const LAYER_PRESETS = [
  { baseCount: 100, minSize: 1, maxSize: 1, minBrightness: 0.3, maxBrightness: 0.5, minSpeed: 2, maxSpeed: 5 },
  { baseCount: 60,  minSize: 1, maxSize: 2, minBrightness: 0.5, maxBrightness: 0.7, minSpeed: 8, maxSpeed: 15 },
  { baseCount: 30,  minSize: 2, maxSize: 3, minBrightness: 0.7, maxBrightness: 1.0, minSpeed: 20, maxSpeed: 35 },
];

/**
 * Linearly interpolate between a and b by factor t (0–1).
 */
function lerp(a, b, t) {
  return a + (b - a) * t;
}

/**
 * Create parallax star layers. Default is 3 (far, mid, near).
 * Extra layers interpolate properties between far and near presets.
 */function createParallaxLayers(canvasWidth, canvasHeight, layerCount = 3) {
  const baseArea = 1920 * 1080;
  const areaRatio = (canvasWidth * canvasHeight) / baseArea;
  const far = LAYER_PRESETS[0];
  const near = LAYER_PRESETS[2];

  const layers = [];
  for (let i = 0; i < layerCount; i++) {
    const t = layerCount === 1 ? 0 : i / (layerCount - 1);

    let preset;
    if (layerCount === 3 && i < 3) {
      preset = LAYER_PRESETS[i];
    } else {
      preset = {
        baseCount: Math.round(lerp(far.baseCount, near.baseCount, t)),
        minSize: lerp(far.minSize, near.minSize, t),
        maxSize: lerp(far.maxSize, near.maxSize, t),
        minBrightness: lerp(far.minBrightness, near.minBrightness, t),
        maxBrightness: lerp(far.maxBrightness, near.maxBrightness, t),
        minSpeed: lerp(far.minSpeed, near.minSpeed, t),
        maxSpeed: lerp(far.maxSpeed, near.maxSpeed, t),
      };
    }

    const count = Math.max(1, Math.round(preset.baseCount * areaRatio));
    // Use midpoint of speed range for interpolated layers to guarantee monotonic ordering;
    // the 3-layer preset path already has non-overlapping ranges so random is fine there.
    const speed = (layerCount === 3 && i < 3)
      ? preset.minSpeed + Math.random() * (preset.maxSpeed - preset.minSpeed)
      : (preset.minSpeed + preset.maxSpeed) / 2;

    const isNearLayer = (i === layerCount - 1) && layerCount > 1;

    layers.push(createStarLayer(count, canvasWidth, canvasHeight, {
      speed,
      minSize: preset.minSize,
      maxSize: preset.maxSize,
      minBrightness: preset.minBrightness,
      maxBrightness: preset.maxBrightness,
      twinkle: !isNearLayer,
    }));
  }
  return layers;
}

/**
 * Update a star layer with a configurable direction.
 * Directions: 'left', 'right', 'up', 'down', 'radial'.
 */function updateStarLayerDirectional(layer, dt, canvasWidth, canvasHeight, direction) {
  const baseDelta = layer.speed * dt;
  if (baseDelta === 0) return;

  const cx = canvasWidth / 2;
  const cy = canvasHeight / 2;
  // Reference distance for perspective scaling (half the shorter dimension)
  const refDist = Math.min(canvasWidth, canvasHeight) / 2;

  for (const star of layer.stars) {
    if (direction === 'radial') {
      let dx = star.x - cx;
      let dy = star.y - cy;
      const dist = Math.hypot(dx, dy);

      if (dist < 0.01) {
        // Star at exact center — assign a random angle to push it outward
        const angle = Math.random() * Math.PI * 2;
        dx = Math.cos(angle);
        dy = Math.sin(angle);
      } else {
        dx /= dist;
        dy /= dist;
      }

      // Perspective acceleration: speed scales with distance from center
      const speedFactor = Math.max(dist / refDist, 0.05);
      star.x += dx * baseDelta * speedFactor;
      star.y += dy * baseDelta * speedFactor;

      // Brightness fades in with distance from center
      const newDist = Math.hypot(star.x - cx, star.y - cy);
      star.radialBrightness = Math.min(newDist / refDist, 1.0);

      // Recycle if outside canvas
      if (star.x < 0 || star.x > canvasWidth || star.y < 0 || star.y > canvasHeight) {
        const angle = Math.random() * Math.PI * 2;
        const spawnDist = 5 + Math.random() * 25;
        star.x = cx + Math.cos(angle) * spawnDist;
        star.y = cy + Math.sin(angle) * spawnDist;
        star.radialBrightness = spawnDist / refDist;
      }
    } else {
      // Clear radialBrightness when not in radial mode
      delete star.radialBrightness;

      if (direction === 'right') {
        star.x += baseDelta;
        if (star.x > canvasWidth) {
          star.x = star.x - canvasWidth;
          star.y = Math.random() * canvasHeight;
        }
      } else if (direction === 'up') {
        star.y -= baseDelta;
        if (star.y < 0) {
          star.y = canvasHeight + star.y;
          star.x = Math.random() * canvasWidth;
        }
      } else if (direction === 'down') {
        star.y += baseDelta;
        if (star.y > canvasHeight) {
          star.y = star.y - canvasHeight;
          star.x = Math.random() * canvasWidth;
        }
      } else {
        // 'left' (default)
        star.x -= baseDelta;
        if (star.x < 0) {
          star.x = canvasWidth + star.x;
          star.y = Math.random() * canvasHeight;
        }
      }
    }
  }
}

/**
 * Redistribute all stars across layers for a new direction mode.
 * Call when the user switches direction to avoid visual artifacts
 * (e.g. stars clustered at center after leaving radial mode).
 */function redistributeStars(layers, canvasWidth, canvasHeight, direction) {
  const cx = canvasWidth / 2;
  const cy = canvasHeight / 2;
  const refDist = Math.min(canvasWidth, canvasHeight) / 2;

  for (const layer of layers) {
    for (const star of layer.stars) {
      if (direction === 'radial') {
        const angle = Math.random() * Math.PI * 2;
        const maxDist = Math.hypot(cx, cy);
        const dist = Math.random() * maxDist;
        star.x = cx + Math.cos(angle) * dist;
        star.y = cy + Math.sin(angle) * dist;
        star.radialBrightness = Math.min(dist / refDist, 1.0);
      } else {
        star.x = Math.random() * canvasWidth;
        star.y = Math.random() * canvasHeight;
        delete star.radialBrightness;
      }
    }
  }
}

/**
 * Update all parallax layers.
 */function updateParallaxLayers(layers, dt, canvasWidth, canvasHeight) {
  for (const layer of layers) {
    updateStarLayer(layer, dt, canvasWidth, canvasHeight);
  }
}

/**
 * Draw all parallax layers (far to near, back to front).
 */function drawParallaxLayers(ctx, layers, elapsedTime = 0) {
  for (const layer of layers) {
    drawStarLayer(ctx, layer, elapsedTime);
  }
}

/**
 * Draw a star layer onto a canvas 2D context.
 */function drawStarLayer(ctx, layer, elapsedTime = 0) {
  for (const star of layer.stars) {
    let brightness = applyTwinkle(star, elapsedTime);
    if (star.radialBrightness != null) {
      brightness *= star.radialBrightness;
    }
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
    ctx.fillRect(
      star.x,
      star.y,
      star.size,
      star.size,
    );
  }
}


startApp();
</script>
</body>
</html>
