<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroid Screensaver </title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
// ===== asteroid.js =====
/**
 * Generate an irregular polygon shape for an asteroid.
 * Returns an array of [x, y] vertex pairs centered at origin.
 * Vertices are ordered by increasing angle (no crossed edges).
 */
function generateShape(radius) {
  const vertexCount = 8 + Math.floor(Math.random() * 7); // 8–14
  const step = (Math.PI * 2) / vertexCount;
  const vertices = [];

  for (let i = 0; i < vertexCount; i++) {
    const angle = -Math.PI + step * i; // start at -PI so angles are monotonically increasing
    const r = radius * (0.6 + Math.random() * 0.4); // 0.6–1.0 of radius
    vertices.push([r * Math.cos(angle), r * Math.sin(angle)]);
  }

  return vertices;
}

/**
 * Determine stroke width from asteroid radius (size class).
 */
function getStrokeWidth(radius) {
  if (radius >= 50) return 2.0; // large
  if (radius >= 25) return 1.5; // medium
  return 1.0; // small
}

/**
 * Create an asteroid object.
 */
function createAsteroid({ x, y, vx, vy, radius }) {
  // Angular velocity scaled inversely to radius: smaller = faster spin
  const maxAngVel = 0.5 * (20 / Math.max(radius, 10));
  const angularVelocity = (Math.random() * 2 - 1) * Math.min(maxAngVel, 0.5);

  const shape = generateShape(radius);

  // Compute effective collision radius as average vertex distance from center
  const collisionRadius =
    shape.reduce((sum, [px, py]) => sum + Math.sqrt(px * px + py * py), 0) /
    shape.length;

  return {
    x,
    y,
    vx,
    vy,
    radius,
    collisionRadius,
    rotation: 0,
    angularVelocity,
    shape,
    strokeWidth: getStrokeWidth(radius),
  };
}

/**
 * Update asteroid position and rotation by delta time.
 */
function updateAsteroid(asteroid, dt) {
  asteroid.x += asteroid.vx * dt;
  asteroid.y += asteroid.vy * dt;
  asteroid.rotation += asteroid.angularVelocity * dt;
}

/**
 * Draw an asteroid as a white wireframe polygon on a canvas 2D context.
 */
function drawAsteroid(ctx, asteroid) {
  const { x, y, rotation, shape, strokeWidth } = asteroid;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = strokeWidth;

  ctx.beginPath();
  ctx.moveTo(shape[0][0], shape[0][1]);
  for (let i = 1; i < shape.length; i++) {
    ctx.lineTo(shape[i][0], shape[i][1]);
  }
  ctx.closePath();
  ctx.stroke();

  ctx.restore();
}

// ===== camera.js =====
/**
 * Create a camera state object.
 */
function createCamera(x, y, rotation) {
  return { x, y, rotation };
}

/**
 * Apply camera transform to a canvas context.
 * Saves context, then applies: translate to screen center →
 * rotate by -rotation → translate by (-x, -y).
 */
function applyCameraTransform(ctx, camera, viewportW, viewportH) {
  ctx.save();
  ctx.translate(viewportW / 2, viewportH / 2);
  ctx.rotate(-camera.rotation);
  ctx.translate(-camera.x, -camera.y);
}

/**
 * Reset camera transform by restoring the saved context.
 */
function resetCameraTransform(ctx) {
  ctx.restore();
}

/**
 * Compute the axis-aligned bounding box of the rotated viewport in world-space.
 * Returns { minX, maxX, minY, maxY } with optional padding margin.
 */
function getViewportBounds(camera, viewportW, viewportH, margin = 0) {
  const cosA = Math.abs(Math.cos(camera.rotation));
  const sinA = Math.abs(Math.sin(camera.rotation));
  const halfW = (viewportW * cosA + viewportH * sinA) / 2;
  const halfH = (viewportW * sinA + viewportH * cosA) / 2;
  return {
    minX: camera.x - halfW - margin,
    maxX: camera.x + halfW + margin,
    minY: camera.y - halfH - margin,
    maxY: camera.y + halfH + margin,
  };
}

/**
 * Convert a world-space coordinate to screen-space.
 * Returns [screenX, screenY].
 */
function worldToScreen(wx, wy, camera, viewportW, viewportH) {
  // Translate by (-camera.x, -camera.y)
  const dx = wx - camera.x;
  const dy = wy - camera.y;
  // Rotate by -camera.rotation
  const cosR = Math.cos(-camera.rotation);
  const sinR = Math.sin(-camera.rotation);
  const rx = dx * cosR - dy * sinR;
  const ry = dx * sinR + dy * cosR;
  // Translate to screen center
  return [rx + viewportW / 2, ry + viewportH / 2];
}

/**
 * Convert a screen-space coordinate to world-space.
 * Returns [worldX, worldY]. Inverse of worldToScreen.
 */
function screenToWorld(sx, sy, camera, viewportW, viewportH) {
  // Reverse translate from screen center
  const cx = sx - viewportW / 2;
  const cy = sy - viewportH / 2;
  // Reverse rotate (rotate by +camera.rotation)
  const cosR = Math.cos(camera.rotation);
  const sinR = Math.sin(camera.rotation);
  const rx = cx * cosR - cy * sinR;
  const ry = cx * sinR + cy * cosR;
  // Reverse translate
  return [rx + camera.x, ry + camera.y];
}

// ===== energy.js =====
/**
 * Compute kinetic energy for a single asteroid.
 * KE = 0.5 * mass * speed², where mass = collisionRadius²
 */
function computeKE(asteroid) {
  const mass = asteroid.collisionRadius * asteroid.collisionRadius;
  return 0.5 * mass * (asteroid.vx * asteroid.vx + asteroid.vy * asteroid.vy);
}

/**
 * Sum kinetic energy across all asteroids.
 */
function computeTotalKE(asteroids) {
  let total = 0;
  for (const a of asteroids) {
    total += computeKE(a);
  }
  return total;
}

/**
 * Compute a speed multiplier for new spawns to sustain system energy.
 * Returns clamp(sqrt(targetKE / actualKE), 1.0, 1.5).
 */
function computeSpeedBoost(
  baselineKEPerAsteroid,
  targetCount,
  asteroids,
) {
  const targetKE = baselineKEPerAsteroid * targetCount;
  if (targetKE <= 0) return 1.0;

  const actualKE = computeTotalKE(asteroids);
  if (actualKE <= 0) return 1.5;
  if (actualKE >= targetKE) return 1.0;

  return Math.min(Math.sqrt(targetKE / actualKE), 1.5);
}

// ===== input.js =====
/**
 * Create a fresh input state with all flags false.
 */
function createInputState() {
  return {
    thrust: false,
    rotateLeft: false,
    rotateRight: false,
    brake: false,
    fire: false,
  };
}

const KEY_MAP = {
  w: 'thrust',
  arrowup: 'thrust',
  a: 'rotateLeft',
  arrowleft: 'rotateLeft',
  d: 'rotateRight',
  arrowright: 'rotateRight',
  s: 'brake',
  arrowdown: 'brake',
  ' ': 'fire',
};

function resolveKey(key) {
  return KEY_MAP[key.toLowerCase()] || null;
}

/**
 * Handle a keydown event — set the corresponding input flag to true.
 */
function handleKeyDown(state, key) {
  const flag = resolveKey(key);
  if (flag) state[flag] = true;
}

/**
 * Handle a keyup event — clear the corresponding input flag.
 */
function handleKeyUp(state, key) {
  const flag = resolveKey(key);
  if (flag) state[flag] = false;
}

/**
 * Copy input flags onto ship control booleans.
 */
function applyInput(inputState, ship) {
  ship.thrust = inputState.thrust;
  ship.rotatingLeft = inputState.rotateLeft;
  ship.rotatingRight = inputState.rotateRight;
  ship.braking = inputState.brake;
  ship.fire = inputState.fire;
}

// ===== main.js =====





/**
 * Calculate delta time in seconds between two timestamps (ms).
 * Caps at 0.1s to avoid spiral-of-death after tab backgrounding.
 * Never returns negative values.
 */
function calculateDeltaTime(currentTimestamp, previousTimestamp) {
  const dtSeconds = (currentTimestamp - previousTimestamp) / 1000;
  return Math.min(Math.max(dtSeconds, 0), 0.1);
}

/**
 * Create an animation loop state object.
 * Call loop.tick(timestamp) each frame from requestAnimationFrame.
 * First tick returns dt=0 (no previous frame to diff against).
 */
function createLoop() {
  let started = false;

  const state = {
    frameCount: 0,
    lastTimestamp: 0,

    tick(timestamp) {
      let dt = 0;
      if (started) {
        dt = calculateDeltaTime(timestamp, state.lastTimestamp);
      }
      started = true;
      state.lastTimestamp = timestamp;
      state.frameCount++;
      return dt;
    },
  };
  return state;
}

/**
 * Bootstrap the application: set up canvas, resize handling, and start the loop.
 */
const BASE_ASTEROID_COUNT = 40;
function startApp() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  let logicalSize = setupHiDPICanvas(
    canvas,
    ctx,
    window.innerWidth,
    window.innerHeight,
    dpr,
  );

  const loop = createLoop();
  let starLayers = createParallaxLayers(logicalSize.width, logicalSize.height);
  const initialBounds = {
    minX: 0,
    maxX: logicalSize.width,
    minY: 0,
    maxY: logicalSize.height,
  };
  const sim = createSimulation(initialBounds);
  const playerShip = createShip({
    x: logicalSize.width / 2,
    y: logicalSize.height / 2,
    heading: -Math.PI / 2,
  });
  const camera = createCamera(
    playerShip.x,
    playerShip.y,
    playerShip.heading + Math.PI / 2,
  );
  const playerTrail = createTrail();
  let prevCameraX = camera.x;
  let prevCameraY = camera.y;
  let prevCameraRotation = camera.rotation;
  const inputState = createInputState();
  const loaded = loadSettings();
  const settings = createSettings(loaded);
  let elapsedTime = 0;

  // Settings UI
  const ui = createSettingsUI(document.body, settings);
  // Apply loaded settings to simulation, ship, and starfield
  sim.targetCount = Math.round(BASE_ASTEROID_COUNT * settings.asteroidDensity);
  playerShip.thrustPower = settings.thrustPower;
  if (settings.starLayers !== 3) {
    starLayers = createParallaxLayers(
      logicalSize.width,
      logicalSize.height,
      settings.starLayers,
    );
  }
  if (settings.starDirection !== 'left') {
    redistributeStars(
      starLayers,
      logicalSize.width,
      logicalSize.height,
      settings.starDirection,
    );
  }

  ui.onChange = (name, value) => {
    settings[name] = value;
    if (name === 'starLayers') {
      starLayers = createParallaxLayers(
        logicalSize.width,
        logicalSize.height,
        value,
      );
    }
    if (name === 'thrustPower') {
      playerShip.thrustPower = value;
    }
    if (name === 'starDirection') {
      redistributeStars(
        starLayers,
        logicalSize.width,
        logicalSize.height,
        value,
      );
    }
    saveSettings(settings);
  };

  // Resize: update canvas with HiDPI and redistribute stars
  window.addEventListener('resize', () => {
    logicalSize = setupHiDPICanvas(
      canvas,
      ctx,
      window.innerWidth,
      window.innerHeight,
      dpr,
    );
    redistributeStars(
      starLayers,
      logicalSize.width,
      logicalSize.height,
      settings.starDirection,
    );
  });

  // Auto-hide: reset gear timer on any mouse movement
  window.addEventListener('mousemove', () => {
    settings.gearTimer = 0;
    if (settings.panelOpen) {
      settings.panelTimer = 0;
    }
  });

  // Keyboard input for ship controls
  window.addEventListener('keydown', (e) => handleKeyDown(inputState, e.key));
  window.addEventListener('keyup', (e) => handleKeyUp(inputState, e.key));

  function frame(timestamp) {
    const dt = loop.tick(timestamp);
    elapsedTime += dt;

    // Apply speed multiplier to simulation dt
    const scaledDt = dt * settings.speedMultiplier;

    updateAutoHide(settings, dt);

    // When panel is open, button acts as close icon — always fully visible
    if (settings.panelOpen) {
      ui.gearButton.style.opacity = '0.8';
      ui.gearButton.style.pointerEvents = 'auto';
    } else {
      ui.gearButton.style.opacity = settings.gearVisible
        ? settings.gearHovered
          ? '0.8'
          : '0.3'
        : '0';
      ui.gearButton.style.pointerEvents = settings.gearVisible
        ? 'auto'
        : 'none';
    }
    ui.panel.style.display = settings.panelOpen ? 'block' : 'none';
    ui.gearButton.textContent = settings.panelOpen ? '\u2715' : '\u2630';

    // Ship input + update
    applyInput(inputState, playerShip);
    updateShip(playerShip, scaledDt);
    updateTrail(
      playerTrail,
      playerShip.x,
      playerShip.y,
      playerShip.heading,
      playerShip.thrust,
    );

    // Camera follows ship (PI/2 offset so ship nose points UP on screen)
    camera.x = playerShip.x;
    camera.y = playerShip.y;
    camera.rotation = playerShip.heading + Math.PI / 2;

    // Compute camera deltas and rotate to screen space for starfield parallax
    const cameraDeltaX = camera.x - prevCameraX;
    const cameraDeltaY = camera.y - prevCameraY;
    // Normalize rotation delta to [-PI, PI] so heading wrapping doesn't
    // produce a ±2PI spike that snaps stars across the screen
    let cameraDeltaRotation = camera.rotation - prevCameraRotation;
    while (cameraDeltaRotation > Math.PI) cameraDeltaRotation -= 2 * Math.PI;
    while (cameraDeltaRotation < -Math.PI) cameraDeltaRotation += 2 * Math.PI;
    const cosR = Math.cos(-camera.rotation);
    const sinR = Math.sin(-camera.rotation);
    const screenDx = cameraDeltaX * cosR - cameraDeltaY * sinR;
    const screenDy = cameraDeltaX * sinR + cameraDeltaY * cosR;

    updateStarLayersCamera(
      starLayers,
      screenDx,
      screenDy,
      cameraDeltaRotation,
      logicalSize.width,
      logicalSize.height,
    );

    prevCameraX = camera.x;
    prevCameraY = camera.y;
    prevCameraRotation = camera.rotation;
    // Tight viewport bounds (no margin — simulation handles its own zones)
    const viewportBounds = getViewportBounds(
      camera,
      logicalSize.width,
      logicalSize.height,
    );
    // Target count uses zone area (viewport + border) for proportional density
    const spawnBounds = computeSpawnBounds(viewportBounds);
    const zoneArea =
      (spawnBounds.maxX - spawnBounds.minX) *
      (spawnBounds.maxY - spawnBounds.minY);
    const viewportArea = logicalSize.width * logicalSize.height;
    sim.targetCount = Math.round(
      BASE_ASTEROID_COUNT *
        settings.asteroidDensity *
        (zoneArea / viewportArea),
    );
    updateSimulation(
      sim,
      scaledDt,
      viewportBounds,
      playerShip.vx,
      playerShip.vy,
    );

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, logicalSize.width, logicalSize.height);

    drawParallaxLayers(ctx, starLayers, elapsedTime);

    applyCameraTransform(ctx, camera, logicalSize.width, logicalSize.height);

    for (const asteroid of sim.asteroids) {
      drawAsteroid(ctx, asteroid);
    }

    drawTrail(ctx, playerTrail);
    drawShip(ctx, playerShip);

    resetCameraTransform(ctx);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

// ===== physics.js =====
/**
 * Detect all colliding asteroid pairs using circle-circle collision.
 * Returns an array of [asteroidA, asteroidB] pairs.
 * A collision occurs when distance between centers < sum of collision radii.
 * Exactly touching (distance === sum) is NOT a collision.
 */
function detectCollisions(asteroids) {
  const pairs = [];
  for (let i = 0; i < asteroids.length; i++) {
    for (let j = i + 1; j < asteroids.length; j++) {
      const a = asteroids[i];
      const b = asteroids[j];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const radiiSum = a.collisionRadius + b.collisionRadius;
      if (dist < radiiSum) {
        pairs.push([a, b]);
      }
    }
  }
  return pairs;
}

/**
 * Separate two overlapping asteroids along the collision normal.
 * Lighter asteroid (smaller collisionRadius²) is pushed proportionally more.
 */
function separateOverlap(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist === 0) {
    // Perfectly coincident — push apart along arbitrary axis
    b.x += a.collisionRadius + b.collisionRadius;
    return;
  }

  const overlap = a.collisionRadius + b.collisionRadius - dist;
  if (overlap <= 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const massA = a.collisionRadius * a.collisionRadius;
  const massB = b.collisionRadius * b.collisionRadius;
  const totalMass = massA + massB;

  // Lighter asteroid moves more
  const pushA = overlap * (massB / totalMass);
  const pushB = overlap * (massA / totalMass);

  a.x -= nx * pushA;
  a.y -= ny * pushA;
  b.x += nx * pushB;
  b.y += ny * pushB;
}

/**
 * Resolve an elastic collision between two asteroids.
 * Uses 2D elastic collision formula with mass = collisionRadius².
 * Applies ±1% random perturbation and angular velocity nudge.
 */
function resolveCollision(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist === 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const massA = a.collisionRadius * a.collisionRadius;
  const massB = b.collisionRadius * b.collisionRadius;

  // Relative velocity along collision normal
  const dvx = a.vx - b.vx;
  const dvy = a.vy - b.vy;
  const dvDotN = dvx * nx + dvy * ny;

  // Don't resolve if asteroids are moving apart
  if (dvDotN <= 0) return;

  const totalMass = massA + massB;

  // 2D elastic collision impulse with ±1% perturbation on magnitude.
  // Using a single factor for both asteroids preserves momentum exactly
  // while adding enough variation to prevent repeating collision patterns.
  // Kept at ±1% to maintain KE conservation within 5%.
  const perturbation = 1 + (Math.random() * 0.02 - 0.01);
  const impulseA = ((2 * massB) / totalMass) * dvDotN * perturbation;
  const impulseB = ((2 * massA) / totalMass) * dvDotN * perturbation;

  a.vx -= impulseA * nx;
  a.vy -= impulseA * ny;
  b.vx += impulseB * nx;
  b.vy += impulseB * ny;

  // Nudge angular velocity slightly on impact
  const angularNudge = () => Math.random() * 0.2 - 0.1;
  a.angularVelocity += angularNudge();
  b.angularVelocity += angularNudge();
}

// ===== renderer.js =====
/**
 * Set up a canvas for HiDPI rendering.
 * Sets internal resolution to CSS size × dpr, applies CSS size,
 * and scales the context so all drawing uses CSS (logical) coordinates.
 * Returns the logical size { width, height } for use by game systems.
 */
function setupHiDPICanvas(canvas, ctx, cssWidth, cssHeight, dpr) {
  canvas.width = cssWidth * dpr;
  canvas.height = cssHeight * dpr;
  canvas.style.width = `${cssWidth}px`;
  canvas.style.height = `${cssHeight}px`;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { width: cssWidth, height: cssHeight };
}

// ===== settings.js =====
/**
 * Configuration for each setting: range, step, default, and display label.
 */
const SETTINGS_CONFIG = {
  asteroidDensity: {
    min: 0.5,
    max: 3.0,
    step: 0.1,
    default: 1.0,
    label: 'Density',
  },
  speedMultiplier: {
    min: 0.2,
    max: 3.0,
    step: 0.1,
    default: 1.0,
    label: 'Speed',
  },
  starLayers: { min: 3, max: 6, step: 1, default: 3, label: 'Star Layers' },
  thrustPower: {
    min: 1000,
    max: 5000,
    step: 50,
    default: 2000,
    label: 'Thrust',
  },
  starDirection: {
    options: ['left', 'right', 'up', 'down', 'radial'],
    default: 'left',
    label: 'Direction',
  },
};

const STORAGE_KEY = 'asteroidSettings';

/**
 * Create settings state with defaults, optionally applying overrides.
 */
function createSettings(overrides = {}) {
  return {
    asteroidDensity:
      overrides.asteroidDensity ?? SETTINGS_CONFIG.asteroidDensity.default,
    speedMultiplier:
      overrides.speedMultiplier ?? SETTINGS_CONFIG.speedMultiplier.default,
    starLayers: overrides.starLayers ?? SETTINGS_CONFIG.starLayers.default,
    thrustPower: overrides.thrustPower ?? SETTINGS_CONFIG.thrustPower.default,
    starDirection:
      overrides.starDirection ?? SETTINGS_CONFIG.starDirection.default,
    panelOpen: false,
    gearVisible: true,
    gearHovered: false,
    gearTimer: 0,
    panelTimer: 0,
  };
}

/**
 * Save the 3 tunable settings to localStorage.
 */
function saveSettings(settings) {
  const data = {
    asteroidDensity: settings.asteroidDensity,
    speedMultiplier: settings.speedMultiplier,
    starLayers: settings.starLayers,
    thrustPower: settings.thrustPower,
    starDirection: settings.starDirection,
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

/**
 * Load settings from localStorage. Returns an object with tunable values.
 * Falls back to defaults if storage is empty, corrupt, or contains invalid values.
 */
function loadSettings() {
  const defaults = {
    asteroidDensity: SETTINGS_CONFIG.asteroidDensity.default,
    speedMultiplier: SETTINGS_CONFIG.speedMultiplier.default,
    starLayers: SETTINGS_CONFIG.starLayers.default,
    thrustPower: SETTINGS_CONFIG.thrustPower.default,
    starDirection: SETTINGS_CONFIG.starDirection.default,
  };

  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw === null) return defaults;

    const parsed = JSON.parse(raw);
    if (
      typeof parsed !== 'object' ||
      parsed === null ||
      Array.isArray(parsed)
    ) {
      return defaults;
    }

    const result = {};
    for (const name of Object.keys(defaults)) {
      const config = SETTINGS_CONFIG[name];
      const val = parsed[name];

      if (config.options) {
        // String enum setting (e.g. starDirection)
        result[name] = config.options.includes(val) ? val : defaults[name];
      } else if (typeof val === 'number' && !Number.isNaN(val)) {
        result[name] = clampSetting(name, val);
      } else {
        result[name] = defaults[name];
      }
    }
    return result;
  } catch {
    return defaults;
  }
}

/**
 * Clamp a setting value to its valid range.
 * Integer settings (step=1) are rounded to the nearest integer.
 */
function clampSetting(name, value) {
  const config = SETTINGS_CONFIG[name];
  let v = Number(value);
  if (config.step >= 1) v = Math.round(v);
  return Math.min(config.max, Math.max(config.min, v));
}

/**
 * Update auto-hide timers. Call each frame with dt.
 * - Gear hides after 3s of no mouse movement (caller resets gearTimer to 0 on mouse move)
 * - Panel closes after 4s of no mouse activity over it (caller resets panelTimer to 0)
 */
function updateAutoHide(settings, dt) {
  settings.gearTimer += dt;
  if (settings.gearTimer < 3) {
    settings.gearVisible = true;
  } else {
    settings.gearVisible = false;
  }

  if (settings.panelOpen) {
    settings.panelTimer += dt;
    if (settings.panelTimer >= 4) {
      settings.panelOpen = false;
    }
  }
}

/**
 * Format a setting value for display.
 */
function formatValue(name, value) {
  if (name === 'speedMultiplier' || name === 'asteroidDensity')
    return `${value.toFixed(1)}x`;
  return String(value);
}

/**
 * Create the settings UI: gear button, panel with sliders.
 * Returns { gearButton, panel, sliders, valueDisplays, onChange }.
 */
function createSettingsUI(container, settings) {
  // Hamburger menu button
  const gearButton = document.createElement('button');
  gearButton.textContent = '\u2630';
  gearButton.style.cssText =
    'position:fixed;top:20px;left:20px;background:none;border:none;' +
    'color:#fff;font-size:28px;cursor:pointer;opacity:0.3;z-index:1001;' +
    'padding:8px;line-height:1;transition:opacity 0.2s;';
  gearButton.addEventListener('mouseenter', () => {
    settings.gearHovered = true;
    gearButton.style.opacity = '0.8';
  });
  gearButton.addEventListener('mouseleave', () => {
    settings.gearHovered = false;
    gearButton.style.opacity = '0.3';
  });
  container.appendChild(gearButton);

  // Panel
  const panel = document.createElement('div');
  panel.style.cssText =
    'position:fixed;top:0;left:0;width:260px;height:100%;' +
    'background:rgba(0,0,0,0.85);color:#fff;font-family:"Courier New",monospace;' +
    'font-size:14px;padding:70px 20px 24px;box-sizing:border-box;z-index:1000;' +
    'display:none;';
  container.appendChild(panel);

  const title = document.createElement('div');
  title.textContent = 'Settings';
  title.style.cssText = 'font-size:18px;margin-bottom:24px;';
  panel.appendChild(title);

  let _onChange = () => {};

  const sliders = {};
  const valueDisplays = {};

  let directionSelect;

  for (const [name, config] of Object.entries(SETTINGS_CONFIG)) {
    if (config.options) {
      // Enum setting — render as a <select> dropdown
      const row = document.createElement('div');
      row.style.cssText = 'margin-bottom:20px;';

      const label = document.createElement('label');
      label.style.cssText = 'display:block;margin-bottom:6px;';
      label.textContent = config.label;

      const select = document.createElement('select');
      select.style.cssText =
        'width:100%;background:#222;color:#fff;border:1px solid #555;' +
        'padding:4px;font-family:"Courier New",monospace;font-size:14px;';
      for (const opt of config.options) {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        select.appendChild(option);
      }
      select.value = settings[name];
      directionSelect = select;

      select.addEventListener('change', () => {
        _onChange(name, select.value);
      });

      row.appendChild(label);
      row.appendChild(select);
      panel.appendChild(row);
      continue;
    }

    // Numeric setting — render as a slider
    const row = document.createElement('div');
    row.style.cssText = 'margin-bottom:20px;';

    const label = document.createElement('label');
    label.style.cssText = 'display:block;margin-bottom:6px;';

    const labelText = document.createElement('span');
    labelText.textContent = config.label;

    const valueSpan = document.createElement('span');
    valueSpan.textContent = formatValue(name, settings[name]);
    valueSpan.style.cssText = 'float:right;';
    valueDisplays[name] = valueSpan;

    label.appendChild(labelText);
    label.appendChild(valueSpan);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = String(config.min);
    slider.max = String(config.max);
    slider.step = String(config.step);
    slider.value = String(settings[name]);
    slider.style.cssText = 'width:100%;';
    sliders[name] = slider;

    slider.addEventListener('input', () => {
      const val = clampSetting(name, slider.value);
      valueSpan.textContent = formatValue(name, val);
      _onChange(name, val);
    });

    row.appendChild(label);
    row.appendChild(slider);
    panel.appendChild(row);
  }

  // Button click toggles panel; swap icon between ☰ and ✕
  gearButton.addEventListener('click', () => {
    settings.panelOpen = !settings.panelOpen;
    settings.panelTimer = 0;
    panel.style.display = settings.panelOpen ? 'block' : 'none';
    gearButton.textContent = settings.panelOpen ? '\u2715' : '\u2630';
  });

  // Escape closes panel
  const onKeydown = (e) => {
    if (e.key === 'Escape') {
      settings.panelOpen = false;
      panel.style.display = 'none';
      gearButton.textContent = '\u2630';
    }
  };
  document.addEventListener('keydown', onKeydown);

  return {
    gearButton,
    panel,
    sliders,
    valueDisplays,
    directionSelect,
    set onChange(fn) {
      _onChange = fn;
    },
    get onChange() {
      return _onChange;
    },
    destroy() {
      document.removeEventListener('keydown', onKeydown);
    },
  };
}

// ===== ship.js =====
/**
 * Ship size constant (half-height of the chevron shape).
 * Used for rendering and later for collision radius.
 */
const SHIP_SIZE = 15;

/** Rotation speed in radians per second. */
const ROTATION_SPEED = 4.0;

/** Thrust acceleration in pixels/s². */
const THRUST_POWER = 2000;

/** Drag coefficient per second (mild friction). */
const DRAG = 0.5;

/** Braking deceleration in pixels/s². */
const BRAKE_POWER = 200;

/** Maximum ship speed in pixels/s. */
const MAX_SPEED = 400;

/** Maximum number of trail points (~2 seconds at 60 fps). */
const TRAIL_MAX_LENGTH = 120;

/** Opacity of the newest trail segment. */
const TRAIL_MAX_OPACITY = 0.4;

/** Dark orange exhaust color. */
const TRAIL_COLOR = { r: 255, g: 120, b: 0 };

/**
 * Normalize an angle to the range [-PI, PI].
 */
function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create a ship entity.
 */
function createShip({ x, y, heading }) {
  return {
    x,
    y,
    vx: 0,
    vy: 0,
    heading,
    alive: true,
    thrust: false,
    rotatingLeft: false,
    rotatingRight: false,
    braking: false,
    fire: false,
  };
}

/**
 * Update ship state for one frame.
 * Applies rotation, thrust, braking, drag, speed cap, and position update.
 */
function updateShip(ship, dt) {
  // 1. Rotation
  if (ship.rotatingLeft) ship.heading -= ROTATION_SPEED * dt;
  if (ship.rotatingRight) ship.heading += ROTATION_SPEED * dt;
  ship.heading = normalizeAngle(ship.heading);

  // 2. Thrust — accelerate in heading direction
  if (ship.thrust) {
    const power = ship.thrustPower ?? THRUST_POWER;
    ship.vx += Math.cos(ship.heading) * power * dt;
    ship.vy += Math.sin(ship.heading) * power * dt;
  }

  // 3. Braking — decelerate opposite to velocity direction
  if (ship.braking) {
    const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
    if (speed > 0) {
      const decel = Math.min(BRAKE_POWER * dt, speed);
      ship.vx -= (ship.vx / speed) * decel;
      ship.vy -= (ship.vy / speed) * decel;
    }
  }

  // 4. Drag — friction always applied
  ship.vx *= 1 - DRAG * dt;
  ship.vy *= 1 - DRAG * dt;

  // 5. Speed cap
  const currentSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  if (currentSpeed > MAX_SPEED) {
    ship.vx = (ship.vx / currentSpeed) * MAX_SPEED;
    ship.vy = (ship.vy / currentSpeed) * MAX_SPEED;
  }

  // 6. Position update
  ship.x += ship.vx * dt;
  ship.y += ship.vy * dt;
}

/**
 * Draw a classic Asteroids chevron/triangle at the ship's position,
 * rotated by its heading. White wireframe, no fill.
 */
function drawShip(ctx, ship) {
  if (!ship.alive) return;

  const s = SHIP_SIZE;

  ctx.save();
  ctx.translate(ship.x, ship.y);
  ctx.rotate(ship.heading);

  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 1.5;

  // Chevron shape: nose at right (+x), two rear points, notch in back
  ctx.beginPath();
  ctx.moveTo(s, 0); // nose
  ctx.lineTo(-s, -s * 0.7); // top-left wing
  ctx.lineTo(-s * 0.5, 0); // rear notch
  ctx.lineTo(-s, s * 0.7); // bottom-left wing
  ctx.closePath();
  ctx.stroke();

  ctx.restore();
}

/**
 * Create a new motion trail.
 */
function createTrail() {
  return { points: [] };
}

/**
 * Record the ship's rear-nozzle position in the trail.
 * Only records when thrusting; otherwise the existing trail fades naturally.
 * Evicts the oldest point when the trail exceeds TRAIL_MAX_LENGTH.
 */
function updateTrail(trail, x, y, heading, isThrusting) {
  if (!isThrusting) return;
  const nozzleOffset = SHIP_SIZE * 0.5;
  const rearX = x - Math.cos(heading) * nozzleOffset;
  const rearY = y - Math.sin(heading) * nozzleOffset;
  trail.points.push({ x: rearX, y: rearY });
  if (trail.points.length > TRAIL_MAX_LENGTH) {
    trail.points.shift();
  }
}

/**
 * Draw the exhaust trail as fading dark orange line segments.
 * Alpha increases linearly from 0 (oldest) to TRAIL_MAX_OPACITY (newest).
 */
function drawTrail(ctx, trail) {
  if (trail.points.length < 2) return;

  ctx.lineWidth = 1;
  const { r, g, b } = TRAIL_COLOR;
  const len = trail.points.length;

  for (let i = 1; i < len; i++) {
    const alpha = (i / (len - 1)) * TRAIL_MAX_OPACITY;
    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
    ctx.beginPath();
    ctx.moveTo(trail.points[i - 1].x, trail.points[i - 1].y);
    ctx.lineTo(trail.points[i].x, trail.points[i].y);
    ctx.stroke();
  }
}

// ===== simulation.js =====

const SPAWN_BORDER = 300; // px, width of border ring
const RECYCLE_MARGIN = 5; // px, hysteresis beyond spawn bounds
const MAX_SPAWN_PER_FRAME = 10; // cap spawns per frame
const BASE_EDGE_WEIGHT = 100; // min weight per edge (prevents starvation)

/**
 * Expand viewport bounds by SPAWN_BORDER on each side to get spawn bounds.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @returns {object} - { minX, maxX, minY, maxY }
 */
function computeSpawnBounds(viewportBounds) {
  return {
    minX: viewportBounds.minX - SPAWN_BORDER,
    maxX: viewportBounds.maxX + SPAWN_BORDER,
    minY: viewportBounds.minY - SPAWN_BORDER,
    maxY: viewportBounds.maxY + SPAWN_BORDER,
  };
}

/**
 * Compute direction-biased edge selection weights from ship velocity.
 * Edge outward normals: left=(-1,0), right=(+1,0), top=(0,-1), bottom=(0,+1)
 * weight[edge] = max(dot(shipVelocity, edgeOutward), 0) + BASE_EDGE_WEIGHT
 * Normalized to sum to 1.0.
 * @param {number} shipVx
 * @param {number} shipVy
 * @returns {number[]} - [left, right, top, bottom] weights summing to 1.0
 */
function computeEdgeWeights(shipVx, shipVy) {
  const raw = [
    Math.max(-shipVx, 0) + BASE_EDGE_WEIGHT, // left: outward = (-1, 0)
    Math.max(shipVx, 0) + BASE_EDGE_WEIGHT, // right: outward = (+1, 0)
    Math.max(-shipVy, 0) + BASE_EDGE_WEIGHT, // top: outward = (0, -1)
    Math.max(shipVy, 0) + BASE_EDGE_WEIGHT, // bottom: outward = (0, +1)
  ];
  const total = raw[0] + raw[1] + raw[2] + raw[3];
  return [raw[0] / total, raw[1] / total, raw[2] / total, raw[3] / total];
}

/**
 * Pick an edge using cumulative weighted random selection.
 * @param {number[]} weights - [left, right, top, bottom] summing to 1.0
 * @returns {number} - 0=left, 1=right, 2=top, 3=bottom
 */
function pickWeightedEdge(weights) {
  const r = Math.random();
  let cumulative = 0;
  for (let i = 0; i < 3; i++) {
    cumulative += weights[i];
    if (r < cumulative) return i;
  }
  return 3;
}

/**
 * Pick a random size class with the spec distribution:
 * ~20% large (50–80), ~40% medium (25–49), ~40% small (10–24)
 */
function randomRadius() {
  const roll = Math.random();
  if (roll < 0.2) return 50 + Math.random() * 30;
  if (roll < 0.6) return 25 + Math.random() * 24;
  return 10 + Math.random() * 14;
}

/**
 * Get speed range for a given radius.
 * Large (50–80): 15–30 px/s, Medium (25–49): 30–60 px/s, Small (10–24): 60–120 px/s
 */
function speedForRadius(radius) {
  if (radius >= 50) return 15 + Math.random() * 15;
  if (radius >= 25) return 30 + Math.random() * 30;
  return 60 + Math.random() * 60;
}

/**
 * Check if an asteroid is outside the spawn zone (past spawn bounds + recycle margin).
 * @param {object} asteroid
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @returns {boolean}
 */
function isOutsideZone(asteroid, spawnBounds) {
  const { x, y, radius } = asteroid;
  return (
    x + radius + RECYCLE_MARGIN < spawnBounds.minX ||
    x - radius - RECYCLE_MARGIN > spawnBounds.maxX ||
    y + radius + RECYCLE_MARGIN < spawnBounds.minY ||
    y - radius - RECYCLE_MARGIN > spawnBounds.maxY
  );
}

/**
 * Spawn a new asteroid in the border ring (outside viewport, inside spawn bounds).
 * Uses direction-biased edge selection and aims roughly toward viewport center.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @param {number[]} edgeWeights - [left, right, top, bottom]
 * @param {number} speedMultiplier
 * @returns {object} asteroid
 */
function spawnAsteroidInBorder(
  viewportBounds,
  spawnBounds,
  edgeWeights,
  speedMultiplier = 1.0,
) {
  const radius = randomRadius();
  const speed = speedForRadius(radius) * speedMultiplier;
  const edge = pickWeightedEdge(edgeWeights);

  const vpCenterX = (viewportBounds.minX + viewportBounds.maxX) / 2;
  const vpCenterY = (viewportBounds.minY + viewportBounds.maxY) / 2;

  let x, y;

  switch (edge) {
    case 0: // left border: between spawnBounds.minX and viewportBounds.minX
      x =
        spawnBounds.minX +
        Math.random() * (viewportBounds.minX - spawnBounds.minX);
      y =
        spawnBounds.minY +
        Math.random() * (spawnBounds.maxY - spawnBounds.minY);
      break;
    case 1: // right border: between viewportBounds.maxX and spawnBounds.maxX
      x =
        viewportBounds.maxX +
        Math.random() * (spawnBounds.maxX - viewportBounds.maxX);
      y =
        spawnBounds.minY +
        Math.random() * (spawnBounds.maxY - spawnBounds.minY);
      break;
    case 2: // top border: between spawnBounds.minY and viewportBounds.minY
      x =
        spawnBounds.minX +
        Math.random() * (spawnBounds.maxX - spawnBounds.minX);
      y =
        spawnBounds.minY +
        Math.random() * (viewportBounds.minY - spawnBounds.minY);
      break;
    default: // bottom border: between viewportBounds.maxY and spawnBounds.maxY
      x =
        spawnBounds.minX +
        Math.random() * (spawnBounds.maxX - spawnBounds.minX);
      y =
        viewportBounds.maxY +
        Math.random() * (spawnBounds.maxY - viewportBounds.maxY);
      break;
  }

  // Aim toward viewport center with ±30° spread
  const baseAngle = Math.atan2(vpCenterY - y, vpCenterX - x);
  const spread = (Math.random() * 2 - 1) * (Math.PI / 6);
  const angle = baseAngle + spread;

  return createAsteroid({
    x,
    y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius,
  });
}

/**
 * Spawn a new asteroid at a random position within the full zone (spawn bounds),
 * with a random direction. Used for initial population.
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @param {number} speedMultiplier
 * @returns {object} asteroid
 */
function spawnAsteroidInZone(spawnBounds, speedMultiplier = 1.0) {
  const radius = randomRadius();
  const speed = speedForRadius(radius) * speedMultiplier;
  const x =
    spawnBounds.minX + Math.random() * (spawnBounds.maxX - spawnBounds.minX);
  const y =
    spawnBounds.minY + Math.random() * (spawnBounds.maxY - spawnBounds.minY);
  const angle = Math.random() * Math.PI * 2;

  return createAsteroid({
    x,
    y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius,
  });
}

/**
 * Create the simulation state with an initial population of asteroids.
 * Asteroids are distributed across the entire zone (viewport + border) for
 * immediate visibility and pre-populated border.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {number} targetCount
 */
function createSimulation(viewportBounds, targetCount = 20) {
  const spawnBounds = computeSpawnBounds(viewportBounds);
  const asteroids = [];
  for (let i = 0; i < targetCount; i++) {
    asteroids.push(spawnAsteroidInZone(spawnBounds));
  }

  const baselineKEPerAsteroid = computeTotalKE(asteroids) / asteroids.length;

  return {
    asteroids,
    targetCount,
    baselineKEPerAsteroid,
  };
}

/**
 * Update the simulation: move asteroids, resolve collisions, recycle outside zone,
 * spawn in border when below target with direction-biased edge selection.
 * @param {object} sim
 * @param {number} dt
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {number} shipVx - ship x velocity for direction bias
 * @param {number} shipVy - ship y velocity for direction bias
 */
function updateSimulation(
  sim,
  dt,
  viewportBounds,
  shipVx = 0,
  shipVy = 0,
) {
  // Move all asteroids
  for (const a of sim.asteroids) {
    updateAsteroid(a, dt);
  }

  // Detect and resolve collisions
  const pairs = detectCollisions(sim.asteroids);
  for (const [a, b] of pairs) {
    separateOverlap(a, b);
    resolveCollision(a, b);
  }

  // Compute spawn bounds and remove asteroids outside zone
  const spawnBounds = computeSpawnBounds(viewportBounds);
  sim.asteroids = sim.asteroids.filter((a) => !isOutsideZone(a, spawnBounds));

  // Compute energy boost
  const boost = computeSpeedBoost(
    sim.baselineKEPerAsteroid,
    sim.targetCount,
    sim.asteroids,
  );

  // Compute direction-biased edge weights
  const edgeWeights = computeEdgeWeights(shipVx, shipVy);

  // Spawn in border when below target
  const deficit = sim.targetCount - sim.asteroids.length;
  const toSpawn = Math.min(Math.max(deficit, 0), MAX_SPAWN_PER_FRAME);
  for (let i = 0; i < toSpawn; i++) {
    sim.asteroids.push(
      spawnAsteroidInBorder(viewportBounds, spawnBounds, edgeWeights, boost),
    );
  }
}

// ===== starfield.js =====
/**
 * Create a single star with random position, size, and brightness.
 */
function createStar(canvasWidth, canvasHeight, options = {}) {
  const minSize = options.minSize ?? 1;
  const maxSize = options.maxSize ?? 2;
  const minBrightness = options.minBrightness ?? 0.3;
  const maxBrightness = options.maxBrightness ?? 1.0;

  const brightness =
    minBrightness + Math.random() * (maxBrightness - minBrightness);

  const star = {
    x: Math.random() * canvasWidth,
    y: Math.random() * canvasHeight,
    size: minSize + Math.random() * (maxSize - minSize),
    brightness,
  };

  if (options.twinkle) {
    star.twinklePhase = Math.random() * Math.PI * 2;
    star.twinkleFreq = 0.3 + Math.random() * 2.7; // 0.3–3.0 Hz
    star.twinkleAmplitude = brightness * (0.1 + Math.random() * 0.2); // 10–30% of base
  }

  return star;
}

/**
 * Create a star layer: a collection of stars that scroll together at a given speed.
 */
function createStarLayer(
  count,
  canvasWidth,
  canvasHeight,
  options = {},
) {
  const stars = [];
  for (let i = 0; i < count; i++) {
    stars.push(createStar(canvasWidth, canvasHeight, options));
  }
  return {
    stars,
    speed: options.speed ?? 10,
  };
}

/**
 * Update a star layer: move all stars leftward by speed * dt.
 * Stars that exit the left edge wrap to the right edge with a new random y.
 */
function updateStarLayer(layer, dt, canvasWidth, canvasHeight) {
  const dx = layer.speed * dt;
  for (const star of layer.stars) {
    star.x -= dx;
    if (star.x < 0) {
      star.x = canvasWidth + star.x;
      star.y = Math.random() * canvasHeight;
    }
  }
}

/**
 * Compute the effective brightness of a star at a given elapsed time.
 * Stars without twinkle properties return their base brightness.
 * Formula: base + amplitude * sin(time * freq * 2π + phase), clamped to [0, 1].
 */
function applyTwinkle(star, elapsedTime) {
  if (star.twinklePhase == null) return star.brightness;
  const value =
    star.brightness +
    star.twinkleAmplitude *
      Math.sin(
        elapsedTime * star.twinkleFreq * Math.PI * 2 + star.twinklePhase,
      );
  return Math.min(1.0, Math.max(0, value));
}

// Layer presets for the default 3-layer parallax (far, mid, near).
// Base star counts are calibrated for 1920×1080; scaled by canvas area ratio.
const LAYER_PRESETS = [
  {
    baseCount: 100,
    minSize: 1,
    maxSize: 1,
    minBrightness: 0.3,
    maxBrightness: 0.5,
    minSpeed: 2,
    maxSpeed: 5,
  },
  {
    baseCount: 60,
    minSize: 1,
    maxSize: 2,
    minBrightness: 0.5,
    maxBrightness: 0.7,
    minSpeed: 8,
    maxSpeed: 15,
  },
  {
    baseCount: 30,
    minSize: 2,
    maxSize: 3,
    minBrightness: 0.7,
    maxBrightness: 1.0,
    minSpeed: 20,
    maxSpeed: 35,
  },
];

/**
 * Linearly interpolate between a and b by factor t (0–1).
 */
function lerp(a, b, t) {
  return a + (b - a) * t;
}

/**
 * Create parallax star layers. Default is 3 (far, mid, near).
 * Extra layers interpolate properties between far and near presets.
 */
function createParallaxLayers(
  canvasWidth,
  canvasHeight,
  layerCount = 3,
) {
  const baseArea = 1920 * 1080;
  const areaRatio = (canvasWidth * canvasHeight) / baseArea;
  const far = LAYER_PRESETS[0];
  const near = LAYER_PRESETS[2];

  const layers = [];
  for (let i = 0; i < layerCount; i++) {
    const t = layerCount === 1 ? 0 : i / (layerCount - 1);

    let preset;
    if (layerCount === 3 && i < 3) {
      preset = LAYER_PRESETS[i];
    } else {
      preset = {
        baseCount: Math.round(lerp(far.baseCount, near.baseCount, t)),
        minSize: lerp(far.minSize, near.minSize, t),
        maxSize: lerp(far.maxSize, near.maxSize, t),
        minBrightness: lerp(far.minBrightness, near.minBrightness, t),
        maxBrightness: lerp(far.maxBrightness, near.maxBrightness, t),
        minSpeed: lerp(far.minSpeed, near.minSpeed, t),
        maxSpeed: lerp(far.maxSpeed, near.maxSpeed, t),
      };
    }

    const count = Math.max(1, Math.round(preset.baseCount * areaRatio));
    // Use midpoint of speed range for interpolated layers to guarantee monotonic ordering;
    // the 3-layer preset path already has non-overlapping ranges so random is fine there.
    const speed =
      layerCount === 3 && i < 3
        ? preset.minSpeed + Math.random() * (preset.maxSpeed - preset.minSpeed)
        : (preset.minSpeed + preset.maxSpeed) / 2;

    const isNearLayer = i === layerCount - 1 && layerCount > 1;

    layers.push(
      createStarLayer(count, canvasWidth, canvasHeight, {
        speed,
        minSize: preset.minSize,
        maxSize: preset.maxSize,
        minBrightness: preset.minBrightness,
        maxBrightness: preset.maxBrightness,
        twinkle: !isNearLayer,
      }),
    );
  }
  return layers;
}

/**
 * Update a star layer with a configurable direction.
 * Directions: 'left', 'right', 'up', 'down', 'radial'.
 */
function updateStarLayerDirectional(
  layer,
  dt,
  canvasWidth,
  canvasHeight,
  direction,
) {
  const baseDelta = layer.speed * dt;
  if (baseDelta === 0) return;

  const cx = canvasWidth / 2;
  const cy = canvasHeight / 2;
  // Reference distance for perspective scaling (half the shorter dimension)
  const refDist = Math.min(canvasWidth, canvasHeight) / 2;

  for (const star of layer.stars) {
    if (direction === 'radial') {
      let dx = star.x - cx;
      let dy = star.y - cy;
      const dist = Math.hypot(dx, dy);

      if (dist < 0.01) {
        // Star at exact center — assign a random angle to push it outward
        const angle = Math.random() * Math.PI * 2;
        dx = Math.cos(angle);
        dy = Math.sin(angle);
      } else {
        dx /= dist;
        dy /= dist;
      }

      // Perspective acceleration: speed scales with distance from center
      const speedFactor = Math.max(dist / refDist, 0.05);
      star.x += dx * baseDelta * speedFactor;
      star.y += dy * baseDelta * speedFactor;

      // Brightness fades in with distance from center
      const newDist = Math.hypot(star.x - cx, star.y - cy);
      star.radialBrightness = Math.min(newDist / refDist, 1.0);

      // Recycle if outside canvas
      if (
        star.x < 0 ||
        star.x > canvasWidth ||
        star.y < 0 ||
        star.y > canvasHeight
      ) {
        const angle = Math.random() * Math.PI * 2;
        const spawnDist = 5 + Math.random() * 25;
        star.x = cx + Math.cos(angle) * spawnDist;
        star.y = cy + Math.sin(angle) * spawnDist;
        star.radialBrightness = spawnDist / refDist;
      }
    } else {
      // Clear radialBrightness when not in radial mode
      delete star.radialBrightness;

      if (direction === 'right') {
        star.x += baseDelta;
        if (star.x > canvasWidth) {
          star.x = star.x - canvasWidth;
          star.y = Math.random() * canvasHeight;
        }
      } else if (direction === 'up') {
        star.y -= baseDelta;
        if (star.y < 0) {
          star.y = canvasHeight + star.y;
          star.x = Math.random() * canvasWidth;
        }
      } else if (direction === 'down') {
        star.y += baseDelta;
        if (star.y > canvasHeight) {
          star.y = star.y - canvasHeight;
          star.x = Math.random() * canvasWidth;
        }
      } else {
        // 'left' (default)
        star.x -= baseDelta;
        if (star.x < 0) {
          star.x = canvasWidth + star.x;
          star.y = Math.random() * canvasHeight;
        }
      }
    }
  }
}

/**
 * Redistribute all stars across layers for a new direction mode.
 * Call when the user switches direction to avoid visual artifacts
 * (e.g. stars clustered at center after leaving radial mode).
 */
function redistributeStars(
  layers,
  canvasWidth,
  canvasHeight,
  direction,
) {
  const cx = canvasWidth / 2;
  const cy = canvasHeight / 2;
  const refDist = Math.min(canvasWidth, canvasHeight) / 2;

  for (const layer of layers) {
    for (const star of layer.stars) {
      if (direction === 'radial') {
        const angle = Math.random() * Math.PI * 2;
        const maxDist = Math.hypot(cx, cy);
        const dist = Math.random() * maxDist;
        star.x = cx + Math.cos(angle) * dist;
        star.y = cy + Math.sin(angle) * dist;
        star.radialBrightness = Math.min(dist / refDist, 1.0);
      } else {
        star.x = Math.random() * canvasWidth;
        star.y = Math.random() * canvasHeight;
        delete star.radialBrightness;
      }
    }
  }
}

/**
 * Parallax scaling factor for camera-relative star movement.
 * Keeps star drift speeds comparable to directional scroll speeds.
 */
const CAMERA_PARALLAX_SCALE = 0.1;

/**
 * Update star layers based on camera movement deltas (screen-space).
 * Stars shift opposite to camera motion with per-layer depth parallax.
 * Camera rotation rotates stars around the screen center.
 *
 * @param {Array} layers - Star layers from createParallaxLayers
 * @param {number} screenDx - Camera delta X in screen space (pre-rotated)
 * @param {number} screenDy - Camera delta Y in screen space (pre-rotated)
 * @param {number} deltaRotation - Camera rotation delta (radians)
 * @param {number} viewportW - Viewport width
 * @param {number} viewportH - Viewport height
 */
function updateStarLayersCamera(
  layers,
  screenDx,
  screenDy,
  deltaRotation,
  viewportW,
  viewportH,
) {
  if (layers.length === 0) return;
  const maxSpeed = Math.max(...layers.map((l) => l.speed));
  if (maxSpeed === 0) return;

  const noMovement = screenDx === 0 && screenDy === 0 && deltaRotation === 0;
  const cx = viewportW / 2;
  const cy = viewportH / 2;

  for (const layer of layers) {
    const depth = (layer.speed / maxSpeed) * CAMERA_PARALLAX_SCALE;

    const shiftX = -screenDx * depth;
    const shiftY = -screenDy * depth;

    const rotAngle = -deltaRotation * depth;
    const cosR = Math.cos(rotAngle);
    const sinR = Math.sin(rotAngle);

    for (const star of layer.stars) {
      delete star.radialBrightness;

      if (noMovement) continue;

      if (rotAngle !== 0) {
        const dx = star.x - cx;
        const dy = star.y - cy;
        star.x = cx + dx * cosR - dy * sinR;
        star.y = cy + dx * sinR + dy * cosR;
      }

      star.x += shiftX;
      star.y += shiftY;

      star.x = ((star.x % viewportW) + viewportW) % viewportW;
      star.y = ((star.y % viewportH) + viewportH) % viewportH;
    }
  }
}

/**
 * Update all parallax layers.
 */
function updateParallaxLayers(layers, dt, canvasWidth, canvasHeight) {
  for (const layer of layers) {
    updateStarLayer(layer, dt, canvasWidth, canvasHeight);
  }
}

/**
 * Draw all parallax layers (far to near, back to front).
 */
function drawParallaxLayers(ctx, layers, elapsedTime = 0) {
  for (const layer of layers) {
    drawStarLayer(ctx, layer, elapsedTime);
  }
}

/**
 * Draw a star layer onto a canvas 2D context.
 */
function drawStarLayer(ctx, layer, elapsedTime = 0) {
  for (const star of layer.stars) {
    let brightness = applyTwinkle(star, elapsedTime);
    if (star.radialBrightness != null) {
      brightness *= star.radialBrightness;
    }
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
    ctx.fillRect(star.x, star.y, star.size, star.size);
  }
}


startApp();
</script>
</body>
</html>
