<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroid Screensaver </title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js" async></script>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
// ===== ai-core.js =====
/**
 * AI Strategy Registry
 *
 * Pluggable AI system — register named strategies and retrieve them at runtime.
 * Each strategy implements { createState(), update(state, ship, target, asteroids, dt) }.
 */

const strategies = new Map();

/**
 * Register a named AI strategy.
 */
function registerStrategy(name, strategy) {
  strategies.set(name, strategy);
}

/**
 * Retrieve a registered strategy by name.
 * Throws if the name is not registered.
 */
function getStrategy(name) {
  const strategy = strategies.get(name);
  if (!strategy) {
    throw new Error(`Unknown AI strategy: "${name}"`);
  }
  return strategy;
}

/**
 * Return the names of all registered strategies.
 */
function listStrategies() {
  return [...strategies.keys()];
}

/**
 * Clear all registered strategies (for testing).
 */
function resetRegistry() {
  strategies.clear();
}

// ===== ai-neural.js =====
/**
 * Neural AI Strategy — ONNX model inference in the browser.
 *
 * Loads a trained ONNX model and runs inference each frame to select actions.
 * Falls back to predictive AI while the model loads or if loading fails.
 * Uses the same observation vector and action mapping as the training environment.
 */




/** CDN URL for ONNX Runtime Web. */
const ONNX_CDN_URL =
  'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js';

/** Path to the trained ONNX model file. */
const MODEL_PATH = 'models/policy.onnx';

/** Action hold duration in game-time seconds (training: frameSkip=2 × DT=1/60). */
const ACTION_HOLD_TIME = 2 / 60;

/**
 * Return the index of the maximum value in arr[start..end).
 * Index is 0-based relative to `start`. Ties broken by first occurrence.
 */
function argmax(arr, start, end) {
  let bestIdx = 0;
  let bestVal = arr[start];
  for (let i = 1; i < end - start; i++) {
    if (arr[start + i] > bestVal) {
      bestVal = arr[start + i];
      bestIdx = i;
    }
  }
  return bestIdx;
}

/**
 * Decode 12 raw logits into a movement index and fire decision.
 * - Movement: argmax of logits[0..10) → index 0–9
 * - Fire: logits[11] > logits[10] → true (equivalent to sigmoid > 0.5)
 */
function decodeActions(logits) {
  const moveIndex = argmax(logits, 0, 10);
  const fire = logits[11] > logits[10];
  return { moveIndex, fire };
}

/**
 * Apply a movement action index to a ship's control flags.
 * Maps ACTION_MAP short names (rotL, rotR, brake) to ship flag names.
 */
function applyMoveAction(ship, moveIndex) {
  const action = ACTION_MAP[moveIndex];
  ship.thrust = action.thrust;
  ship.rotatingLeft = action.rotL;
  ship.rotatingRight = action.rotR;
  ship.braking = action.brake;
}

/**
 * Dynamically load ONNX Runtime Web from CDN if not already available.
 * Resolves immediately if window.ort exists.
 */
function loadOnnxRuntime() {
  return new Promise((resolve, reject) => {
    if (typeof window !== 'undefined' && window.ort) {
      resolve();
      return;
    }

    if (typeof document === 'undefined') {
      reject(new Error('No document available to inject ONNX Runtime script'));
      return;
    }

    const script = document.createElement('script');
    script.src = ONNX_CDN_URL;
    script.onload = () => resolve();
    script.onerror = () =>
      reject(new Error('Failed to load ONNX Runtime from CDN'));
    document.head.appendChild(script);
  });
}

/**
 * Initialize ONNX session asynchronously.
 * On success sets state.session and state.ready = true.
 * On failure logs a warning; state.ready stays false (permanent fallback).
 */
async function initSession(state) {
  try {
    await loadOnnxRuntime();
    // Force single-threaded WASM — multi-threading requires cross-origin
    // isolation headers (COOP/COEP) that static hosts like GitHub Pages
    // don't provide, causing SharedArrayBuffer to be unavailable.
    window.ort.env.wasm.numThreads = 1;
    // Disable proxy worker — it also requires cross-origin isolation.
    window.ort.env.wasm.proxy = false;
    state.session = await window.ort.InferenceSession.create(MODEL_PATH, {
      executionProviders: ['wasm'],
    });
    state.ready = true;
  } catch (err) {
    console.warn(
      'Neural AI: model load failed, using fallback.',
      err?.message || err,
    );
  }
}

/**
 * Kick off async inference: build observation, run session, cache result.
 */
async function runInference(state, ship, target, asteroids) {
  try {
    const obs = buildObservation(ship, target, asteroids);
    state.inputBuffer.set(obs);

    const tensor = new window.ort.Tensor('float32', state.inputBuffer, [
      1,
      OBSERVATION_SIZE,
    ]);
    const feeds = { observation: tensor };
    const results = await state.session.run(feeds);

    const logits = results.logits.data;
    state.cachedAction = decodeActions(logits);
  } catch (_err) {
    // Inference failed — keep last cached action or null (will use fallback)
  } finally {
    state.pendingInference = false;
  }
}

/**
 * Create neural AI state. Fires async model loading immediately.
 */
function createNeuralState() {
  const state = {
    session: null,
    inputBuffer: new Float32Array(OBSERVATION_SIZE),
    ready: false,
    fallbackStrategy: predictiveStrategy,
    fallbackState: predictiveStrategy.createState(),
    pendingInference: false,
    cachedAction: null,
    holdTimer: 0,
  };

  // Fire-and-forget async model loading
  initSession(state);

  return state;
}

/**
 * Neural AI update — synchronous strategy interface.
 *
 * When not ready or no cached action: delegate to fallback.
 * When ready: apply cached action and kick off next async inference.
 */
function updateNeural(state, ship, target, asteroids, dt) {
  if (!state.ready || state.cachedAction === null) {
    state.fallbackStrategy.update(
      state.fallbackState,
      ship,
      target,
      asteroids,
      dt,
    );

    // If ready but no cached action, kick off first inference
    if (state.ready && !state.pendingInference) {
      state.pendingInference = true;
      runInference(state, ship, target, asteroids);
    }
    return;
  }

  // Apply cached action every frame (held for ACTION_HOLD_TIME game-seconds)
  applyMoveAction(ship, state.cachedAction.moveIndex);
  ship.fire = state.cachedAction.fire;

  // Request new inference after hold duration expires (time-based, not frame-based)
  state.holdTimer -= dt;
  if (state.holdTimer <= 0 && !state.pendingInference) {
    state.holdTimer = ACTION_HOLD_TIME;
    state.pendingInference = true;
    runInference(state, ship, target, asteroids);
  }
}

/**
 * Neural AI strategy object — pluggable interface.
 */
const neuralStrategy = {
  createState: createNeuralState,
  update: updateNeural,
};

// Self-register in the strategy registry
registerStrategy('neural', neuralStrategy);

// ===== ai-predictive-optimized.js =====
;(function() {
/**
 * Predictive-Optimized AI — trajectory simulation strategy.
 *
 * Each frame, generates 7 fixed-action candidates plus 2 dynamic pursuit
 * candidates, simulates each forward ~1.5s using real ship physics, scores
 * the outcomes, and picks the best action.
 * Firing is a separate snap decision based on current aim geometry.
 */



/** Angular threshold for AI firing (~8.6°) — duplicated from ai-reactive for decoupling. */
const FIRE_ANGLE = 0.15;

/** Max distance (px) at which AI will fire — duplicated from ai-reactive for decoupling. */
const MAX_FIRE_RANGE = 500;

/** Bullet speed (px/s) — duplicated from bullet.js for decoupling. */
const BULLET_SPEED = 600;

/** Last debug info captured by selectBestAction. */
let _lastDebugInfo = null;

/**
 * Return the last debug info captured by selectBestAction, or null.
 */
function getLastDebugInfo() {
  return _lastDebugInfo;
}

/** Number of simulation steps per candidate. */
const SIM_STEPS = 15;

/** Time step for each simulation step (seconds). */
const SIM_DT = 0.1;

/** Base penalty for collision — always catastrophic (collision = death). */
const COLLISION_BASE_PENALTY = -20000;

/** Linear tiebreaker: later collisions are slightly less bad (more time to re-evaluate). */
const COLLISION_EARLY_BONUS = 50;

/** Base penalty for near-miss danger zone — tuned independently of actual collision penalty.
 *  Decoupling this from COLLISION_BASE_PENALTY lets us reduce proximity discouragement
 *  without weakening actual collision deterrence. */
const DANGER_ZONE_BASE_PENALTY = -10000;

/** Number of brake steps before pursuit in the brake-pursuit candidate. */
const BRAKE_PURSUIT_STEPS = 5;

/** Rotation deadzone for pursuit candidates (rad). */
const PURSUIT_DEADZONE = 0.05;

/** Thrust angle for pursuit candidates (rad) — thrust when facing within this. */
const PURSUIT_THRUST_ANGLE = Math.PI / 3;

/** Speed threshold for pursuit braking. */
const PURSUIT_BRAKE_SPEED = 50;

/** Weight applied to distance-to-target (negative = closer is better). */
const DISTANCE_WEIGHT = -3;

/** Bonus for aiming toward target at closest approach. */
const AIM_BONUS = 400;

/** Weight for closing speed bonus (dot of velocity toward target). */
const CLOSING_SPEED_WEIGHT = 16;

/** Proximity scaling factor for aim bonus — amplifies aim importance at close range. */
const AIM_PROXIMITY_SCALE = 5;

/** Bonus per sim step where ship has a viable firing solution. */
const FIRE_OPPORTUNITY_BONUS = 450;

/** Distance below which current scoring balance applies (close-range combat zone). */
const ENGAGE_RANGE = 350;

/** Minimum time (seconds) to hold an action before reconsidering. */
const HOLD_TIME = 0.15;

/** Simulation steps to check for imminent collision during hold. */
const COLLISION_BREAK_STEPS = 3;

/** Score bonus for matching the previous frame's action (reduces oscillation). */
const HYSTERESIS_BONUS = 350;

/** Danger zone extends to this factor × collision distance. Near-misses within
 *  this zone receive a graduated penalty (quadratic ramp from 0 at edge to
 *  full collision penalty at the collision boundary). */
const DANGER_ZONE_FACTOR = 3;

/** Within ENGAGE_RANGE, closing speed weight scales up linearly from 1× at the
 *  boundary to (1 + ENGAGE_CLOSING_SCALE)× at zero distance. Prevents formation
 *  flight stagnation by making the AI progressively more aggressive about
 *  closing distance as it enters combat range. */
const ENGAGE_CLOSING_SCALE = 3;

/**
 * Clone only the physics-relevant fields of a ship for simulation.
 */
function cloneShipForSim(ship) {
  return {
    x: ship.x,
    y: ship.y,
    vx: ship.vx,
    vy: ship.vy,
    heading: ship.heading,
    thrustIntensity: ship.thrustIntensity,
    thrustPower: ship.thrustPower,
    alive: true,
    thrust: false,
    rotatingLeft: false,
    rotatingRight: false,
    braking: false,
  };
}

/**
 * Linearly extrapolate an asteroid's position at time t.
 * Returns { x, y, radius } for collision checking.
 */
function predictAsteroidAt(asteroid, t) {
  return {
    x: asteroid.x + asteroid.vx * t,
    y: asteroid.y + asteroid.vy * t,
    radius: asteroid.collisionRadius,
  };
}

/**
 * Define the 7 candidate actions for trajectory simulation.
 */
function defineCandidates() {
  return [
    { thrust: true, rotatingLeft: false, rotatingRight: false, braking: false },
    { thrust: true, rotatingLeft: true, rotatingRight: false, braking: false },
    { thrust: true, rotatingLeft: false, rotatingRight: true, braking: false },
    {
      thrust: false,
      rotatingLeft: false,
      rotatingRight: false,
      braking: false,
    },
    { thrust: false, rotatingLeft: true, rotatingRight: false, braking: false },
    { thrust: false, rotatingLeft: false, rotatingRight: true, braking: false },
    { thrust: false, rotatingLeft: false, rotatingRight: false, braking: true },
  ];
}

/**
 * Simulate a ship clone forward for `steps` time steps, applying the given action.
 * Returns an array of positions (length = steps + 1, including the initial position).
 */
function simulateTrajectory(clone, action, steps, dt) {
  const positions = [
    {
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    },
  ];

  clone.thrust = action.thrust;
  clone.rotatingLeft = action.rotatingLeft;
  clone.rotatingRight = action.rotatingRight;
  clone.braking = action.braking;

  for (let i = 0; i < steps; i++) {
    updateShip(clone, dt);
    positions.push({
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    });
  }

  return positions;
}

/**
 * Score a simulated trajectory based on:
 * - Catastrophic collision penalty (first collision only — ship would be dead)
 * - Closest approach to target across trajectory (lower = better)
 * - Average aim bonus across all steps (avoids crossover artifact at overshoot)
 * - Approach rate bonus (net distance closed, immune to overshoot terror)
 * - Fire opportunity bonus for steps with viable firing solutions (proximity-scaled)
 */
function scoreTrajectory(positions, target, asteroids, simDt) {
  let score = 0;

  // Check for first collision only (ship dies on first hit, later ones are moot)
  // Also track worst near-miss within the danger zone for graduated penalty.
  const shipRadius = SHIP_SIZE;
  let collided = false;
  let worstDanger = 0;
  for (let i = 1; i < positions.length && !collided; i++) {
    const t = i * simDt;
    const pos = positions[i];

    for (const ast of asteroids) {
      const predicted = predictAsteroidAt(ast, t);
      const dx = pos.x - predicted.x;
      const dy = pos.y - predicted.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const collisionDist = predicted.radius + shipRadius;

      if (dist < collisionDist) {
        score += COLLISION_BASE_PENALTY + COLLISION_EARLY_BONUS * i;
        collided = true;
        break;
      }

      const dangerZone = DANGER_ZONE_FACTOR * collisionDist;
      if (dist < dangerZone) {
        const proximity = (dangerZone - dist) / (dangerZone - collisionDist);
        worstDanger = Math.max(worstDanger, proximity * proximity);
      }
    }
  }

  if (!collided && worstDanger > 0) {
    score += DANGER_ZONE_BASE_PENALTY * worstDanger;
  }

  // Compute initial distance to target (used for approach urgency and closing rate)
  const initDx = positions[0].x - target.x;
  const initDy = positions[0].y - target.y;
  const initialDist = Math.sqrt(initDx * initDx + initDy * initDy);

  // Find the closest approach to the predicted target across the trajectory
  let minDist = Infinity;
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const ddx = positions[i].x - predX;
    const ddy = positions[i].y - predY;
    const d = Math.sqrt(ddx * ddx + ddy * ddy);
    if (d < minDist) {
      minDist = d;
    }
  }

  // Distance-scaled approach urgency: stronger pull to close at long range
  const distanceScale =
    1 + Math.max(0, initialDist - ENGAGE_RANGE) / ENGAGE_RANGE;
  score += DISTANCE_WEIGHT * distanceScale * minDist;

  // Aim bonus: average alignment across all trajectory steps.
  // Averaging avoids the "crossover artifact" where a ship passing through
  // the target gets a negative aim reading at the single crossover point,
  // despite being well-aimed for most of the trajectory.
  let aimSum = 0;
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const angleToTarget = Math.atan2(
      predY - positions[i].y,
      predX - positions[i].x,
    );
    let angleDiff = angleToTarget - positions[i].heading;
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    aimSum += Math.cos(angleDiff);
  }
  const aimProximityFactor =
    1 + AIM_PROXIMITY_SCALE * Math.max(0, 1 - minDist / MAX_FIRE_RANGE);
  score += AIM_BONUS * (aimSum / (positions.length - 1)) * aimProximityFactor;

  // Approach rate: reward net distance closed over the simulation.
  // Uses (initialDist - finalDist) / simTime instead of instantaneous velocity
  // at a single point, avoiding "overshoot terror" where passing through the
  // target produces a massive negative closing speed.
  const lastIdx = positions.length - 1;
  const lastT = lastIdx * simDt;
  const finalTargetX = target.x + target.vx * lastT;
  const finalTargetY = target.y + target.vy * lastT;
  const finDx = positions[lastIdx].x - finalTargetX;
  const finDy = positions[lastIdx].y - finalTargetY;
  const finalDist = Math.sqrt(finDx * finDx + finDy * finDy);

  const simTime = simDt * lastIdx;
  if (simTime > 0) {
    const closingRate = (initialDist - finalDist) / simTime;
    const closingScale =
      initialDist < ENGAGE_RANGE
        ? 1 + ENGAGE_CLOSING_SCALE * (1 - initialDist / ENGAGE_RANGE)
        : 1;
    score += CLOSING_SPEED_WEIGHT * closingScale * closingRate;
  }

  // Fire opportunity bonus: count steps with a viable lead-angle firing solution.
  // Uses the same lead-angle logic as the fire decision — scores trajectories
  // by whether shots would actually hit the predicted target position, not just
  // aim at where the target currently is. Scaled by proximity.
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const fdx = predX - positions[i].x;
    const fdy = predY - positions[i].y;
    const fDist = Math.sqrt(fdx * fdx + fdy * fdy);
    if (fDist > MAX_FIRE_RANGE) continue;
    // Lead-angle: where target will be when a bullet fired now arrives
    const bulletTime = fDist / BULLET_SPEED;
    const rvx = target.vx - positions[i].vx;
    const rvy = target.vy - positions[i].vy;
    const leadX = predX + rvx * bulletTime;
    const leadY = predY + rvy * bulletTime;
    const fireAngle = Math.atan2(
      leadY - positions[i].y,
      leadX - positions[i].x,
    );
    let fireDiff = fireAngle - positions[i].heading;
    while (fireDiff > Math.PI) fireDiff -= 2 * Math.PI;
    while (fireDiff < -Math.PI) fireDiff += 2 * Math.PI;
    if (Math.abs(fireDiff) < FIRE_ANGLE) {
      score += FIRE_OPPORTUNITY_BONUS * (1 - fDist / MAX_FIRE_RANGE);
    }
  }

  return score;
}

/**
 * Simulate a dynamic pursuit trajectory where the ship adapts each step:
 * rotate toward the predicted target, thrust when facing it, brake otherwise.
 * Optionally brakes for `brakeSteps` before engaging pursuit.
 *
 * Returns { positions, firstAction } where firstAction is the action at step 0.
 */
function simulatePursuitTrajectory(
  clone,
  target,
  steps,
  dt,
  brakeSteps = 0,
) {
  const positions = [
    {
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    },
  ];
  let firstAction = null;

  for (let i = 0; i < steps; i++) {
    const t = (i + 1) * dt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const dx = predX - clone.x;
    const dy = predY - clone.y;
    const headingDiff = normalizeAngle(Math.atan2(dy, dx) - clone.heading);
    const speed = Math.sqrt(clone.vx * clone.vx + clone.vy * clone.vy);

    if (i < brakeSteps) {
      clone.thrust = false;
      clone.braking = speed > 10;
      clone.rotatingLeft = headingDiff < -PURSUIT_DEADZONE;
      clone.rotatingRight = headingDiff > PURSUIT_DEADZONE;
    } else {
      const facingTarget = Math.abs(headingDiff) < PURSUIT_THRUST_ANGLE;
      clone.thrust = facingTarget;
      clone.braking = !facingTarget && speed > PURSUIT_BRAKE_SPEED;
      clone.rotatingLeft = headingDiff < -PURSUIT_DEADZONE;
      clone.rotatingRight = headingDiff > PURSUIT_DEADZONE;
    }

    if (i === 0) {
      firstAction = {
        thrust: clone.thrust,
        rotatingLeft: clone.rotatingLeft,
        rotatingRight: clone.rotatingRight,
        braking: clone.braking,
      };
    }

    updateShip(clone, dt);
    positions.push({
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    });
  }

  return { positions, firstAction };
}

/**
 * Check if a held action would cause an imminent collision (within a few steps).
 * Used as an emergency escape hatch during action hold periods.
 */
function hasImminentCollision(ship, action, asteroids) {
  const clone = cloneShipForSim(ship);
  const positions = simulateTrajectory(
    clone,
    action,
    COLLISION_BREAK_STEPS,
    SIM_DT,
  );
  const shipRadius = SHIP_SIZE;
  for (let i = 1; i < positions.length; i++) {
    const t = i * SIM_DT;
    for (const ast of asteroids) {
      const predicted = predictAsteroidAt(ast, t);
      const dx = positions[i].x - predicted.x;
      const dy = positions[i].y - predicted.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < predicted.radius + shipRadius) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Check if two action objects have identical control flags.
 */
function actionsMatch(a, b) {
  return (
    a.thrust === b.thrust &&
    a.rotatingLeft === b.rotatingLeft &&
    a.rotatingRight === b.rotatingRight &&
    a.braking === b.braking
  );
}

/**
 * Select the best action by simulating all candidates and picking the highest score.
 * Optional prevAction enables hysteresis — matching candidates get a small bonus
 * to prevent frame-by-frame oscillation between similar-scoring actions.
 */
function selectBestAction(
  ship,
  target,
  asteroids,
  prevAction = null,
  simSteps = SIM_STEPS,
) {
  const candidates = defineCandidates();
  let bestScore = -Infinity;
  let bestAction = candidates[0];
  let bestName = '';
  const debugCandidates = [];

  // Evaluate fixed-action candidates
  for (const action of candidates) {
    const clone = cloneShipForSim(ship);
    const positions = simulateTrajectory(clone, action, simSteps, SIM_DT);
    let score = scoreTrajectory(positions, target, asteroids, SIM_DT);
    if (prevAction && actionsMatch(action, prevAction)) {
      score += HYSTERESIS_BONUS;
    }
    const name = fmtAction(action);
    debugCandidates.push({ name, score });

    if (score > bestScore) {
      bestScore = score;
      bestAction = action;
      bestName = name;
    }
  }

  // Evaluate dynamic pursuit candidate (rotate toward target, thrust when facing)
  const pursuitClone = cloneShipForSim(ship);
  const pursuit = simulatePursuitTrajectory(
    pursuitClone,
    target,
    simSteps,
    SIM_DT,
    0,
  );
  let pursuitScore = scoreTrajectory(
    pursuit.positions,
    target,
    asteroids,
    SIM_DT,
  );
  if (
    prevAction &&
    pursuit.firstAction &&
    actionsMatch(pursuit.firstAction, prevAction)
  ) {
    pursuitScore += HYSTERESIS_BONUS;
  }
  debugCandidates.push({ name: 'PUR', score: pursuitScore });
  if (pursuitScore > bestScore) {
    bestScore = pursuitScore;
    bestAction = pursuit.firstAction;
    bestName = 'PUR';
  }

  // Evaluate brake-pursuit candidate (brake first, then pursue).
  // Only useful when ship has significant velocity — otherwise the brake phase
  // does nothing and the trajectory degenerates into delayed pursuit, producing
  // a misleading firstAction (coast) that the AI would repeat every frame.
  const shipSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  if (shipSpeed > PURSUIT_BRAKE_SPEED) {
    const brakeClone = cloneShipForSim(ship);
    const brakePursuit = simulatePursuitTrajectory(
      brakeClone,
      target,
      simSteps,
      SIM_DT,
      BRAKE_PURSUIT_STEPS,
    );
    let brakeScore = scoreTrajectory(
      brakePursuit.positions,
      target,
      asteroids,
      SIM_DT,
    );
    if (
      prevAction &&
      brakePursuit.firstAction &&
      actionsMatch(brakePursuit.firstAction, prevAction)
    ) {
      brakeScore += HYSTERESIS_BONUS;
    }
    debugCandidates.push({ name: 'BRK', score: brakeScore });
    if (brakeScore > bestScore) {
      bestScore = brakeScore;
      bestAction = brakePursuit.firstAction;
      bestName = 'BRK';
    }
  }

  _lastDebugInfo = { candidates: debugCandidates, winner: bestName };

  return bestAction;
}

/**
 * Compute the lead angle for firing at a moving target.
 * Returns the world-space angle to aim at so the bullet intercepts the target,
 * or null if no solution exists (target outrunning bullet).
 *
 * @param {object} ship - { x, y, vx, vy }
 * @param {object} target - { x, y, vx, vy }
 * @returns {{ angle: number, travelTime: number } | null}
 */
function computeLeadAngle(ship, target) {
  const dx = target.x - ship.x;
  const dy = target.y - ship.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 1) return { angle: Math.atan2(dy, dx), travelTime: 0 };

  // Relative velocity of target w.r.t. ship (bullet inherits ship velocity)
  const rvx = target.vx - ship.vx;
  const rvy = target.vy - ship.vy;

  // Estimate travel time: dist / BULLET_SPEED (first-order approximation)
  const travelTime = dist / BULLET_SPEED;

  // Predict target position at intercept time
  const predX = target.x + rvx * travelTime;
  const predY = target.y + rvy * travelTime;

  return {
    angle: Math.atan2(predY - ship.y, predX - ship.x),
    travelTime,
  };
}

/**
 * Normalize an angle to [-PI, PI].
 */
function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create predictive-optimized AI state.
 */
function createPredictiveOptimizedState() {
  return { prevAction: null, holdTimer: 0 };
}

/**
 * Predictive-optimized AI update function.
 * Holds selected action for HOLD_TIME to prevent oscillation, with an
 * emergency escape if the held action predicts an imminent collision.
 * Firing decision is a separate snap check based on current aim.
 */
function updatePredictiveOptimizedAI(state, ship, target, asteroids, _dt) {
  if (!ship.alive || !target.alive) {
    ship.thrust = false;
    ship.rotatingLeft = false;
    ship.rotatingRight = false;
    ship.braking = false;
    ship.fire = false;
    return;
  }

  const holdTime = state.holdTime ?? HOLD_TIME;
  const simSteps = state.simSteps ?? SIM_STEPS;

  state.holdTimer = Math.max(0, state.holdTimer - _dt);

  const holdExpired = state.holdTimer <= 0;
  const emergency =
    !holdExpired &&
    state.prevAction &&
    hasImminentCollision(ship, state.prevAction, asteroids);

  if (holdExpired || emergency || !state.prevAction) {
    const action = selectBestAction(
      ship,
      target,
      asteroids,
      state.prevAction,
      simSteps,
    );
    state.prevAction = action;
    state.holdTimer = holdTime;
  }

  ship.thrust = state.prevAction.thrust;
  ship.rotatingLeft = state.prevAction.rotatingLeft;
  ship.rotatingRight = state.prevAction.rotatingRight;
  ship.braking = state.prevAction.braking;

  // Fire decision: lead-angle check — aim where the target will be
  const dx = target.x - ship.x;
  const dy = target.y - ship.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist < MAX_FIRE_RANGE) {
    const lead = computeLeadAngle(ship, target);
    const headingDiff = Math.abs(normalizeAngle(lead.angle - ship.heading));
    ship.fire = headingDiff < FIRE_ANGLE;
  } else {
    ship.fire = false;
  }
}

/**
 * Predictive-optimized AI strategy object — pluggable interface.
 */
const predictiveOptimizedStrategy = {
  createState: createPredictiveOptimizedState,
  update: updatePredictiveOptimizedAI,
};

// Self-register in the strategy registry
registerStrategy('predictive-optimized', predictiveOptimizedStrategy);

})();
// ===== ai-predictive.js =====
/**
 * Predictive AI — trajectory simulation strategy.
 *
 * Each frame, generates 7 fixed-action candidates plus 2 dynamic pursuit
 * candidates, simulates each forward ~1.5s using real ship physics, scores
 * the outcomes, and picks the best action.
 * Firing is a separate snap decision based on current aim geometry.
 */



/** Last debug info captured by selectBestAction. */
let _lastDebugInfo = null;

/**
 * Return the last debug info captured by selectBestAction, or null.
 */
function getLastDebugInfo() {
  return _lastDebugInfo;
}

/** Number of simulation steps per candidate. */
const SIM_STEPS = 15;

/** Time step for each simulation step (seconds). */
const SIM_DT = 0.1;

/** Base penalty for collision — always catastrophic (collision = death). */
const COLLISION_BASE_PENALTY = -20000;

/** Linear tiebreaker: later collisions are slightly less bad (more time to re-evaluate). */
const COLLISION_EARLY_BONUS = 50;

/** Number of brake steps before pursuit in the brake-pursuit candidate. */
const BRAKE_PURSUIT_STEPS = 5;

/** Rotation deadzone for pursuit candidates (rad). */
const PURSUIT_DEADZONE = 0.05;

/** Thrust angle for pursuit candidates (rad) — thrust when facing within this. */
const PURSUIT_THRUST_ANGLE = Math.PI / 3;

/** Speed threshold for pursuit braking. */
const PURSUIT_BRAKE_SPEED = 50;

/** Weight applied to distance-to-target (negative = closer is better). */
const DISTANCE_WEIGHT = -8;

/** Bonus for aiming toward target at closest approach. */
const AIM_BONUS = 400;

/** Weight for closing speed bonus (dot of velocity toward target). */
const CLOSING_SPEED_WEIGHT = 8;

/** Proximity scaling factor for aim bonus — amplifies aim importance at close range. */
const AIM_PROXIMITY_SCALE = 5;

/** Bonus per sim step where ship has a viable firing solution. */
const FIRE_OPPORTUNITY_BONUS = 300;

/** Distance below which current scoring balance applies (close-range combat zone). */
const ENGAGE_RANGE = 350;

/** Minimum time (seconds) to hold an action before reconsidering. */
const HOLD_TIME = 0.15;

/** Simulation steps to check for imminent collision during hold. */
const COLLISION_BREAK_STEPS = 3;

/** Score bonus for matching the previous frame's action (reduces oscillation). */
const HYSTERESIS_BONUS = 250;

/** Danger zone extends to this factor × collision distance. Near-misses within
 *  this zone receive a graduated penalty (quadratic ramp from 0 at edge to
 *  full collision penalty at the collision boundary). */
const DANGER_ZONE_FACTOR = 3;

/** Within ENGAGE_RANGE, closing speed weight scales up linearly from 1× at the
 *  boundary to (1 + ENGAGE_CLOSING_SCALE)× at zero distance. Prevents formation
 *  flight stagnation by making the AI progressively more aggressive about
 *  closing distance as it enters combat range. */
const ENGAGE_CLOSING_SCALE = 3;

/**
 * Clone only the physics-relevant fields of a ship for simulation.
 */
function cloneShipForSim(ship) {
  return {
    x: ship.x,
    y: ship.y,
    vx: ship.vx,
    vy: ship.vy,
    heading: ship.heading,
    thrustIntensity: ship.thrustIntensity,
    thrustPower: ship.thrustPower,
    alive: true,
    thrust: false,
    rotatingLeft: false,
    rotatingRight: false,
    braking: false,
  };
}

/**
 * Linearly extrapolate an asteroid's position at time t.
 * Returns { x, y, radius } for collision checking.
 */
function predictAsteroidAt(asteroid, t) {
  return {
    x: asteroid.x + asteroid.vx * t,
    y: asteroid.y + asteroid.vy * t,
    radius: asteroid.collisionRadius,
  };
}

/**
 * Define the 7 candidate actions for trajectory simulation.
 */
function defineCandidates() {
  return [
    { thrust: true, rotatingLeft: false, rotatingRight: false, braking: false },
    { thrust: true, rotatingLeft: true, rotatingRight: false, braking: false },
    { thrust: true, rotatingLeft: false, rotatingRight: true, braking: false },
    {
      thrust: false,
      rotatingLeft: false,
      rotatingRight: false,
      braking: false,
    },
    { thrust: false, rotatingLeft: true, rotatingRight: false, braking: false },
    { thrust: false, rotatingLeft: false, rotatingRight: true, braking: false },
    { thrust: false, rotatingLeft: false, rotatingRight: false, braking: true },
  ];
}

/**
 * Simulate a ship clone forward for `steps` time steps, applying the given action.
 * Returns an array of positions (length = steps + 1, including the initial position).
 */
function simulateTrajectory(clone, action, steps, dt) {
  const positions = [
    {
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    },
  ];

  clone.thrust = action.thrust;
  clone.rotatingLeft = action.rotatingLeft;
  clone.rotatingRight = action.rotatingRight;
  clone.braking = action.braking;

  for (let i = 0; i < steps; i++) {
    updateShip(clone, dt);
    positions.push({
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    });
  }

  return positions;
}

/**
 * Score a simulated trajectory based on:
 * - Catastrophic collision penalty (first collision only — ship would be dead)
 * - Closest approach to target across trajectory (lower = better)
 * - Average aim bonus across all steps (avoids crossover artifact at overshoot)
 * - Approach rate bonus (net distance closed, immune to overshoot terror)
 * - Fire opportunity bonus for steps with viable firing solutions (proximity-scaled)
 */
function scoreTrajectory(positions, target, asteroids, simDt) {
  let score = 0;

  // Check for first collision only (ship dies on first hit, later ones are moot)
  // Also track worst near-miss within the danger zone for graduated penalty.
  const shipRadius = SHIP_SIZE;
  let collided = false;
  let worstDanger = 0;
  for (let i = 1; i < positions.length && !collided; i++) {
    const t = i * simDt;
    const pos = positions[i];

    for (const ast of asteroids) {
      const predicted = predictAsteroidAt(ast, t);
      const dx = pos.x - predicted.x;
      const dy = pos.y - predicted.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const collisionDist = predicted.radius + shipRadius;

      if (dist < collisionDist) {
        score += COLLISION_BASE_PENALTY + COLLISION_EARLY_BONUS * i;
        collided = true;
        break;
      }

      const dangerZone = DANGER_ZONE_FACTOR * collisionDist;
      if (dist < dangerZone) {
        const proximity = (dangerZone - dist) / (dangerZone - collisionDist);
        worstDanger = Math.max(worstDanger, proximity * proximity);
      }
    }
  }

  if (!collided && worstDanger > 0) {
    score += COLLISION_BASE_PENALTY * worstDanger;
  }

  // Compute initial distance to target (used for approach urgency and closing rate)
  const initDx = positions[0].x - target.x;
  const initDy = positions[0].y - target.y;
  const initialDist = Math.sqrt(initDx * initDx + initDy * initDy);

  // Find the closest approach to the predicted target across the trajectory
  let minDist = Infinity;
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const ddx = positions[i].x - predX;
    const ddy = positions[i].y - predY;
    const d = Math.sqrt(ddx * ddx + ddy * ddy);
    if (d < minDist) {
      minDist = d;
    }
  }

  // Distance-scaled approach urgency: stronger pull to close at long range
  const distanceScale =
    1 + Math.max(0, initialDist - ENGAGE_RANGE) / ENGAGE_RANGE;
  score += DISTANCE_WEIGHT * distanceScale * minDist;

  // Aim bonus: average alignment across all trajectory steps.
  // Averaging avoids the "crossover artifact" where a ship passing through
  // the target gets a negative aim reading at the single crossover point,
  // despite being well-aimed for most of the trajectory.
  let aimSum = 0;
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const angleToTarget = Math.atan2(
      predY - positions[i].y,
      predX - positions[i].x,
    );
    let angleDiff = angleToTarget - positions[i].heading;
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    aimSum += Math.cos(angleDiff);
  }
  const aimProximityFactor =
    1 + AIM_PROXIMITY_SCALE * Math.max(0, 1 - minDist / MAX_FIRE_RANGE);
  score += AIM_BONUS * (aimSum / (positions.length - 1)) * aimProximityFactor;

  // Approach rate: reward net distance closed over the simulation.
  // Uses (initialDist - finalDist) / simTime instead of instantaneous velocity
  // at a single point, avoiding "overshoot terror" where passing through the
  // target produces a massive negative closing speed.
  const lastIdx = positions.length - 1;
  const lastT = lastIdx * simDt;
  const finalTargetX = target.x + target.vx * lastT;
  const finalTargetY = target.y + target.vy * lastT;
  const finDx = positions[lastIdx].x - finalTargetX;
  const finDy = positions[lastIdx].y - finalTargetY;
  const finalDist = Math.sqrt(finDx * finDx + finDy * finDy);

  const simTime = simDt * lastIdx;
  if (simTime > 0) {
    const closingRate = (initialDist - finalDist) / simTime;
    const closingScale =
      initialDist < ENGAGE_RANGE
        ? 1 + ENGAGE_CLOSING_SCALE * (1 - initialDist / ENGAGE_RANGE)
        : 1;
    score += CLOSING_SPEED_WEIGHT * closingScale * closingRate;
  }

  // Fire opportunity bonus: count steps with a viable firing solution
  // (aimed within FIRE_ANGLE and within MAX_FIRE_RANGE of predicted target).
  // Scaled by proximity — closer shots are worth more, breaking orbits
  // while not rewarding standing still at max range.
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const fdx = predX - positions[i].x;
    const fdy = predY - positions[i].y;
    const fDist = Math.sqrt(fdx * fdx + fdy * fdy);
    if (fDist > MAX_FIRE_RANGE) continue;
    const fireAngle = Math.atan2(fdy, fdx);
    let fireDiff = fireAngle - positions[i].heading;
    while (fireDiff > Math.PI) fireDiff -= 2 * Math.PI;
    while (fireDiff < -Math.PI) fireDiff += 2 * Math.PI;
    if (Math.abs(fireDiff) < FIRE_ANGLE) {
      score += FIRE_OPPORTUNITY_BONUS * (1 - fDist / MAX_FIRE_RANGE);
    }
  }

  return score;
}

/**
 * Simulate a dynamic pursuit trajectory where the ship adapts each step:
 * rotate toward the predicted target, thrust when facing it, brake otherwise.
 * Optionally brakes for `brakeSteps` before engaging pursuit.
 *
 * Returns { positions, firstAction } where firstAction is the action at step 0.
 */
function simulatePursuitTrajectory(
  clone,
  target,
  steps,
  dt,
  brakeSteps = 0,
) {
  const positions = [
    {
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    },
  ];
  let firstAction = null;

  for (let i = 0; i < steps; i++) {
    const t = (i + 1) * dt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const dx = predX - clone.x;
    const dy = predY - clone.y;
    const headingDiff = normalizeAngle(Math.atan2(dy, dx) - clone.heading);
    const speed = Math.sqrt(clone.vx * clone.vx + clone.vy * clone.vy);

    if (i < brakeSteps) {
      clone.thrust = false;
      clone.braking = speed > 10;
      clone.rotatingLeft = headingDiff < -PURSUIT_DEADZONE;
      clone.rotatingRight = headingDiff > PURSUIT_DEADZONE;
    } else {
      const facingTarget = Math.abs(headingDiff) < PURSUIT_THRUST_ANGLE;
      clone.thrust = facingTarget;
      clone.braking = !facingTarget && speed > PURSUIT_BRAKE_SPEED;
      clone.rotatingLeft = headingDiff < -PURSUIT_DEADZONE;
      clone.rotatingRight = headingDiff > PURSUIT_DEADZONE;
    }

    if (i === 0) {
      firstAction = {
        thrust: clone.thrust,
        rotatingLeft: clone.rotatingLeft,
        rotatingRight: clone.rotatingRight,
        braking: clone.braking,
      };
    }

    updateShip(clone, dt);
    positions.push({
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    });
  }

  return { positions, firstAction };
}

/**
 * Check if a held action would cause an imminent collision (within a few steps).
 * Used as an emergency escape hatch during action hold periods.
 */
function hasImminentCollision(ship, action, asteroids) {
  const clone = cloneShipForSim(ship);
  const positions = simulateTrajectory(
    clone,
    action,
    COLLISION_BREAK_STEPS,
    SIM_DT,
  );
  const shipRadius = SHIP_SIZE;
  for (let i = 1; i < positions.length; i++) {
    const t = i * SIM_DT;
    for (const ast of asteroids) {
      const predicted = predictAsteroidAt(ast, t);
      const dx = positions[i].x - predicted.x;
      const dy = positions[i].y - predicted.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < predicted.radius + shipRadius) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Check if two action objects have identical control flags.
 */
function actionsMatch(a, b) {
  return (
    a.thrust === b.thrust &&
    a.rotatingLeft === b.rotatingLeft &&
    a.rotatingRight === b.rotatingRight &&
    a.braking === b.braking
  );
}

/**
 * Select the best action by simulating all candidates and picking the highest score.
 * Optional prevAction enables hysteresis — matching candidates get a small bonus
 * to prevent frame-by-frame oscillation between similar-scoring actions.
 */
function selectBestAction(
  ship,
  target,
  asteroids,
  prevAction = null,
  simSteps = SIM_STEPS,
) {
  const candidates = defineCandidates();
  let bestScore = -Infinity;
  let bestAction = candidates[0];
  let bestName = '';
  const debugCandidates = [];

  // Evaluate fixed-action candidates
  for (const action of candidates) {
    const clone = cloneShipForSim(ship);
    const positions = simulateTrajectory(clone, action, simSteps, SIM_DT);
    let score = scoreTrajectory(positions, target, asteroids, SIM_DT);
    if (prevAction && actionsMatch(action, prevAction)) {
      score += HYSTERESIS_BONUS;
    }
    const name = fmtAction(action);
    debugCandidates.push({ name, score });

    if (score > bestScore) {
      bestScore = score;
      bestAction = action;
      bestName = name;
    }
  }

  // Evaluate dynamic pursuit candidate (rotate toward target, thrust when facing)
  const pursuitClone = cloneShipForSim(ship);
  const pursuit = simulatePursuitTrajectory(
    pursuitClone,
    target,
    simSteps,
    SIM_DT,
    0,
  );
  let pursuitScore = scoreTrajectory(
    pursuit.positions,
    target,
    asteroids,
    SIM_DT,
  );
  if (
    prevAction &&
    pursuit.firstAction &&
    actionsMatch(pursuit.firstAction, prevAction)
  ) {
    pursuitScore += HYSTERESIS_BONUS;
  }
  debugCandidates.push({ name: 'PUR', score: pursuitScore });
  if (pursuitScore > bestScore) {
    bestScore = pursuitScore;
    bestAction = pursuit.firstAction;
    bestName = 'PUR';
  }

  // Evaluate brake-pursuit candidate (brake first, then pursue).
  // Only useful when ship has significant velocity — otherwise the brake phase
  // does nothing and the trajectory degenerates into delayed pursuit, producing
  // a misleading firstAction (coast) that the AI would repeat every frame.
  const shipSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  if (shipSpeed > PURSUIT_BRAKE_SPEED) {
    const brakeClone = cloneShipForSim(ship);
    const brakePursuit = simulatePursuitTrajectory(
      brakeClone,
      target,
      simSteps,
      SIM_DT,
      BRAKE_PURSUIT_STEPS,
    );
    let brakeScore = scoreTrajectory(
      brakePursuit.positions,
      target,
      asteroids,
      SIM_DT,
    );
    if (
      prevAction &&
      brakePursuit.firstAction &&
      actionsMatch(brakePursuit.firstAction, prevAction)
    ) {
      brakeScore += HYSTERESIS_BONUS;
    }
    debugCandidates.push({ name: 'BRK', score: brakeScore });
    if (brakeScore > bestScore) {
      bestScore = brakeScore;
      bestAction = brakePursuit.firstAction;
      bestName = 'BRK';
    }
  }

  _lastDebugInfo = { candidates: debugCandidates, winner: bestName };

  return bestAction;
}

/**
 * Normalize an angle to [-PI, PI].
 */
function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create predictive AI state.
 */
function createPredictiveState() {
  return { prevAction: null, holdTimer: 0 };
}

/**
 * Predictive AI update function.
 * Holds selected action for HOLD_TIME to prevent oscillation, with an
 * emergency escape if the held action predicts an imminent collision.
 * Firing decision is a separate snap check based on current aim.
 */
function updatePredictiveAI(state, ship, target, asteroids, _dt) {
  if (!ship.alive || !target.alive) {
    ship.thrust = false;
    ship.rotatingLeft = false;
    ship.rotatingRight = false;
    ship.braking = false;
    ship.fire = false;
    return;
  }

  const holdTime = state.holdTime ?? HOLD_TIME;
  const simSteps = state.simSteps ?? SIM_STEPS;

  state.holdTimer = Math.max(0, state.holdTimer - _dt);

  const holdExpired = state.holdTimer <= 0;
  const emergency =
    !holdExpired &&
    state.prevAction &&
    hasImminentCollision(ship, state.prevAction, asteroids);

  if (holdExpired || emergency || !state.prevAction) {
    const action = selectBestAction(
      ship,
      target,
      asteroids,
      state.prevAction,
      simSteps,
    );
    state.prevAction = action;
    state.holdTimer = holdTime;
  }

  ship.thrust = state.prevAction.thrust;
  ship.rotatingLeft = state.prevAction.rotatingLeft;
  ship.rotatingRight = state.prevAction.rotatingRight;
  ship.braking = state.prevAction.braking;

  // Fire decision: snap check based on current aim geometry
  const dx = target.x - ship.x;
  const dy = target.y - ship.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angleToTarget = Math.atan2(dy, dx);
  const headingDiff = Math.abs(normalizeAngle(angleToTarget - ship.heading));

  ship.fire = headingDiff < FIRE_ANGLE && dist < MAX_FIRE_RANGE;
}

/**
 * Predictive AI strategy object — pluggable interface.
 */
const predictiveStrategy = {
  createState: createPredictiveState,
  update: updatePredictiveAI,
};

// ===== ai-reactive.js =====

/** Dead zone for rotation — prevents oscillation (~3°). */
const ROTATION_DEADZONE = 0.05;

/** Thrust engages when heading is within this angle of target (~60°). */
const THRUST_ANGLE = Math.PI / 3;

/** Brake threshold — brake when not facing target and speed exceeds this. */
const BRAKE_SPEED = 50;

/** Lead calculation divisor (~MAX_SPEED). */
const PREDICTION_SPEED = 400;

/** Maximum look-ahead time for target prediction (seconds). */
const MAX_PREDICTION_TIME = 2.0;

/** Angular threshold for AI firing (~8.6°). */
const FIRE_ANGLE = 0.15;

/** Max distance (px) at which AI will fire. */
const MAX_FIRE_RANGE = 500;

/** How far ahead (px) the AI scans for obstacles along its predicted path. */
const AVOID_LOOKAHEAD = 800;

/** Buffer (px) around obstacle collision radius for avoidance. */
const AVOID_MARGIN = 50;

/** Maximum steering offset (rad) from avoidance. */
const AVOID_STRENGTH = 2.5;

/** Proximity detection radius (px) — catches obstacles the cylinder misses. */
const AVOID_PROXIMITY = 80;

/** How aggressively avoidance suppresses pursuit (urgency * this >= 1 → pure avoidance). */
const AVOIDANCE_PRIORITY = 2;

/** Time horizon (seconds) for predicting future velocity in avoidance. */
const AVOID_PREDICT_TIME = 0.3;

/** Speed threshold below which avoidance falls back to heading direction. */
const AVOID_MIN_SPEED = 1;

/**
 * Normalize an angle to the range [-PI, PI].
 */
function normalizeAngleAI(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create reactive AI decision state.
 */
function createReactiveState() {
  return {};
}

/**
 * Compute a steering angle offset to avoid obstacles on a collision course.
 *
 * Projects a look-ahead cylinder along the ship's predicted velocity
 * direction (accounting for current momentum + thrust input). Falls back
 * to heading when nearly stationary.
 *
 * Returns { offset, maxUrgency } where offset is the summed angle in
 * radians (positive = steer right, negative = steer left) and maxUrgency
 * is the highest raw urgency (before squaring) across all obstacles.
 */
function computeAvoidanceOffset(aiShip, obstacles) {
  let totalOffset = 0;
  let maxRawUrgency = 0;

  // Compute predicted velocity: current velocity + thrust acceleration
  const power = aiShip.thrustPower ?? THRUST_POWER;
  const thrustAccel =
    aiShip.thrust && aiShip.thrustIntensity > 0
      ? power * aiShip.thrustIntensity
      : 0;
  const predVx =
    aiShip.vx + Math.cos(aiShip.heading) * thrustAccel * AVOID_PREDICT_TIME;
  const predVy =
    aiShip.vy + Math.sin(aiShip.heading) * thrustAccel * AVOID_PREDICT_TIME;
  const predSpeed = Math.sqrt(predVx * predVx + predVy * predVy);

  // Determine look-ahead direction: predicted velocity, or heading fallback
  let dirX;
  let dirY;
  if (predSpeed >= AVOID_MIN_SPEED) {
    dirX = predVx / predSpeed;
    dirY = predVy / predSpeed;
  } else {
    dirX = Math.cos(aiShip.heading);
    dirY = Math.sin(aiShip.heading);
  }

  // dirX, dirY form the forward axis; perpendicular is (-dirY, dirX)
  for (const obs of obstacles) {
    const dx = obs.x - aiShip.x;
    const dy = obs.y - aiShip.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Project onto predicted velocity axis (ahead) and perpendicular (lateral)
    const ahead = dx * dirX + dy * dirY;
    const lateral = -dx * dirY + dy * dirX;

    // --- Cylinder threat ---
    let cylinderUrgency = 0;
    if (ahead > 0 && ahead < AVOID_LOOKAHEAD) {
      const dangerRadius = obs.radius + AVOID_MARGIN;
      if (Math.abs(lateral) < dangerRadius) {
        cylinderUrgency = 1 - ahead / AVOID_LOOKAHEAD;
      }
    }

    // --- Proximity threat ---
    let proximityUrgency = 0;
    const proximityRadius = obs.radius + AVOID_PROXIMITY;
    if (dist < proximityRadius) {
      proximityUrgency = 1 - dist / proximityRadius;
    }

    // Combined urgency: take the stronger signal (linear — stronger medium-range response)
    const rawUrgency = Math.max(cylinderUrgency, proximityUrgency);
    if (rawUrgency <= 0) continue;
    maxRawUrgency = Math.max(maxRawUrgency, rawUrgency);

    // Steer away from obstacle: obstacle to right (lateral > 0) → steer left (negative)
    // Dead center (lateral ≈ 0) → default to steering right (positive)
    const steerDirection = lateral > 0 ? -1 : 1;

    totalOffset += steerDirection * AVOID_STRENGTH * rawUrgency;
  }

  return { offset: totalOffset, maxUrgency: maxRawUrgency };
}

/**
 * Update reactive AI control flags on aiShip to pursue targetShip,
 * fire when aimed, and avoid obstacles.
 *
 * Sets the same 5 control flags as keyboard input so the ship physics
 * engine treats AI and player identically.
 */
function updateReactiveAI(_aiState, aiShip, targetShip, asteroids, _dt) {
  // If either ship is dead, clear all flags
  if (!aiShip.alive || !targetShip.alive) {
    aiShip.thrust = false;
    aiShip.rotatingLeft = false;
    aiShip.rotatingRight = false;
    aiShip.braking = false;
    aiShip.fire = false;
    return;
  }

  // Distance to target
  const dx = targetShip.x - aiShip.x;
  const dy = targetShip.y - aiShip.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  // Lead prediction
  const lookAheadTime = Math.min(dist / PREDICTION_SPEED, MAX_PREDICTION_TIME);
  const predictedX = targetShip.x + targetShip.vx * lookAheadTime;
  const predictedY = targetShip.y + targetShip.vy * lookAheadTime;

  // Angle to predicted position (pursuit angle)
  const pursuitAngle = Math.atan2(predictedY - aiShip.y, predictedX - aiShip.x);

  // Build obstacle list: asteroids only (target ship excluded — AI pursues it)
  const obstacles = asteroids.map((a) => ({
    x: a.x,
    y: a.y,
    radius: a.collisionRadius,
  }));

  // Compute avoidance offset and survival-first blending
  const { offset: avoidanceOffset, maxUrgency } = computeAvoidanceOffset(
    aiShip,
    obstacles,
  );

  // Heading diff to raw pursuit target (for firing decision — fire at target, not avoidance direction)
  const pursuitHeadingDiff = normalizeAngleAI(pursuitAngle - aiShip.heading);

  // Survival-first: suppress pursuit proportionally to threat urgency
  const survivalWeight = Math.min(maxUrgency * AVOIDANCE_PRIORITY, 1.0);
  const pursuitDiff = pursuitHeadingDiff * (1 - survivalWeight);
  const headingDiff = normalizeAngleAI(pursuitDiff + avoidanceOffset);

  // Rotation: turn toward effective angle with dead zone
  aiShip.rotatingLeft = headingDiff < -ROTATION_DEADZONE;
  aiShip.rotatingRight = headingDiff > ROTATION_DEADZONE;

  // Thrust: engage when roughly facing effective direction, or during active avoidance
  const facingEffective = Math.abs(headingDiff) < THRUST_ANGLE;
  const avoidanceActive = avoidanceOffset !== 0;
  aiShip.thrust = facingEffective || avoidanceActive;

  // Brake: engage when NOT facing target AND speed exceeds threshold AND no avoidance
  const speed = Math.sqrt(aiShip.vx * aiShip.vx + aiShip.vy * aiShip.vy);
  aiShip.braking = !facingEffective && !avoidanceActive && speed > BRAKE_SPEED;

  // Fire: aimed within FIRE_ANGLE of predicted target AND within range
  aiShip.fire =
    Math.abs(pursuitHeadingDiff) < FIRE_ANGLE && dist < MAX_FIRE_RANGE;
}

/**
 * Reactive AI strategy object — pluggable interface.
 */
const reactiveStrategy = {
  createState: createReactiveState,
  update: updateReactiveAI,
};

// ===== ai.js =====
/**
 * AI Facade — registers strategies and provides backward-compatible aliases.
 *
 * Registers all available AI strategies in the ai-core registry. Provides
 * createAIState/updateAI as backward-compatible aliases for the reactive
 * strategy, and spawnEnemyPosition for enemy ship placement.
 *
 * In ES module mode, consumers import getStrategy/listStrategies from
 * ai-core.js and reactive constants from ai-reactive.js directly.
 * In the build (single scope), all symbols are already global.
 */


// ── Register strategies ──────────────────────────────────────────────
registerStrategy('reactive', reactiveStrategy);
registerStrategy('predictive', predictiveStrategy);

// ── Backward-compatible aliases (new names — no redeclaration conflict) ──
const createAIState = createReactiveState;
const updateAI = updateReactiveAI;

/** Minimum enemy spawn offset from player (px). Just off-screen at 1920×1080. */
const MIN_SPAWN_DISTANCE = 1000;

/** Maximum enemy spawn offset from player (px). Tight band just past viewport. */
const MAX_SPAWN_DISTANCE = 1100;

/**
 * Compute a random spawn position for the enemy ship at
 * MIN_SPAWN_DISTANCE–MAX_SPAWN_DISTANCE from the player.
 */
function spawnEnemyPosition(playerX, playerY) {
  const angle = Math.random() * 2 * Math.PI;
  const distance =
    MIN_SPAWN_DISTANCE +
    Math.random() * (MAX_SPAWN_DISTANCE - MIN_SPAWN_DISTANCE);
  return {
    x: playerX + Math.cos(angle) * distance,
    y: playerY + Math.sin(angle) * distance,
  };
}

// ===== asteroid.js =====
/**
 * Generate an irregular polygon shape for an asteroid.
 * Returns an array of [x, y] vertex pairs centered at origin.
 * Vertices are ordered by increasing angle (no crossed edges).
 */
function generateShape(radius) {
  const vertexCount = 8 + Math.floor(Math.random() * 7); // 8–14
  const step = (Math.PI * 2) / vertexCount;
  const vertices = [];

  for (let i = 0; i < vertexCount; i++) {
    const angle = -Math.PI + step * i; // start at -PI so angles are monotonically increasing
    const r = radius * (0.6 + Math.random() * 0.4); // 0.6–1.0 of radius
    vertices.push([r * Math.cos(angle), r * Math.sin(angle)]);
  }

  return vertices;
}

/**
 * Determine stroke width from asteroid radius (size class).
 */
function getStrokeWidth(radius) {
  if (radius >= 50) return 2.0; // large
  if (radius >= 25) return 1.5; // medium
  return 1.0; // small
}

/** Average vertex distance factor for headless collision radius (E[0.6 + U(0,0.4)]). */
const HEADLESS_COLLISION_FACTOR = 0.8;

/**
 * Create an asteroid object.
 * When headless is true, visual-only data (shape, strokeWidth) is skipped
 * and collisionRadius uses a deterministic approximation.
 */
function createAsteroid({ x, y, vx, vy, radius, headless = false }) {
  let shape, collisionRadius, angularVelocity, strokeWidth;

  if (headless) {
    shape = null;
    collisionRadius = radius * HEADLESS_COLLISION_FACTOR;
    angularVelocity = 0;
    strokeWidth = 0;
  } else {
    // Angular velocity scaled inversely to radius: smaller = faster spin
    const maxAngVel = 0.5 * (20 / Math.max(radius, 10));
    angularVelocity = (Math.random() * 2 - 1) * Math.min(maxAngVel, 0.5);

    shape = generateShape(radius);

    // Compute effective collision radius as average vertex distance from center
    collisionRadius =
      shape.reduce((sum, [px, py]) => sum + Math.sqrt(px * px + py * py), 0) /
      shape.length;

    strokeWidth = getStrokeWidth(radius);
  }

  return {
    x,
    y,
    vx,
    vy,
    radius,
    collisionRadius,
    rotation: 0,
    angularVelocity,
    shape,
    strokeWidth,
  };
}

/**
 * Update asteroid position and rotation by delta time.
 */
function updateAsteroid(asteroid, dt) {
  asteroid.x += asteroid.vx * dt;
  asteroid.y += asteroid.vy * dt;
  asteroid.rotation += asteroid.angularVelocity * dt;
}

/**
 * Draw an asteroid as a white wireframe polygon on a canvas 2D context.
 */
function drawAsteroid(ctx, asteroid) {
  const { x, y, rotation, shape, strokeWidth } = asteroid;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = strokeWidth;

  ctx.beginPath();
  ctx.moveTo(shape[0][0], shape[0][1]);
  for (let i = 1; i < shape.length; i++) {
    ctx.lineTo(shape[i][0], shape[i][1]);
  }
  ctx.closePath();
  ctx.stroke();

  ctx.restore();
}

// ===== bullet.js =====
/** Bullet travel speed in pixels/second. */
const BULLET_SPEED = 600;

/** Bullet lifetime in seconds before expiry. */
const BULLET_LIFETIME = 2;

/** Minimum interval between shots in seconds. */
const FIRE_COOLDOWN = 0.2;

/** Visual line length of a bullet in pixels. */
const BULLET_LENGTH = 4;

/**
 * Create a bullet entity at the given position, traveling in heading
 * direction at BULLET_SPEED plus inherited ship velocity.
 */
function createBullet(x, y, heading, shipVx, shipVy, owner) {
  return {
    x,
    y,
    vx: Math.cos(heading) * BULLET_SPEED + shipVx,
    vy: Math.sin(heading) * BULLET_SPEED + shipVy,
    heading,
    age: 0,
    owner,
  };
}

/**
 * Update bullet position and age for one frame.
 */
function updateBullet(bullet, dt) {
  bullet.x += bullet.vx * dt;
  bullet.y += bullet.vy * dt;
  bullet.age += dt;
}

/**
 * Returns true when the bullet has exceeded its lifetime.
 */
function isBulletExpired(bullet) {
  return bullet.age >= BULLET_LIFETIME;
}

/**
 * Draw a bullet as a short white line segment oriented along its heading.
 */
function drawBullet(ctx, bullet) {
  const halfLen = BULLET_LENGTH / 2;
  const dx = Math.cos(bullet.heading) * halfLen;
  const dy = Math.sin(bullet.heading) * halfLen;

  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(bullet.x - dx, bullet.y - dy);
  ctx.lineTo(bullet.x + dx, bullet.y + dy);
  ctx.stroke();
}

/**
 * Remove bullets that are inside any asteroid's collision radius.
 * Returns the filtered array of surviving bullets. Asteroids are unaffected.
 */
function checkBulletAsteroidCollisions(bullets, asteroids) {
  return bullets.filter((bullet) => {
    for (const asteroid of asteroids) {
      const dx = bullet.x - asteroid.x;
      const dy = bullet.y - asteroid.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < asteroid.collisionRadius) {
        return false;
      }
    }
    return true;
  });
}

// ===== camera.js =====
/**
 * Create a camera state object.
 */
function createCamera(x, y, rotation) {
  return { x, y, rotation };
}

/**
 * Apply camera transform to a canvas context.
 * Saves context, then applies: translate to screen center →
 * rotate by -rotation → translate by (-x, -y).
 */
function applyCameraTransform(ctx, camera, viewportW, viewportH) {
  ctx.save();
  ctx.translate(viewportW / 2, viewportH / 2);
  ctx.rotate(-camera.rotation);
  ctx.translate(-camera.x, -camera.y);
}

/**
 * Reset camera transform by restoring the saved context.
 */
function resetCameraTransform(ctx) {
  ctx.restore();
}

/**
 * Compute the axis-aligned bounding box of the rotated viewport in world-space.
 * Returns { minX, maxX, minY, maxY } with optional padding margin.
 */
function getViewportBounds(camera, viewportW, viewportH, margin = 0) {
  const cosA = Math.abs(Math.cos(camera.rotation));
  const sinA = Math.abs(Math.sin(camera.rotation));
  const halfW = (viewportW * cosA + viewportH * sinA) / 2;
  const halfH = (viewportW * sinA + viewportH * cosA) / 2;
  return {
    minX: camera.x - halfW - margin,
    maxX: camera.x + halfW + margin,
    minY: camera.y - halfH - margin,
    maxY: camera.y + halfH + margin,
  };
}

/**
 * Convert a world-space coordinate to screen-space.
 * Returns [screenX, screenY].
 */
function worldToScreen(wx, wy, camera, viewportW, viewportH) {
  // Translate by (-camera.x, -camera.y)
  const dx = wx - camera.x;
  const dy = wy - camera.y;
  // Rotate by -camera.rotation
  const cosR = Math.cos(-camera.rotation);
  const sinR = Math.sin(-camera.rotation);
  const rx = dx * cosR - dy * sinR;
  const ry = dx * sinR + dy * cosR;
  // Translate to screen center
  return [rx + viewportW / 2, ry + viewportH / 2];
}

/**
 * Convert a screen-space coordinate to world-space.
 * Returns [worldX, worldY]. Inverse of worldToScreen.
 */
function screenToWorld(sx, sy, camera, viewportW, viewportH) {
  // Reverse translate from screen center
  const cx = sx - viewportW / 2;
  const cy = sy - viewportH / 2;
  // Reverse rotate (rotate by +camera.rotation)
  const cosR = Math.cos(camera.rotation);
  const sinR = Math.sin(camera.rotation);
  const rx = cx * cosR - cy * sinR;
  const ry = cx * sinR + cy * cosR;
  // Reverse translate
  return [rx + camera.x, ry + camera.y];
}

// ===== debug.js =====
/**
 * AI Debug Logger — structured console telemetry for diagnosing AI behavior.
 *
 * Toggled via settings checkbox or window.aiDebug.enable()/disable().
 * Zero cost when disabled — all functions are no-ops.
 */

/** Rate limit interval for periodic logs (seconds). */
const LOG_INTERVAL = 0.5;

/**
 * Format ship control flags as a compact 4-character string.
 * T=thrust, L=left, R=right, B=brake, _=inactive.
 */
function fmtAction(ship) {
  return (
    (ship.thrust ? 'T' : '_') +
    (ship.rotatingLeft ? 'L' : '_') +
    (ship.rotatingRight ? 'R' : '_') +
    (ship.braking ? 'B' : '_')
  );
}

/**
 * Create a debug logger instance.
 */
function createDebugLogger() {
  let enabled = false;
  let lastLogTime = -Infinity;
  let lastAction = '';

  function enable() {
    enabled = true;
  }

  function disable() {
    enabled = false;
  }

  function isEnabled() {
    return enabled;
  }

  /**
   * Log AI frame telemetry. Rate-limited to LOG_INTERVAL, but always
   * logs immediately on action change.
   */
  function logAIFrame(elapsed, enemy, player, debugInfo) {
    if (!enabled) return;

    const action = fmtAction(enemy);
    const actionChanged = action !== lastAction && lastAction !== '';
    const timeSinceLastLog = elapsed - lastLogTime;

    if (!actionChanged && timeSinceLastLog < LOG_INTERVAL && lastLogTime >= 0) {
      return;
    }

    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const dist = Math.round(Math.sqrt(dx * dx + dy * dy));
    const spd = Math.round(
      Math.sqrt(enemy.vx * enemy.vx + enemy.vy * enemy.vy),
    );

    if (actionChanged) {
      console.log(
        `[AI ${elapsed.toFixed(2)}s] CHANGE ${lastAction} → ${action} dist=${dist}`,
      );
    } else {
      let msg = `[AI ${elapsed.toFixed(2)}s] dist=${dist} action=${action} spd=${spd} hdg=${enemy.heading.toFixed(2)} pos=(${Math.round(enemy.x)},${Math.round(enemy.y)})`;

      if (debugInfo?.candidates) {
        const scores = debugInfo.candidates
          .map((c) => `${c.name}:${Math.round(c.score)}`)
          .join(' ');
        msg += ` | ${scores}`;
      }

      console.log(msg);
    }

    lastAction = action;
    lastLogTime = elapsed;
  }

  /**
   * Log an immediate event (fire, collision, etc.).
   */
  function logEvent(elapsed, type, data) {
    if (!enabled) return;

    const parts = Object.entries(data)
      .map(([k, v]) => {
        if (typeof v === 'number') {
          return `${k}=${Number.isInteger(v) ? v : v.toFixed(2)}`;
        }
        return `${k}=${v}`;
      })
      .join(' ');

    console.log(`[${type} ${elapsed.toFixed(2)}s] ${parts}`);
  }

  return {
    enable,
    disable,
    isEnabled,
    logAIFrame,
    logEvent,
  };
}

// ===== energy.js =====
/**
 * Compute kinetic energy for a single asteroid.
 * KE = 0.5 * mass * speed², where mass = collisionRadius²
 */
function computeKE(asteroid) {
  const mass = asteroid.collisionRadius * asteroid.collisionRadius;
  return 0.5 * mass * (asteroid.vx * asteroid.vx + asteroid.vy * asteroid.vy);
}

/**
 * Sum kinetic energy across all asteroids.
 */
function computeTotalKE(asteroids) {
  let total = 0;
  for (const a of asteroids) {
    total += computeKE(a);
  }
  return total;
}

/**
 * Compute a speed multiplier for new spawns to sustain system energy.
 * Returns clamp(sqrt(targetKE / actualKE), 1.0, 1.5).
 */
function computeSpeedBoost(
  baselineKEPerAsteroid,
  targetCount,
  asteroids,
) {
  const targetKE = baselineKEPerAsteroid * targetCount;
  if (targetKE <= 0) return 1.0;

  const actualKE = computeTotalKE(asteroids);
  if (actualKE <= 0) return 1.5;
  if (actualKE >= targetKE) return 1.0;

  return Math.min(Math.sqrt(targetKE / actualKE), 1.5);
}

// ===== font.js =====
/** Grid width per glyph (units). */
const GLYPH_WIDTH = 4;

/** Grid height per glyph (units). */
const GLYPH_HEIGHT = 6;

/** Spacing between characters (grid units). */
const GLYPH_SPACING = 1;

/**
 * Vector glyph data — each character is an array of polylines.
 * Each polyline is an array of [x, y] points on a 4-wide × 6-tall grid.
 * Drawn as connected line segments matching the wireframe aesthetic.
 */
const GLYPHS = {
  A: [
    [
      [0, 6],
      [0, 2],
      [2, 0],
      [4, 2],
      [4, 6],
    ],
    [
      [0, 4],
      [4, 4],
    ],
  ],
  B: [
    [
      [0, 6],
      [0, 0],
      [3, 0],
      [4, 1],
      [3, 3],
      [0, 3],
    ],
    [
      [3, 3],
      [4, 4],
      [4, 5],
      [3, 6],
      [0, 6],
    ],
  ],
  C: [
    [
      [4, 1],
      [3, 0],
      [1, 0],
      [0, 1],
      [0, 5],
      [1, 6],
      [3, 6],
      [4, 5],
    ],
  ],
  D: [
    [
      [0, 0],
      [0, 6],
      [3, 6],
      [4, 5],
      [4, 1],
      [3, 0],
      [0, 0],
    ],
  ],
  E: [
    [
      [4, 0],
      [0, 0],
      [0, 6],
      [4, 6],
    ],
    [
      [0, 3],
      [3, 3],
    ],
  ],
  F: [
    [
      [4, 0],
      [0, 0],
      [0, 6],
    ],
    [
      [0, 3],
      [3, 3],
    ],
  ],
  G: [
    [
      [4, 1],
      [3, 0],
      [1, 0],
      [0, 1],
      [0, 5],
      [1, 6],
      [3, 6],
      [4, 5],
      [4, 3],
      [2, 3],
    ],
  ],
  H: [
    [
      [0, 0],
      [0, 6],
    ],
    [
      [4, 0],
      [4, 6],
    ],
    [
      [0, 3],
      [4, 3],
    ],
  ],
  I: [
    [
      [1, 0],
      [3, 0],
    ],
    [
      [2, 0],
      [2, 6],
    ],
    [
      [1, 6],
      [3, 6],
    ],
  ],
  J: [
    [
      [1, 0],
      [4, 0],
    ],
    [
      [3, 0],
      [3, 5],
      [2, 6],
      [1, 6],
      [0, 5],
    ],
  ],
  K: [
    [
      [0, 0],
      [0, 6],
    ],
    [
      [4, 0],
      [0, 3],
      [4, 6],
    ],
  ],
  L: [
    [
      [0, 0],
      [0, 6],
      [4, 6],
    ],
  ],
  M: [
    [
      [0, 6],
      [0, 0],
      [2, 3],
      [4, 0],
      [4, 6],
    ],
  ],
  N: [
    [
      [0, 6],
      [0, 0],
      [4, 6],
      [4, 0],
    ],
  ],
  O: [
    [
      [1, 0],
      [3, 0],
      [4, 1],
      [4, 5],
      [3, 6],
      [1, 6],
      [0, 5],
      [0, 1],
      [1, 0],
    ],
  ],
  P: [
    [
      [0, 6],
      [0, 0],
      [3, 0],
      [4, 1],
      [4, 2],
      [3, 3],
      [0, 3],
    ],
  ],
  Q: [
    [
      [1, 0],
      [3, 0],
      [4, 1],
      [4, 5],
      [3, 6],
      [1, 6],
      [0, 5],
      [0, 1],
      [1, 0],
    ],
    [
      [3, 5],
      [4, 6],
    ],
  ],
  R: [
    [
      [0, 6],
      [0, 0],
      [3, 0],
      [4, 1],
      [4, 2],
      [3, 3],
      [0, 3],
    ],
    [
      [2, 3],
      [4, 6],
    ],
  ],
  S: [
    [
      [4, 1],
      [3, 0],
      [1, 0],
      [0, 1],
      [0, 2],
      [1, 3],
      [3, 3],
      [4, 4],
      [4, 5],
      [3, 6],
      [1, 6],
      [0, 5],
    ],
  ],
  T: [
    [
      [0, 0],
      [4, 0],
    ],
    [
      [2, 0],
      [2, 6],
    ],
  ],
  U: [
    [
      [0, 0],
      [0, 5],
      [1, 6],
      [3, 6],
      [4, 5],
      [4, 0],
    ],
  ],
  V: [
    [
      [0, 0],
      [2, 6],
      [4, 0],
    ],
  ],
  W: [
    [
      [0, 0],
      [0, 6],
      [2, 4],
      [4, 6],
      [4, 0],
    ],
  ],
  X: [
    [
      [0, 0],
      [4, 6],
    ],
    [
      [4, 0],
      [0, 6],
    ],
  ],
  Y: [
    [
      [0, 0],
      [2, 3],
      [4, 0],
    ],
    [
      [2, 3],
      [2, 6],
    ],
  ],
  Z: [
    [
      [0, 0],
      [4, 0],
      [0, 6],
      [4, 6],
    ],
  ],
  0: [
    [
      [1, 0],
      [3, 0],
      [4, 1],
      [4, 5],
      [3, 6],
      [1, 6],
      [0, 5],
      [0, 1],
      [1, 0],
    ],
    [
      [0, 5],
      [4, 1],
    ],
  ],
  1: [
    [
      [1, 1],
      [2, 0],
      [2, 6],
    ],
    [
      [1, 6],
      [3, 6],
    ],
  ],
  2: [
    [
      [0, 1],
      [1, 0],
      [3, 0],
      [4, 1],
      [4, 2],
      [0, 6],
      [4, 6],
    ],
  ],
  3: [
    [
      [0, 1],
      [1, 0],
      [3, 0],
      [4, 1],
      [4, 2],
      [3, 3],
      [4, 4],
      [4, 5],
      [3, 6],
      [1, 6],
      [0, 5],
    ],
    [
      [2, 3],
      [3, 3],
    ],
  ],
  4: [
    [
      [0, 0],
      [0, 3],
      [4, 3],
    ],
    [
      [4, 0],
      [4, 6],
    ],
  ],
  5: [
    [
      [4, 0],
      [0, 0],
      [0, 3],
      [3, 3],
      [4, 4],
      [4, 5],
      [3, 6],
      [1, 6],
      [0, 5],
    ],
  ],
  6: [
    [
      [3, 0],
      [1, 0],
      [0, 1],
      [0, 5],
      [1, 6],
      [3, 6],
      [4, 5],
      [4, 4],
      [3, 3],
      [0, 3],
    ],
  ],
  7: [
    [
      [0, 0],
      [4, 0],
      [2, 6],
    ],
  ],
  8: [
    [
      [1, 0],
      [3, 0],
      [4, 1],
      [4, 2],
      [3, 3],
      [1, 3],
      [0, 2],
      [0, 1],
      [1, 0],
    ],
    [
      [1, 3],
      [0, 4],
      [0, 5],
      [1, 6],
      [3, 6],
      [4, 5],
      [4, 4],
      [3, 3],
    ],
  ],
  9: [
    [
      [4, 3],
      [1, 3],
      [0, 2],
      [0, 1],
      [1, 0],
      [3, 0],
      [4, 1],
      [4, 5],
      [3, 6],
      [1, 6],
    ],
  ],
  ' ': [],
  '.': [
    [
      [2, 5],
      [2, 6],
    ],
  ],
  '!': [
    [
      [2, 0],
      [2, 4],
    ],
    [
      [2, 5.5],
      [2, 6],
    ],
  ],
  ':': [
    [
      [2, 1],
      [2, 2],
    ],
    [
      [2, 4],
      [2, 5],
    ],
  ],
};

/**
 * Draw vector-stroked text centered at (centerX, centerY).
 *
 * @param {CanvasRenderingContext2D} ctx
 * @param {string} text
 * @param {number} centerX - horizontal center of the text
 * @param {number} centerY - vertical center of the text
 * @param {number} scale - pixel size per grid unit
 * @param {object} [options]
 * @param {string} [options.color='#FFFFFF']
 * @param {number} [options.lineWidth=1.5]
 * @param {number} [options.alpha=1.0]
 */
function drawVectorText(
  ctx,
  text,
  centerX,
  centerY,
  scale,
  options = {},
) {
  const upper = text.toUpperCase();
  if (upper.length === 0) return;

  const { color = '#FFFFFF', lineWidth = 1.5, alpha = 1.0 } = options;

  const charWidth = GLYPH_WIDTH * scale;
  const charHeight = GLYPH_HEIGHT * scale;
  const gap = GLYPH_SPACING * scale;
  const totalWidth = upper.length * charWidth + (upper.length - 1) * gap;
  const startX = centerX - totalWidth / 2;
  const startY = centerY - charHeight / 2;

  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.globalAlpha = alpha;

  for (let i = 0; i < upper.length; i++) {
    const ch = upper[i];
    const polylines = GLYPHS[ch];
    if (!polylines) continue;

    const ox = startX + i * (charWidth + gap);

    for (const polyline of polylines) {
      ctx.beginPath();
      for (let p = 0; p < polyline.length; p++) {
        const px = ox + polyline[p][0] * scale;
        const py = startY + polyline[p][1] * scale;
        if (p === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      }
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ===== game-env.js =====

const DT = 1 / 60;
const VIEWPORT_W = 1920;
const VIEWPORT_H = 1080;
const ENV_BASE_ASTEROID_COUNT = 40;

/** Action index → control flag mapping (10 discrete move actions). */
const ACTION_MAP = [
  { thrust: true, rotL: false, rotR: false, brake: false }, // 0: thrust-straight
  { thrust: true, rotL: true, rotR: false, brake: false }, // 1: thrust-left
  { thrust: true, rotL: false, rotR: true, brake: false }, // 2: thrust-right
  { thrust: false, rotL: false, rotR: false, brake: false }, // 3: coast-straight
  { thrust: false, rotL: true, rotR: false, brake: false }, // 4: coast-left
  { thrust: false, rotL: false, rotR: true, brake: false }, // 5: coast-right
  { thrust: false, rotL: false, rotR: false, brake: true }, // 6: brake-straight
  { thrust: false, rotL: true, rotR: false, brake: true }, // 7: brake-left
  { thrust: false, rotL: false, rotR: true, brake: true }, // 8: brake-right
  { thrust: false, rotL: false, rotR: false, brake: false }, // 9: no-op
];

function getDefaultConfig() {
  return {
    shipHP: 1,
    maxTicks: 3600,
    asteroidDensity: 1.0,
    enemyPolicy: 'predictive',
    enemyShoots: true,
    spawnDistance: 500,
    spawnFacing: true,
    frameSkip: 1,
    rewardWeights: DEFAULT_REWARD_WEIGHTS,
    campCheckTicks: 0,
    campMinClosing: 100,
  };
}

/**
 * Gym-style training environment wrapping headless game simulation.
 * Usage: env.reset(config) → observation, then env.step(move, fire) → { observation, reward, done, info }
 */
class GameEnv {
  constructor() {
    this._initialized = false;
  }

  /**
   * Initialize a new episode.
   * @param {Object} [config] - episode configuration overrides
   * @returns {Float32Array} initial observation
   */
  reset(config = {}) {
    this._config = { ...getDefaultConfig(), ...config };
    const c = this._config;

    // Agent ship at viewport center, heading up (-PI/2)
    const centerX = VIEWPORT_W / 2;
    const centerY = VIEWPORT_H / 2;
    this._agent = createShip({
      x: centerX,
      y: centerY,
      heading: -Math.PI / 2,
      owner: 'player',
    });

    // Opponent at spawnDistance in random direction
    const spawnAngle = Math.random() * 2 * Math.PI;
    const opponentX = centerX + Math.cos(spawnAngle) * c.spawnDistance;
    const opponentY = centerY + Math.sin(spawnAngle) * c.spawnDistance;
    this._opponent = createShip({
      x: opponentX,
      y: opponentY,
      heading: Math.random() * 2 * Math.PI,
      owner: 'enemy',
    });

    // If spawnFacing: both ships face each other
    if (c.spawnFacing) {
      this._agent.heading = Math.atan2(
        this._opponent.y - this._agent.y,
        this._opponent.x - this._agent.x,
      );
      this._opponent.heading = Math.atan2(
        this._agent.y - this._opponent.y,
        this._agent.x - this._opponent.x,
      );
    } else {
      this._agent.heading = -Math.PI / 2;
      // opponent heading stays random (set above)
    }

    // HP system (internal to GameEnv)
    this._agentHP = c.shipHP;
    this._opponentHP = c.shipHP;

    // Camera following agent
    this._camera = createCamera(this._agent.x, this._agent.y, 0);

    // Asteroid simulation
    const viewportBounds = getViewportBounds(
      this._camera,
      VIEWPORT_W,
      VIEWPORT_H,
    );
    const targetCount = Math.round(ENV_BASE_ASTEROID_COUNT * c.asteroidDensity);
    this._sim = createSimulation(viewportBounds, targetCount, true);

    // Clear spawn zones around both ships
    this._sim.asteroids = clearSpawnZone(this._sim.asteroids, [
      this._agent,
      this._opponent,
    ]);

    // Opponent strategy
    if (c.enemyPolicy === 'static') {
      this._strategy = null;
      this._strategyState = null;
    } else {
      this._strategy = getStrategy(c.enemyPolicy);
      this._strategyState = this._strategy.createState(this._config);
      // Apply per-episode AI tuning overrides (training speed optimization)
      if (c.aiHoldTime != null) this._strategyState.holdTime = c.aiHoldTime;
      if (c.aiSimSteps != null) this._strategyState.simSteps = c.aiSimSteps;
    }

    // Bullets
    this._bullets = [];

    // Death cause tracking
    this._agentDeathCause = null;
    this._opponentDeathCause = null;

    // Counters
    this._tick = 0;
    this._hitsLanded = 0;
    this._hitsTaken = 0;
    this._asteroidsHit = 0;

    // Camp detection: track agent position for periodic movement checks
    this._campCheckX = this._agent.x;
    this._campCheckY = this._agent.y;
    this._nextCampCheck = this._config.campCheckTicks || 0;

    // Initial reward state snapshot
    this._prevRewardState = this._buildRewardState();

    this._initialized = true;

    return buildObservation(this._agent, this._opponent, this._sim.asteroids);
  }

  /**
   * Advance simulation by one tick.
   * @param {number} moveAction - integer 0–9
   * @param {number} fireAction - 0 or 1
   * @returns {{ observation: Float32Array, reward: number, done: boolean, info: Object }}
   */
  step(moveAction, fireAction) {
    if (!this._initialized) {
      throw new Error('Must call reset() before step()');
    }

    // Validate actions
    if (!Number.isInteger(moveAction) || moveAction < 0 || moveAction > 9) {
      throw new Error(
        `Invalid moveAction: ${moveAction}. Must be integer 0–9.`,
      );
    }
    if (fireAction !== 0 && fireAction !== 1) {
      throw new Error(`Invalid fireAction: ${fireAction}. Must be 0 or 1.`);
    }

    // 1. Apply agent action from ACTION_MAP (held for all sub-ticks)
    const action = ACTION_MAP[moveAction];
    this._agent.thrust = action.thrust;
    this._agent.rotatingLeft = action.rotL;
    this._agent.rotatingRight = action.rotR;
    this._agent.braking = action.brake;
    this._agent.fire = fireAction === 1;

    let totalReward = 0;
    let done = false;
    let winner = null;
    const frameSkip = this._config.frameSkip;

    for (let frame = 0; frame < frameSkip; frame++) {
      // 2. Apply opponent AI (if strategy exists and opponent alive)
      if (this._strategy && this._opponent.alive) {
        this._strategy.update(
          this._strategyState,
          this._opponent,
          this._agent,
          this._sim.asteroids,
          DT,
        );
        // Suppress fire if enemyShoots is false
        if (!this._config.enemyShoots) {
          this._opponent.fire = false;
        }
      }

      // 3. Update ships
      updateShip(this._agent, DT);
      updateShip(this._opponent, DT);

      // 4. Bullet firing
      this._tryFire(this._agent);
      this._tryFire(this._opponent);

      // 5. Update camera to follow agent
      this._camera.x = this._agent.x;
      this._camera.y = this._agent.y;

      // 6. Compute viewport → spawn bounds for asteroid simulation
      const viewportBounds = getViewportBounds(
        this._camera,
        VIEWPORT_W,
        VIEWPORT_H,
      );

      // 7. Update asteroid simulation
      updateSimulation(
        this._sim,
        DT,
        viewportBounds,
        this._agent.vx,
        this._agent.vy,
      );

      // 8. Update bullets: move, expire, asteroid collisions
      for (const bullet of this._bullets) {
        updateBullet(bullet, DT);
      }
      this._bullets = this._bullets.filter((b) => !isBulletExpired(b));
      this._bullets = checkBulletAsteroidCollisions(
        this._bullets,
        this._sim.asteroids,
      );

      // 9. Bullet-ship collisions → decrement HP (NOT alive yet)
      const {
        bullets: survivingBullets,
        playerHit,
        enemyHit,
      } = processBulletShipCollisions(
        this._bullets,
        this._agent,
        this._opponent,
      );
      this._bullets = survivingBullets;

      if (playerHit) {
        this._agentHP -= 1;
        this._hitsTaken += 1;
        if (this._agentHP <= 0 && this._agentDeathCause === null) {
          this._agentDeathCause = 'bullet';
        }
      }
      if (enemyHit) {
        this._opponentHP -= 1;
        this._hitsLanded += 1;
        if (this._opponentHP <= 0 && this._opponentDeathCause === null) {
          this._opponentDeathCause = 'bullet';
        }
      }

      // 10. Ship-asteroid collisions → decrement HP (NOT alive yet)
      if (this._agent.alive) {
        const agentAsteroid = checkShipAsteroidCollision(
          this._agent,
          this._sim.asteroids,
        );
        if (agentAsteroid) {
          this._agentHP -= 1;
          this._asteroidsHit += 1;
          if (this._agentHP <= 0 && this._agentDeathCause === null) {
            this._agentDeathCause = 'asteroid';
          }
        }
      }
      if (this._opponent.alive) {
        const opponentAsteroid = checkShipAsteroidCollision(
          this._opponent,
          this._sim.asteroids,
        );
        if (opponentAsteroid) {
          this._opponentHP -= 1;
          if (this._opponentHP <= 0 && this._opponentDeathCause === null) {
            this._opponentDeathCause = 'asteroid';
          }
        }
      }

      // 11. Build current reward state snapshot (alive=true, HP may be 0)
      const currentRewardState = this._buildRewardState();

      // 12. Compute reward (accumulated across sub-ticks)
      totalReward += computeReward(
        this._prevRewardState,
        currentRewardState,
        { moveAction, fireAction },
        this._config,
      );

      // 13. Set alive=false for ships with HP <= 0 (AFTER reward snapshot)
      if (this._agentHP <= 0) {
        this._agent.alive = false;
      }
      if (this._opponentHP <= 0) {
        this._opponent.alive = false;
      }

      // 14. Update prevRewardState
      this._prevRewardState = currentRewardState;

      // 15. Increment tick
      this._tick += 1;

      // 16. Determine done/winner
      if (this._agentHP <= 0 && this._opponentHP <= 0) {
        done = true;
        winner = 'draw_mutual';
      } else if (this._agentHP <= 0) {
        done = true;
        winner = 'opponent';
      } else if (this._opponentHP <= 0) {
        done = true;
        winner = 'agent';
      }

      if (this._tick >= this._config.maxTicks) {
        done = true;
        if (winner === null) {
          winner = 'timeout';
        }
      }

      // Camp check: agent must move campMinClosing px every campCheckTicks
      const campTicks = this._config.campCheckTicks;
      if (campTicks > 0 && this._tick >= this._nextCampCheck && !done) {
        const mdx = this._agent.x - this._campCheckX;
        const mdy = this._agent.y - this._campCheckY;
        const displacement = Math.sqrt(mdx * mdx + mdy * mdy);
        const minClosing = this._config.campMinClosing || 100;
        if (displacement < minClosing) {
          done = true;
          winner = 'opponent';
        } else {
          // Passed — reset checkpoint for next interval
          this._campCheckX = this._agent.x;
          this._campCheckY = this._agent.y;
          this._nextCampCheck = this._tick + campTicks;
        }
      }

      if (done) break;
    }

    // 17. Build observation + info (once, after all sub-ticks)
    const observation = buildObservation(
      this._agent,
      this._opponent,
      this._sim.asteroids,
    );
    const info = {
      winner,
      ticksElapsed: this._tick,
      hitsLanded: this._hitsLanded,
      hitsTaken: this._hitsTaken,
      asteroidsHit: this._asteroidsHit,
      agentDeathCause: this._agentDeathCause,
      opponentDeathCause: this._opponentDeathCause,
    };

    return { observation, reward: totalReward, done, info };
  }

  /**
   * Attempt to fire a bullet from a ship.
   * Inline implementation (logic mirrors simulate.js tryFireBullet).
   */
  _tryFire(ship) {
    ship.fireCooldown = Math.max(ship.fireCooldown - DT, 0);
    if (ship.fire && ship.fireCooldown <= 0 && ship.alive) {
      const noseX = ship.x + Math.cos(ship.heading) * SHIP_SIZE;
      const noseY = ship.y + Math.sin(ship.heading) * SHIP_SIZE;
      this._bullets.push(
        createBullet(noseX, noseY, ship.heading, ship.vx, ship.vy, ship.owner),
      );
      ship.fireCooldown = FIRE_COOLDOWN;
    }
  }

  /**
   * Build a reward state snapshot for computeReward.
   */
  _buildRewardState() {
    return {
      ship: {
        x: this._agent.x,
        y: this._agent.y,
        heading: this._agent.heading,
        vx: this._agent.vx,
        vy: this._agent.vy,
        alive: this._agent.alive,
      },
      target: {
        x: this._opponent.x,
        y: this._opponent.y,
        heading: this._opponent.heading,
        vx: this._opponent.vx,
        vy: this._opponent.vy,
        alive: this._opponent.alive,
      },
      asteroids: this._sim.asteroids,
      shipHP: this._agentHP,
      targetHP: this._opponentHP,
      tick: this._tick,
    };
  }
}

// ===== game-log.js =====
/**
 * Create a fresh game log with all counters at zero.
 */
function createGameLog() {
  return { wins: 0, losses: 0, draws: 0 };
}

/**
 * Record a match result. Only terminal phases update counters.
 */
function recordResult(log, phase) {
  if (phase === 'playerWin') log.wins++;
  else if (phase === 'playerDead') log.losses++;
  else if (phase === 'draw') log.draws++;
}

/**
 * Reset all counters to zero.
 */
function resetGameLog(log) {
  log.wins = 0;
  log.losses = 0;
  log.draws = 0;
}

/**
 * Format the game log as a compact stats string.
 * Returns e.g. "W:5 (50.0%)  L:3 (30.0%)  D:2 (20.0%)  N=10"
 */
function formatGameLog(log) {
  const total = log.wins + log.losses + log.draws;
  const rate = (count) =>
    total === 0 ? '0.0%' : `${((100 * count) / total).toFixed(1)}%`;
  return (
    `W:${log.wins} (${rate(log.wins)})  ` +
    `L:${log.losses} (${rate(log.losses)})  ` +
    `D:${log.draws} (${rate(log.draws)})  ` +
    `N=${total}`
  );
}

// ===== game.js =====

/** Duration of the explosion effect in seconds. */
const EXPLOSION_DURATION = 1.0;

/** Maximum radius the explosion circle expands to (pixels). */
const EXPLOSION_MAX_RADIUS = 60;

/**
 * Check if a ship overlaps any asteroid (circle-circle using collisionRadius).
 * Returns the first overlapping asteroid, or null if none overlap.
 */
function checkShipAsteroidCollision(ship, asteroids) {
  for (const asteroid of asteroids) {
    const dx = ship.x - asteroid.x;
    const dy = ship.y - asteroid.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < ship.collisionRadius + asteroid.collisionRadius) {
      return asteroid;
    }
  }
  return null;
}

/**
 * Check if a bullet is within a ship's collision radius.
 * Returns true when distance(bullet, ship) < ship.collisionRadius.
 */
function checkBulletShipHit(bullet, ship) {
  const dx = bullet.x - ship.x;
  const dy = bullet.y - ship.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  return dist < ship.collisionRadius;
}

/**
 * Process bullet-ship collisions for both ships.
 * Player bullets can only hit the enemy; enemy bullets can only hit the player.
 * Dead ships cannot be hit.
 *
 * Returns { bullets, playerHit, enemyHit } — surviving bullets and hit flags.
 * Does NOT mutate ships (caller handles death).
 */
function processBulletShipCollisions(bullets, playerShip, enemyShip) {
  let playerHit = false;
  let enemyHit = false;

  const surviving = bullets.filter((bullet) => {
    if (bullet.owner === 'player' && enemyShip.alive) {
      if (checkBulletShipHit(bullet, enemyShip)) {
        enemyHit = true;
        return false;
      }
    }
    if (bullet.owner === 'enemy' && playerShip.alive) {
      if (checkBulletShipHit(bullet, playerShip)) {
        playerHit = true;
        return false;
      }
    }
    return true;
  });

  return { bullets: surviving, playerHit, enemyHit };
}

/**
 * Create an explosion effect at the given world position.
 * @param {number} x
 * @param {number} y
 * @param {{ r: number, g: number, b: number }} color - RGB color for the rings
 */
function createExplosion(x, y, color = { r: 255, g: 255, b: 255 }) {
  return { x, y, age: 0, color };
}

/**
 * Advance explosion age by dt.
 */
function updateExplosion(explosion, dt) {
  explosion.age += dt;
}

/**
 * Returns true when the explosion has completed its animation.
 */
function isExplosionDone(explosion) {
  return explosion.age >= EXPLOSION_DURATION;
}

/** Inner circle radius ratio relative to the outer circle. */
const EXPLOSION_INNER_RATIO = 0.5;

/**
 * Draw two expanding concentric wireframe circles that fade out over lifetime.
 * The inner circle is smaller and slightly brighter, creating depth.
 */
function drawExplosion(ctx, explosion) {
  const progress = explosion.age / EXPLOSION_DURATION;
  const outerRadius = progress * EXPLOSION_MAX_RADIUS;
  const innerRadius = outerRadius * EXPLOSION_INNER_RATIO;
  const alpha = 1.0 - progress;

  const { r, g, b } = explosion.color;

  ctx.save();

  // Outer circle
  ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(explosion.x, explosion.y, outerRadius, 0, Math.PI * 2);
  ctx.stroke();

  // Inner circle — slightly brighter
  ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${Math.min(alpha * 1.4, 1.0)})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(explosion.x, explosion.y, innerRadius, 0, Math.PI * 2);
  ctx.stroke();

  ctx.restore();
}

/** Seconds after first death before the final result is shown (matches explosion duration). */
const GRACE_PERIOD = 1;

/**
 * Create the initial game state.
 */
function createGameState() {
  return {
    phase: 'playing',
    explosions: [],
    deathTimer: 0,
  };
}

/**
 * Transition game phase based on ship alive status.
 *
 * 'playing' → first death → 'ending' (grace period, collisions still active)
 * 'ending'  → timer expires → 'playerWin' / 'playerDead' / 'draw'
 * Terminal states are sticky.
 */
function updateGameState(state, playerShip, enemyShip, dt) {
  if (state.phase === 'playing') {
    if (!playerShip.alive || !enemyShip.alive) {
      state.phase = 'ending';
      state.deathTimer = GRACE_PERIOD;
    }
    return;
  }

  if (state.phase === 'ending') {
    state.deathTimer -= dt;
    if (state.deathTimer <= 0) {
      if (!playerShip.alive && !enemyShip.alive) {
        state.phase = 'draw';
      } else if (!playerShip.alive) {
        state.phase = 'playerDead';
      } else {
        state.phase = 'playerWin';
      }
    }
  }
}

/** Safe clearance radius around each ship spawn point (3× ship size = 45). */
const SPAWN_SAFE_RADIUS = 45;

/**
 * Remove asteroids that overlap any ship's spawn zone.
 * Returns a new array — does not mutate the original.
 */
function clearSpawnZone(asteroids, ships) {
  return asteroids.filter((asteroid) => {
    for (const ship of ships) {
      const dx = asteroid.x - ship.x;
      const dy = asteroid.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < SPAWN_SAFE_RADIUS + asteroid.collisionRadius) {
        return false;
      }
    }
    return true;
  });
}

/** Opacity of the dark overlay drawn behind the HUD text. */
const END_SCREEN_OVERLAY_ALPHA = 0.6;

/**
 * Draw a semi-transparent black overlay for the end screen.
 * Fades the background so the HUD text stands out.
 */
function drawEndScreenOverlay(ctx, phase, width, height) {
  if (phase === 'playing' || phase === 'ending') return;

  ctx.save();
  ctx.globalAlpha = END_SCREEN_OVERLAY_ALPHA;
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, width, height);
  ctx.restore();
}

/** Scale for the main HUD text (e.g., "YOU WIN"). */
const HUD_MAIN_SCALE = 8;

/** Scale for the sub-text (e.g., "PRESS ENTER TO RESTART"). */
const HUD_SUB_SCALE = 3;

/** Vertical gap between main text and sub-text (pixels). */
const HUD_TEXT_GAP = 60;

/** Player faction color for HUD text (blue). */
const HUD_PLAYER_COLOR = '#508CFF';

/** Enemy faction color for HUD text (red). */
const HUD_ENEMY_COLOR = '#FF321E';

/** Draw color for draw outcome (white). */
const HUD_DRAW_COLOR = '#FFFFFF';

/**
 * Draw the HUD overlay for terminal phases.
 * Renders "YOU WIN" (blue), "GAME OVER" (red), or "DRAW" (white)
 * with a restart prompt below.
 */
/** Scale for the game log stats line. */
const HUD_LOG_SCALE = 2;

/** Vertical gap between sub-text and game log stats line (pixels). */
const HUD_LOG_GAP = 40;
function drawHUD(ctx, phase, width, height, gameLogText = null) {
  if (phase === 'playing' || phase === 'ending') return;

  const centerX = width / 2;
  const centerY = height / 2 - 30;

  let mainText;
  let mainColor;
  if (phase === 'playerWin') {
    mainText = 'YOU WIN';
    mainColor = HUD_PLAYER_COLOR;
  } else if (phase === 'draw') {
    mainText = 'DRAW';
    mainColor = HUD_DRAW_COLOR;
  } else {
    mainText = 'YOU LOST';
    mainColor = HUD_ENEMY_COLOR;
  }
  drawVectorText(ctx, mainText, centerX, centerY, HUD_MAIN_SCALE, {
    color: mainColor,
  });

  drawVectorText(
    ctx,
    'PRESS SPACE',
    centerX,
    centerY + HUD_TEXT_GAP,
    HUD_SUB_SCALE,
    { alpha: 0.5 },
  );

  if (gameLogText) {
    drawVectorText(
      ctx,
      gameLogText,
      centerX,
      centerY + HUD_TEXT_GAP + HUD_LOG_GAP,
      HUD_LOG_SCALE,
      { alpha: 0.6 },
    );
  }
}

// ===== input.js =====
/**
 * Create a fresh input state with all flags false.
 */
function createInputState() {
  return {
    thrust: false,
    rotateLeft: false,
    rotateRight: false,
    brake: false,
    fire: false,
  };
}

const KEY_MAP = {
  w: 'thrust',
  arrowup: 'thrust',
  a: 'rotateLeft',
  arrowleft: 'rotateLeft',
  d: 'rotateRight',
  arrowright: 'rotateRight',
  s: 'brake',
  arrowdown: 'brake',
  ' ': 'fire',
};

function resolveKey(key) {
  return KEY_MAP[key.toLowerCase()] || null;
}

/**
 * Handle a keydown event — set the corresponding input flag to true.
 */
function handleKeyDown(state, key) {
  const flag = resolveKey(key);
  if (flag) state[flag] = true;
}

/**
 * Handle a keyup event — clear the corresponding input flag.
 */
function handleKeyUp(state, key) {
  const flag = resolveKey(key);
  if (flag) state[flag] = false;
}

/**
 * Returns true if the key is the restart key (Space).
 */
function isRestartKey(key) {
  return key === ' ';
}

/**
 * Copy input flags onto ship control booleans.
 */
function applyInput(inputState, ship) {
  ship.thrust = inputState.thrust;
  ship.rotatingLeft = inputState.rotateLeft;
  ship.rotatingRight = inputState.rotateRight;
  ship.braking = inputState.brake;
  ship.fire = inputState.fire;
}

// ===== main.js =====





/**
 * Calculate delta time in seconds between two timestamps (ms).
 * Caps at 0.1s to avoid spiral-of-death after tab backgrounding.
 * Never returns negative values.
 */
function calculateDeltaTime(currentTimestamp, previousTimestamp) {
  const dtSeconds = (currentTimestamp - previousTimestamp) / 1000;
  return Math.min(Math.max(dtSeconds, 0), 0.1);
}

/**
 * Create an animation loop state object.
 * Call loop.tick(timestamp) each frame from requestAnimationFrame.
 * First tick returns dt=0 (no previous frame to diff against).
 */
function createLoop() {
  let started = false;

  const state = {
    frameCount: 0,
    lastTimestamp: 0,

    tick(timestamp) {
      let dt = 0;
      if (started) {
        dt = calculateDeltaTime(timestamp, state.lastTimestamp);
      }
      started = true;
      state.lastTimestamp = timestamp;
      state.frameCount++;
      return dt;
    },
  };
  return state;
}

/**
 * Bootstrap the application: set up canvas, resize handling, and start the loop.
 */
const BASE_ASTEROID_COUNT = 40;
function startApp() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  let logicalSize = setupHiDPICanvas(
    canvas,
    ctx,
    window.innerWidth,
    window.innerHeight,
    dpr,
  );

  const loop = createLoop();
  let starLayers = createParallaxLayers(logicalSize.width, logicalSize.height);
  const initialBounds = {
    minX: 0,
    maxX: logicalSize.width,
    minY: 0,
    maxY: logicalSize.height,
  };
  const sim = createSimulation(initialBounds);
  let playerShip = createShip({
    x: logicalSize.width / 2,
    y: logicalSize.height / 2,
    heading: -Math.PI / 2,
  });
  const camera = createCamera(
    playerShip.x,
    playerShip.y,
    playerShip.heading + Math.PI / 2,
  );
  let playerTrail = createTrail();
  const enemySpawn = spawnEnemyPosition(playerShip.x, playerShip.y);
  let enemyShip = createShip({
    x: enemySpawn.x,
    y: enemySpawn.y,
    heading: Math.random() * 2 * Math.PI,
    owner: 'enemy',
  });
  let enemyTrail = createTrail(ENEMY_TRAIL_COLOR);
  let bullets = [];
  const gameState = createGameState();
  let prevCameraX = camera.x;
  let prevCameraY = camera.y;
  let prevCameraRotation = camera.rotation;
  const inputState = createInputState();
  const loaded = loadSettings();
  const settings = createSettings(loaded);
  let enemyStrategy = getStrategy(settings.enemyIntelligence);
  let enemyAIState = enemyStrategy.createState();
  let playerStrategy =
    settings.playerIntelligence !== 'human'
      ? getStrategy(settings.playerIntelligence)
      : null;
  let playerAIState = playerStrategy?.createState() ?? null;
  let elapsedTime = 0;
  const gameLog = createGameLog();
  let gameLogRecorded = false;
  const debugLogger = createDebugLogger();
  if (settings.aiDebugLog) debugLogger.enable();
  // Expose on window for console access
  if (typeof window !== 'undefined') {
    window.aiDebug = {
      enable: () => {
        debugLogger.enable();
        settings.aiDebugLog = true;
      },
      disable: () => {
        debugLogger.disable();
        settings.aiDebugLog = false;
      },
    };
  }

  // Settings UI
  const ui = createSettingsUI(document.body, settings);
  // Apply loaded settings to simulation, ships, and starfield
  sim.targetCount = Math.round(BASE_ASTEROID_COUNT * settings.asteroidDensity);
  playerShip.thrustPower = settings.thrustPower;
  enemyShip.thrustPower = settings.thrustPower;
  if (settings.starLayers !== 3) {
    starLayers = createParallaxLayers(
      logicalSize.width,
      logicalSize.height,
      settings.starLayers,
    );
  }
  if (settings.starDirection !== 'left') {
    redistributeStars(
      starLayers,
      logicalSize.width,
      logicalSize.height,
      settings.starDirection,
    );
  }

  ui.onChange = (name, value) => {
    settings[name] = value;
    if (name === 'starLayers') {
      starLayers = createParallaxLayers(
        logicalSize.width,
        logicalSize.height,
        value,
      );
    }
    if (name === 'thrustPower') {
      playerShip.thrustPower = value;
      enemyShip.thrustPower = value;
    }
    if (name === 'starDirection') {
      redistributeStars(
        starLayers,
        logicalSize.width,
        logicalSize.height,
        value,
      );
    }
    if (name === 'enemyIntelligence') {
      enemyStrategy = getStrategy(value);
      enemyAIState = enemyStrategy.createState();
    }
    if (name === 'playerIntelligence') {
      if (value === 'human') {
        playerStrategy = null;
        playerAIState = null;
      } else {
        playerStrategy = getStrategy(value);
        playerAIState = playerStrategy.createState();
      }
    }
    if (name === 'aiDebugLog') {
      if (value) {
        debugLogger.enable();
      } else {
        debugLogger.disable();
      }
    }
    if (name === 'gameLog' && !value) {
      resetGameLog(gameLog);
    }
    saveSettings(settings);
  };

  // Resize: update canvas with HiDPI and redistribute stars
  window.addEventListener('resize', () => {
    logicalSize = setupHiDPICanvas(
      canvas,
      ctx,
      window.innerWidth,
      window.innerHeight,
      dpr,
    );
    redistributeStars(
      starLayers,
      logicalSize.width,
      logicalSize.height,
      settings.starDirection,
    );
  });

  // Auto-hide: reset gear timer on any mouse movement
  window.addEventListener('mousemove', () => {
    settings.gearTimer = 0;
    if (settings.panelOpen) {
      settings.panelTimer = 0;
    }
  });

  // Keyboard input for ship controls and restart
  window.addEventListener('keydown', (e) => {
    const terminal =
      gameState.phase === 'playerWin' ||
      gameState.phase === 'playerDead' ||
      gameState.phase === 'draw';
    if (isRestartKey(e.key) && terminal) {
      restartGame();
      return;
    }
    handleKeyDown(inputState, e.key);
  });
  window.addEventListener('keyup', (e) => handleKeyUp(inputState, e.key));

  function restartGame() {
    playerShip = createShip({
      x: logicalSize.width / 2,
      y: logicalSize.height / 2,
      heading: -Math.PI / 2,
    });
    playerShip.thrustPower = settings.thrustPower;

    const spawn = spawnEnemyPosition(playerShip.x, playerShip.y);
    enemyShip = createShip({
      x: spawn.x,
      y: spawn.y,
      heading: Math.random() * 2 * Math.PI,
      owner: 'enemy',
    });
    enemyShip.thrustPower = settings.thrustPower;

    bullets = [];
    playerTrail = createTrail();
    enemyTrail = createTrail(ENEMY_TRAIL_COLOR);

    sim.asteroids = clearSpawnZone(sim.asteroids, [playerShip, enemyShip]);

    gameState.phase = 'playing';
    gameState.explosions = [];
    gameState.deathTimer = 0;
    gameState.resultTimer = 0;
    gameLogRecorded = false;

    enemyStrategy = getStrategy(settings.enemyIntelligence);
    enemyAIState = enemyStrategy.createState();
    if (settings.playerIntelligence !== 'human') {
      playerStrategy = getStrategy(settings.playerIntelligence);
      playerAIState = playerStrategy.createState();
    } else {
      playerStrategy = null;
      playerAIState = null;
    }

    camera.x = playerShip.x;
    camera.y = playerShip.y;
    camera.rotation = playerShip.heading + Math.PI / 2;
    prevCameraX = camera.x;
    prevCameraY = camera.y;
    prevCameraRotation = camera.rotation;
  }

  function frame(timestamp) {
    const dt = loop.tick(timestamp);
    elapsedTime += dt;

    // Apply speed multiplier to simulation dt
    const scaledDt = dt * settings.speedMultiplier;

    updateAutoHide(settings, dt);

    // When panel is open, button acts as close icon — always fully visible
    if (settings.panelOpen) {
      ui.gearButton.style.opacity = '0.8';
      ui.gearButton.style.pointerEvents = 'auto';
    } else {
      ui.gearButton.style.opacity = settings.gearVisible
        ? settings.gearHovered
          ? '0.8'
          : '0.3'
        : '0';
      ui.gearButton.style.pointerEvents = settings.gearVisible
        ? 'auto'
        : 'none';
    }
    ui.panel.style.display = settings.panelOpen ? 'block' : 'none';
    ui.gearButton.textContent = settings.panelOpen ? '\u2715' : '\u2630';

    // Player input: keyboard or AI (frozen in terminal phases)
    const active =
      gameState.phase === 'playing' || gameState.phase === 'ending';
    if (playerShip.alive && active) {
      if (playerStrategy) {
        playerStrategy.update(
          playerAIState,
          playerShip,
          enemyShip,
          sim.asteroids,
          scaledDt,
        );
      } else {
        applyInput(inputState, playerShip);
      }
      updateShip(playerShip, scaledDt);
    }

    // Enemy always AI (frozen in terminal phases)
    if (enemyShip.alive && active) {
      enemyStrategy.update(
        enemyAIState,
        enemyShip,
        playerShip,
        sim.asteroids,
        scaledDt,
      );
      updateShip(enemyShip, scaledDt);
    }

    // AI debug logging
    debugLogger.logAIFrame(
      elapsedTime,
      enemyShip,
      playerShip,
      getLastDebugInfo(),
    );

    // Bullet firing — player
    playerShip.fireCooldown = Math.max(playerShip.fireCooldown - scaledDt, 0);
    if (playerShip.fire && playerShip.fireCooldown <= 0 && playerShip.alive) {
      const noseX = playerShip.x + Math.cos(playerShip.heading) * SHIP_SIZE;
      const noseY = playerShip.y + Math.sin(playerShip.heading) * SHIP_SIZE;
      bullets.push(
        createBullet(
          noseX,
          noseY,
          playerShip.heading,
          playerShip.vx,
          playerShip.vy,
          'player',
        ),
      );
      playerShip.fireCooldown = FIRE_COOLDOWN;
      const pdx = enemyShip.x - playerShip.x;
      const pdy = enemyShip.y - playerShip.y;
      debugLogger.logEvent(elapsedTime, 'FIRE', {
        owner: 'player',
        dist: Math.round(Math.sqrt(pdx * pdx + pdy * pdy)),
        angle: Math.abs(Math.atan2(pdy, pdx) - playerShip.heading).toFixed(2),
      });
    }

    // Bullet firing — enemy (AI)
    enemyShip.fireCooldown = Math.max(enemyShip.fireCooldown - scaledDt, 0);
    if (enemyShip.fire && enemyShip.fireCooldown <= 0 && enemyShip.alive) {
      const noseX = enemyShip.x + Math.cos(enemyShip.heading) * SHIP_SIZE;
      const noseY = enemyShip.y + Math.sin(enemyShip.heading) * SHIP_SIZE;
      bullets.push(
        createBullet(
          noseX,
          noseY,
          enemyShip.heading,
          enemyShip.vx,
          enemyShip.vy,
          'enemy',
        ),
      );
      enemyShip.fireCooldown = FIRE_COOLDOWN;
      const edx = playerShip.x - enemyShip.x;
      const edy = playerShip.y - enemyShip.y;
      debugLogger.logEvent(elapsedTime, 'FIRE', {
        owner: 'enemy',
        dist: Math.round(Math.sqrt(edx * edx + edy * edy)),
        angle: Math.abs(Math.atan2(edy, edx) - enemyShip.heading).toFixed(2),
      });
    }

    if (playerShip.alive) {
      updateTrail(
        playerTrail,
        playerShip.x,
        playerShip.y,
        playerShip.heading,
        playerShip.thrustIntensity,
      );
    } else {
      drainTrail(playerTrail, scaledDt);
    }
    if (enemyShip.alive) {
      updateTrail(
        enemyTrail,
        enemyShip.x,
        enemyShip.y,
        enemyShip.heading,
        enemyShip.thrustIntensity,
      );
    } else {
      drainTrail(enemyTrail, scaledDt);
    }

    // Camera follows ship (PI/2 offset so ship nose points UP on screen)
    camera.x = playerShip.x;
    camera.y = playerShip.y;
    camera.rotation = playerShip.heading + Math.PI / 2;

    // Compute camera deltas and rotate to screen space for starfield parallax
    const cameraDeltaX = camera.x - prevCameraX;
    const cameraDeltaY = camera.y - prevCameraY;
    // Normalize rotation delta to [-PI, PI] so heading wrapping doesn't
    // produce a ±2PI spike that snaps stars across the screen
    let cameraDeltaRotation = camera.rotation - prevCameraRotation;
    while (cameraDeltaRotation > Math.PI) cameraDeltaRotation -= 2 * Math.PI;
    while (cameraDeltaRotation < -Math.PI) cameraDeltaRotation += 2 * Math.PI;
    const cosR = Math.cos(-camera.rotation);
    const sinR = Math.sin(-camera.rotation);
    const screenDx = cameraDeltaX * cosR - cameraDeltaY * sinR;
    const screenDy = cameraDeltaX * sinR + cameraDeltaY * cosR;

    updateStarLayersCamera(
      starLayers,
      screenDx,
      screenDy,
      cameraDeltaRotation,
      logicalSize.width,
      logicalSize.height,
    );

    prevCameraX = camera.x;
    prevCameraY = camera.y;
    prevCameraRotation = camera.rotation;
    // Tight viewport bounds (no margin — simulation handles its own zones)
    const viewportBounds = getViewportBounds(
      camera,
      logicalSize.width,
      logicalSize.height,
    );
    // Target count must match training env (game-env.js): base × density, no zone scaling
    sim.targetCount = Math.round(
      BASE_ASTEROID_COUNT * settings.asteroidDensity,
    );
    while (sim.asteroids.length > sim.targetCount) {
      sim.asteroids.pop();
    }
    updateSimulation(
      sim,
      scaledDt,
      viewportBounds,
      playerShip.vx,
      playerShip.vy,
    );

    // Bullet update, expiry, and asteroid collisions
    for (const bullet of bullets) {
      updateBullet(bullet, scaledDt);
    }
    bullets = bullets.filter((b) => !isBulletExpired(b));
    bullets = checkBulletAsteroidCollisions(bullets, sim.asteroids);

    // Bullet-ship collisions (active during playing and ending grace period)
    if (gameState.phase === 'playing' || gameState.phase === 'ending') {
      const collisionResult = processBulletShipCollisions(
        bullets,
        playerShip,
        enemyShip,
      );
      bullets = collisionResult.bullets;
      if (collisionResult.playerHit) {
        playerShip.alive = false;
        gameState.explosions.push(
          createExplosion(playerShip.x, playerShip.y, PLAYER_TRAIL_COLOR),
        );
      }
      if (collisionResult.enemyHit) {
        enemyShip.alive = false;
        gameState.explosions.push(
          createExplosion(enemyShip.x, enemyShip.y, ENEMY_TRAIL_COLOR),
        );
      }

      // Ship-asteroid collisions
      if (
        playerShip.alive &&
        checkShipAsteroidCollision(playerShip, sim.asteroids)
      ) {
        playerShip.alive = false;
        gameState.explosions.push(
          createExplosion(playerShip.x, playerShip.y, PLAYER_TRAIL_COLOR),
        );
      }
      if (
        enemyShip.alive &&
        checkShipAsteroidCollision(enemyShip, sim.asteroids)
      ) {
        enemyShip.alive = false;
        gameState.explosions.push(
          createExplosion(enemyShip.x, enemyShip.y, ENEMY_TRAIL_COLOR),
        );
      }

      updateGameState(gameState, playerShip, enemyShip, scaledDt);
    }

    // Update explosions
    for (const explosion of gameState.explosions) {
      updateExplosion(explosion, scaledDt);
    }
    gameState.explosions = gameState.explosions.filter(
      (e) => !isExplosionDone(e),
    );

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, logicalSize.width, logicalSize.height);

    drawParallaxLayers(ctx, starLayers, elapsedTime);

    applyCameraTransform(ctx, camera, logicalSize.width, logicalSize.height);

    for (const asteroid of sim.asteroids) {
      drawAsteroid(ctx, asteroid);
    }

    if (settings.showDangerZones) {
      ctx.globalCompositeOperation = 'lighter';
      for (const asteroid of sim.asteroids) {
        const dr =
          NEAR_MISS_RADIUS_FACTOR * asteroid.collisionRadius +
          DANGER_RADIUS_BASE;
        const grad = ctx.createRadialGradient(
          asteroid.x,
          asteroid.y,
          asteroid.collisionRadius,
          asteroid.x,
          asteroid.y,
          dr,
        );
        grad.addColorStop(0, 'rgba(255, 0, 0, 0.25)');
        grad.addColorStop(1, 'rgba(255, 0, 0, 0.0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(asteroid.x, asteroid.y, dr, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalCompositeOperation = 'source-over';
    }

    if (gameState.phase === 'playing' || gameState.phase === 'ending') {
      drawTrail(ctx, enemyTrail);
      drawShip(ctx, enemyShip);
      drawTrail(ctx, playerTrail);
      drawShip(ctx, playerShip);

      for (const bullet of bullets) {
        drawBullet(ctx, bullet);
      }
    }

    for (const explosion of gameState.explosions) {
      drawExplosion(ctx, explosion);
    }

    resetCameraTransform(ctx);

    drawEndScreenOverlay(
      ctx,
      gameState.phase,
      logicalSize.width,
      logicalSize.height,
    );
    // Record game result for the log (once per match)
    const terminalPhase =
      gameState.phase === 'playerWin' ||
      gameState.phase === 'playerDead' ||
      gameState.phase === 'draw';
    if (terminalPhase && settings.gameLog && !gameLogRecorded) {
      recordResult(gameLog, gameState.phase);
      gameLogRecorded = true;
      console.log('[Game Log]', formatGameLog(gameLog));
    }

    const gameLogText =
      terminalPhase && settings.gameLog ? formatGameLog(gameLog) : null;
    drawHUD(
      ctx,
      gameState.phase,
      logicalSize.width,
      logicalSize.height,
      gameLogText,
    );

    // Auto-restart in AI-vs-AI mode after showing result for 2 seconds
    if (terminalPhase && settings.playerIntelligence !== 'human') {
      gameState.resultTimer = (gameState.resultTimer || 0) + dt;
      if (gameState.resultTimer >= 2) {
        restartGame();
      }
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

// ===== observation.js =====


/** Number of floats in the observation vector. */
const OBSERVATION_SIZE = 36;

/** Number of nearest-asteroid observation slots. */
const MAX_ASTEROID_OBS = 8;

/** Maximum distance (px) for asteroid inclusion. */
const MAX_ASTEROID_DISTANCE = 1000;

/** Normalization divisor for asteroid approach speed. */
const APPROACH_SPEED_NORM = 200;

/** Normalization divisor for distance features. */
const DISTANCE_NORM = 1000;

function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

function clamp(val, min, max) {
  return val < min ? min : val > max ? max : val;
}

/**
 * Build an ego-centric normalized observation vector from game state.
 * Pure function — no mutation of inputs, no side effects.
 *
 * @param {Object} ship - the controlled ship
 * @param {Object} target - the opponent ship
 * @param {Array} asteroids - array of asteroid objects
 * @param {number} [k=MAX_ASTEROID_OBS] - number of asteroid slots
 * @returns {Float32Array} observation vector of length OBSERVATION_SIZE
 */
function buildObservation(
  ship,
  target,
  asteroids,
  k = MAX_ASTEROID_OBS,
) {
  const obs = new Float32Array(OBSERVATION_SIZE);

  // --- Self state (indices 0–5) ---
  const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  obs[0] = clamp(speed / MAX_SPEED, 0, 1);

  if (speed > 0) {
    const velAngle = Math.atan2(ship.vy, ship.vx);
    obs[1] = clamp(normalizeAngle(velAngle - ship.heading) / Math.PI, -1, 1);
  }
  // else obs[1] = 0 (already zero from Float32Array init)

  obs[2] = clamp(ship.thrustIntensity, 0, 1);

  obs[3] = ship.rotatingLeft ? -1 : ship.rotatingRight ? 1 : 0;

  obs[4] = ship.alive ? 1 : 0;

  obs[5] = clamp((ship.fireCooldown || 0) / FIRE_COOLDOWN, 0, 1);

  // --- Target state (indices 6–11) ---
  const tdx = target.x - ship.x;
  const tdy = target.y - ship.y;
  const tDist = Math.sqrt(tdx * tdx + tdy * tdy);

  obs[6] = clamp(tDist / DISTANCE_NORM, 0, 1);

  if (tDist > 0) {
    const absAngle = Math.atan2(tdy, tdx);
    obs[7] = clamp(normalizeAngle(absAngle - ship.heading) / Math.PI, -1, 1);

    // Closing speed: projection of relative velocity onto line-of-sight
    const ux = tdx / tDist;
    const uy = tdy / tDist;
    const rvx = ship.vx - target.vx;
    const rvy = ship.vy - target.vy;
    obs[9] = clamp((rvx * ux + rvy * uy) / MAX_SPEED, -1, 1);

    // Lateral speed: projection onto perpendicular of line-of-sight
    const px = -uy;
    const py = ux;
    obs[10] = clamp((rvx * px + rvy * py) / MAX_SPEED, -1, 1);
  }
  // else indices 7, 9, 10 stay 0

  obs[8] = clamp(
    normalizeAngle(target.heading - ship.heading) / Math.PI,
    -1,
    1,
  );

  obs[11] = target.alive ? 1 : 0;

  // --- Asteroid observations (indices 12–35) ---
  // Compute distances and filter within range
  const nearby = [];
  for (let i = 0; i < asteroids.length; i++) {
    const a = asteroids[i];
    const adx = a.x - ship.x;
    const ady = a.y - ship.y;
    const aDist = Math.sqrt(adx * adx + ady * ady);
    if (aDist <= MAX_ASTEROID_DISTANCE) {
      nearby.push({ asteroid: a, dist: aDist, dx: adx, dy: ady });
    }
  }

  // Sort by distance (nearest first)
  nearby.sort((a, b) => a.dist - b.dist);

  // Fill k slots
  const count = Math.min(nearby.length, k);
  for (let i = 0; i < count; i++) {
    const { asteroid: a, dist: aDist, dx: adx, dy: ady } = nearby[i];
    const base = 12 + i * 3;

    obs[base] = clamp(aDist / DISTANCE_NORM, 0, 1);

    if (aDist > 0) {
      const aAngle = Math.atan2(ady, adx);
      obs[base + 1] = clamp(
        normalizeAngle(aAngle - ship.heading) / Math.PI,
        -1,
        1,
      );

      // Approach speed: relative velocity projected toward asteroid
      const aux = adx / aDist;
      const auy = ady / aDist;
      const arvx = ship.vx - a.vx;
      const arvy = ship.vy - a.vy;
      obs[base + 2] = clamp(
        (arvx * aux + arvy * auy) / APPROACH_SPEED_NORM,
        -1,
        1,
      );
    }
    // else bearing and approach speed stay 0
  }
  // Remaining slots stay 0 from Float32Array init

  return obs;
}

// ===== physics.js =====
/**
 * Detect all colliding asteroid pairs using circle-circle collision.
 * Returns an array of [asteroidA, asteroidB] pairs.
 * A collision occurs when distance between centers < sum of collision radii.
 * Exactly touching (distance === sum) is NOT a collision.
 */
function detectCollisions(asteroids) {
  const pairs = [];
  for (let i = 0; i < asteroids.length; i++) {
    for (let j = i + 1; j < asteroids.length; j++) {
      const a = asteroids[i];
      const b = asteroids[j];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const radiiSum = a.collisionRadius + b.collisionRadius;
      if (dist < radiiSum) {
        pairs.push([a, b]);
      }
    }
  }
  return pairs;
}

/**
 * Separate two overlapping asteroids along the collision normal.
 * Lighter asteroid (smaller collisionRadius²) is pushed proportionally more.
 */
function separateOverlap(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist === 0) {
    // Perfectly coincident — push apart along arbitrary axis
    b.x += a.collisionRadius + b.collisionRadius;
    return;
  }

  const overlap = a.collisionRadius + b.collisionRadius - dist;
  if (overlap <= 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const massA = a.collisionRadius * a.collisionRadius;
  const massB = b.collisionRadius * b.collisionRadius;
  const totalMass = massA + massB;

  // Lighter asteroid moves more
  const pushA = overlap * (massB / totalMass);
  const pushB = overlap * (massA / totalMass);

  a.x -= nx * pushA;
  a.y -= ny * pushA;
  b.x += nx * pushB;
  b.y += ny * pushB;
}

/**
 * Resolve an elastic collision between two asteroids.
 * Uses 2D elastic collision formula with mass = collisionRadius².
 * Applies ±1% random perturbation and angular velocity nudge.
 */
function resolveCollision(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist === 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const massA = a.collisionRadius * a.collisionRadius;
  const massB = b.collisionRadius * b.collisionRadius;

  // Relative velocity along collision normal
  const dvx = a.vx - b.vx;
  const dvy = a.vy - b.vy;
  const dvDotN = dvx * nx + dvy * ny;

  // Don't resolve if asteroids are moving apart
  if (dvDotN <= 0) return;

  const totalMass = massA + massB;

  // 2D elastic collision impulse with ±1% perturbation on magnitude.
  // Using a single factor for both asteroids preserves momentum exactly
  // while adding enough variation to prevent repeating collision patterns.
  // Kept at ±1% to maintain KE conservation within 5%.
  const perturbation = 1 + (Math.random() * 0.02 - 0.01);
  const impulseA = ((2 * massB) / totalMass) * dvDotN * perturbation;
  const impulseB = ((2 * massA) / totalMass) * dvDotN * perturbation;

  a.vx -= impulseA * nx;
  a.vy -= impulseA * ny;
  b.vx += impulseB * nx;
  b.vy += impulseB * ny;

  // Nudge angular velocity slightly on impact
  const angularNudge = () => Math.random() * 0.2 - 0.1;
  a.angularVelocity += angularNudge();
  b.angularVelocity += angularNudge();
}

// ===== renderer.js =====
/**
 * Set up a canvas for HiDPI rendering.
 * Sets internal resolution to CSS size × dpr, applies CSS size,
 * and scales the context so all drawing uses CSS (logical) coordinates.
 * Returns the logical size { width, height } for use by game systems.
 */
function setupHiDPICanvas(canvas, ctx, cssWidth, cssHeight, dpr) {
  canvas.width = cssWidth * dpr;
  canvas.height = cssHeight * dpr;
  canvas.style.width = `${cssWidth}px`;
  canvas.style.height = `${cssHeight}px`;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { width: cssWidth, height: cssHeight };
}

// ===== reward.js =====
/** Default reward weights matching SPEC §16.7. */
const DEFAULT_REWARD_WEIGHTS = {
  survival: 0.001,
  aim: 0.01,
  closing: 0.01,
  hit: 1.0,
  gotHit: -1.0,
  nearMiss: -0.1,
  firePenalty: -0.002,
  win: 5.0,
  loss: -5.0,
  draw: -2.0,
  timeout: -1.0,
  engagePenalty: 0.0,
};

/** Distance threshold (px) for aim alignment reward. */
const AIM_DISTANCE_THRESHOLD = 600;

/** Normalization divisor for closing distance. */
const CLOSING_DISTANCE_NORM = 1000;

/** Distance (px) below which no engage penalty applies (dogfighting zone). */
const ENGAGE_DISTANCE = 400;

/** Normalization divisor for engage penalty distance. */
const ENGAGE_DISTANCE_NORM = 1000;

/** Multiplier on asteroid collisionRadius for near-miss danger zone. */
const NEAR_MISS_RADIUS_FACTOR = 3;

/** Base radius (px) added to every danger zone for a practical minimum buffer. */
const DANGER_RADIUS_BASE = 40;

function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Compute a scalar reward from two consecutive game states.
 * Pure function — no mutation, no side effects.
 *
 * @param {Object} prevState  - { ship, target, asteroids, shipHP, targetHP, tick }
 * @param {Object} currentState - same shape as prevState
 * @param {Object} action - { moveAction, fireAction }
 * @param {Object} config - { rewardWeights?, maxTicks, shipHP }
 * @returns {number} scalar reward (0.0 if agent is dead)
 */
function computeReward(prevState, currentState, action, config) {
  // No posthumous rewards
  if (!currentState.ship.alive) {
    return 0.0;
  }

  const w = { ...DEFAULT_REWARD_WEIGHTS, ...(config.rewardWeights || {}) };
  let reward = 0.0;

  // 1. Survival
  reward += w.survival;

  // 2. Aim alignment
  const ship = currentState.ship;
  const target = currentState.target;
  const dx = target.x - ship.x;
  const dy = target.y - ship.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist < AIM_DISTANCE_THRESHOLD && dist > 0) {
    const angleToTarget = Math.atan2(dy, dx);
    const bearing = normalizeAngle(angleToTarget - ship.heading);
    reward += w.aim * Math.cos(bearing);
  }

  // 3. Closing distance
  const prevShip = prevState.ship;
  const prevTarget = prevState.target;
  const prevDx = prevTarget.x - prevShip.x;
  const prevDy = prevTarget.y - prevShip.y;
  const prevDist = Math.sqrt(prevDx * prevDx + prevDy * prevDy);
  const distanceDelta = prevDist - dist;

  if (distanceDelta > 0) {
    reward += (w.closing * distanceDelta) / CLOSING_DISTANCE_NORM;
  }

  // 4. Hit landed
  if (currentState.targetHP < prevState.targetHP) {
    reward += w.hit;
  }

  // 5. Got hit
  if (currentState.shipHP < prevState.shipHP) {
    reward += w.gotHit;
  }

  // 6. Near-miss
  const asteroids = currentState.asteroids;
  for (let i = 0; i < asteroids.length; i++) {
    const a = asteroids[i];
    const adx = a.x - ship.x;
    const ady = a.y - ship.y;
    const aDist = Math.sqrt(adx * adx + ady * ady);
    const dangerRadius =
      NEAR_MISS_RADIUS_FACTOR * a.collisionRadius + DANGER_RADIUS_BASE;

    if (aDist < dangerRadius) {
      const ratio = 1 - aDist / dangerRadius;
      reward += w.nearMiss * ratio * ratio;
    }
  }

  // 7. Fire discipline
  if (action.fireAction === 1) {
    reward += w.firePenalty;
  }

  // 8. Engage penalty — continuous cost for staying far from the enemy
  if (w.engagePenalty !== 0 && dist > ENGAGE_DISTANCE) {
    reward +=
      (w.engagePenalty * (dist - ENGAGE_DISTANCE)) / ENGAGE_DISTANCE_NORM;
  }

  // 9. Win (terminal)
  if (currentState.targetHP <= 0) {
    reward += w.win;
  }

  // 10. Loss (terminal) — agent is alive (checked above), but shipHP may indicate loss
  if (currentState.shipHP <= 0) {
    reward += w.loss;
  }

  // 11. Draw (terminal) — both HP <= 0
  if (currentState.shipHP <= 0 && currentState.targetHP <= 0) {
    reward += w.draw;
  }

  // 12. Timeout (terminal)
  if (currentState.tick >= config.maxTicks) {
    reward += w.timeout;
  }

  return reward;
}

// ===== settings.js =====
/**
 * Configuration for each setting: range, step, default, and display label.
 */
const SETTINGS_CONFIG = {
  asteroidDensity: {
    min: 0.0,
    max: 3.0,
    step: 0.1,
    default: 1.0,
    label: 'Density',
  },
  speedMultiplier: {
    min: 0.2,
    max: 3.0,
    step: 0.1,
    default: 1.0,
    label: 'Speed',
  },
  starLayers: { min: 3, max: 6, step: 1, default: 3, label: 'Star Layers' },
  thrustPower: {
    min: 1000,
    max: 100000,
    step: 50,
    default: 2000,
    label: 'Thrust',
  },
  starDirection: {
    options: ['left', 'right', 'up', 'down', 'radial'],
    default: 'left',
    label: 'Direction',
  },
  playerIntelligence: {
    options: [
      'human',
      'reactive',
      'predictive',
      'predictive-optimized',
      'neural',
    ],
    default: 'human',
    label: 'Player',
  },
  enemyIntelligence: {
    options: ['reactive', 'predictive', 'predictive-optimized', 'neural'],
    default: 'predictive',
    label: 'Enemy AI',
  },
  aiDebugLog: {
    type: 'boolean',
    default: false,
    label: 'AI Debug Log',
  },
  showDangerZones: {
    type: 'boolean',
    default: false,
    label: 'Danger Zones',
  },
  gameLog: {
    type: 'boolean',
    default: false,
    label: 'Game Log',
  },
};

const STORAGE_KEY = 'asteroidSettings';

/**
 * Create settings state with defaults, optionally applying overrides.
 */
function createSettings(overrides = {}) {
  return {
    asteroidDensity:
      overrides.asteroidDensity ?? SETTINGS_CONFIG.asteroidDensity.default,
    speedMultiplier:
      overrides.speedMultiplier ?? SETTINGS_CONFIG.speedMultiplier.default,
    starLayers: overrides.starLayers ?? SETTINGS_CONFIG.starLayers.default,
    thrustPower: overrides.thrustPower ?? SETTINGS_CONFIG.thrustPower.default,
    starDirection:
      overrides.starDirection ?? SETTINGS_CONFIG.starDirection.default,
    playerIntelligence:
      overrides.playerIntelligence ??
      SETTINGS_CONFIG.playerIntelligence.default,
    enemyIntelligence:
      overrides.enemyIntelligence ?? SETTINGS_CONFIG.enemyIntelligence.default,
    aiDebugLog: overrides.aiDebugLog ?? SETTINGS_CONFIG.aiDebugLog.default,
    showDangerZones:
      overrides.showDangerZones ?? SETTINGS_CONFIG.showDangerZones.default,
    gameLog: overrides.gameLog ?? SETTINGS_CONFIG.gameLog.default,
    panelOpen: false,
    gearVisible: true,
    gearHovered: false,
    gearTimer: 0,
    panelTimer: 0,
  };
}

/**
 * Save tunable settings to localStorage.
 */
function saveSettings(settings) {
  const data = {
    asteroidDensity: settings.asteroidDensity,
    speedMultiplier: settings.speedMultiplier,
    starLayers: settings.starLayers,
    thrustPower: settings.thrustPower,
    starDirection: settings.starDirection,
    playerIntelligence: settings.playerIntelligence,
    enemyIntelligence: settings.enemyIntelligence,
    aiDebugLog: settings.aiDebugLog,
    showDangerZones: settings.showDangerZones,
    gameLog: settings.gameLog,
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

/**
 * Load settings from localStorage. Returns an object with tunable values.
 * Falls back to defaults if storage is empty, corrupt, or contains invalid values.
 */
function loadSettings() {
  const defaults = {
    asteroidDensity: SETTINGS_CONFIG.asteroidDensity.default,
    speedMultiplier: SETTINGS_CONFIG.speedMultiplier.default,
    starLayers: SETTINGS_CONFIG.starLayers.default,
    thrustPower: SETTINGS_CONFIG.thrustPower.default,
    starDirection: SETTINGS_CONFIG.starDirection.default,
    playerIntelligence: SETTINGS_CONFIG.playerIntelligence.default,
    enemyIntelligence: SETTINGS_CONFIG.enemyIntelligence.default,
    aiDebugLog: SETTINGS_CONFIG.aiDebugLog.default,
    showDangerZones: SETTINGS_CONFIG.showDangerZones.default,
    gameLog: SETTINGS_CONFIG.gameLog.default,
  };

  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw === null) return defaults;

    const parsed = JSON.parse(raw);
    if (
      typeof parsed !== 'object' ||
      parsed === null ||
      Array.isArray(parsed)
    ) {
      return defaults;
    }

    // Backward compat: migrate old aiStrategy → enemyIntelligence
    if (parsed.aiStrategy && parsed.enemyIntelligence === undefined) {
      parsed.enemyIntelligence = parsed.aiStrategy;
    }

    const result = {};
    for (const name of Object.keys(defaults)) {
      const config = SETTINGS_CONFIG[name];
      const val = parsed[name];

      if (config.type === 'boolean') {
        // Boolean setting (e.g. aiDebugLog)
        result[name] = typeof val === 'boolean' ? val : defaults[name];
      } else if (config.options) {
        // String enum setting (e.g. starDirection)
        result[name] = config.options.includes(val) ? val : defaults[name];
      } else if (typeof val === 'number' && !Number.isNaN(val)) {
        result[name] = clampSetting(name, val);
      } else {
        result[name] = defaults[name];
      }
    }
    return result;
  } catch {
    return defaults;
  }
}

/**
 * Clamp a setting value to its valid range.
 * Integer settings (step=1) are rounded to the nearest integer.
 */
function clampSetting(name, value) {
  const config = SETTINGS_CONFIG[name];
  let v = Number(value);
  if (config.step >= 1) v = Math.round(v);
  return Math.min(config.max, Math.max(config.min, v));
}

/**
 * Update auto-hide timers. Call each frame with dt.
 * - Gear hides after 3s of no mouse movement (caller resets gearTimer to 0 on mouse move)
 * - Panel closes after 4s of no mouse activity over it (caller resets panelTimer to 0)
 */
function updateAutoHide(settings, dt) {
  settings.gearTimer += dt;
  if (settings.gearTimer < 3) {
    settings.gearVisible = true;
  } else {
    settings.gearVisible = false;
  }

  if (settings.panelOpen) {
    settings.panelTimer += dt;
    if (settings.panelTimer >= 4) {
      settings.panelOpen = false;
    }
  }
}

/**
 * Format a setting value for display.
 */
function formatValue(name, value) {
  if (name === 'speedMultiplier' || name === 'asteroidDensity')
    return `${value.toFixed(1)}x`;
  return String(value);
}

/**
 * Create the settings UI: gear button, panel with sliders.
 * Returns { gearButton, panel, sliders, valueDisplays, onChange }.
 */
function createSettingsUI(container, settings) {
  // Hamburger menu button
  const gearButton = document.createElement('button');
  gearButton.textContent = '\u2630';
  gearButton.style.cssText =
    'position:fixed;top:20px;left:20px;background:none;border:none;' +
    'color:#fff;font-size:28px;cursor:pointer;opacity:0.3;z-index:1001;' +
    'padding:8px;line-height:1;transition:opacity 0.2s;';
  gearButton.addEventListener('mouseenter', () => {
    settings.gearHovered = true;
    gearButton.style.opacity = '0.8';
  });
  gearButton.addEventListener('mouseleave', () => {
    settings.gearHovered = false;
    gearButton.style.opacity = '0.3';
  });
  container.appendChild(gearButton);

  // Panel
  const panel = document.createElement('div');
  panel.style.cssText =
    'position:fixed;top:0;left:0;width:260px;height:100%;' +
    'background:rgba(0,0,0,0.85);color:#fff;font-family:"Courier New",monospace;' +
    'font-size:14px;padding:70px 20px 24px;box-sizing:border-box;z-index:1000;' +
    'display:none;';
  container.appendChild(panel);

  const title = document.createElement('div');
  title.textContent = 'Settings';
  title.style.cssText = 'font-size:18px;margin-bottom:24px;';
  panel.appendChild(title);

  let _onChange = () => {};

  const sliders = {};
  const valueDisplays = {};

  const selects = {};
  const checkboxes = {};

  for (const [name, config] of Object.entries(SETTINGS_CONFIG)) {
    if (config.type === 'boolean') {
      // Boolean setting — render as a checkbox
      const row = document.createElement('div');
      row.style.cssText = 'margin-bottom:20px;';

      const label = document.createElement('label');
      label.style.cssText = 'display:flex;align-items:center;cursor:pointer;';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = settings[name];
      checkbox.style.cssText = 'margin-right:8px;';
      checkboxes[name] = checkbox;

      checkbox.addEventListener('change', () => {
        _onChange(name, checkbox.checked);
      });

      const labelText = document.createElement('span');
      labelText.textContent = config.label;

      label.appendChild(checkbox);
      label.appendChild(labelText);
      row.appendChild(label);
      panel.appendChild(row);
      continue;
    }

    if (config.options) {
      // Enum setting — render as a <select> dropdown
      const row = document.createElement('div');
      row.style.cssText = 'margin-bottom:20px;';

      const label = document.createElement('label');
      label.style.cssText = 'display:block;margin-bottom:6px;';
      label.textContent = config.label;

      const select = document.createElement('select');
      select.style.cssText =
        'width:100%;background:#222;color:#fff;border:1px solid #555;' +
        'padding:4px;font-family:"Courier New",monospace;font-size:14px;';
      for (const opt of config.options) {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        select.appendChild(option);
      }
      select.value = settings[name];
      selects[name] = select;

      select.addEventListener('change', () => {
        _onChange(name, select.value);
      });

      row.appendChild(label);
      row.appendChild(select);
      panel.appendChild(row);
      continue;
    }

    // Numeric setting — render as a slider
    const row = document.createElement('div');
    row.style.cssText = 'margin-bottom:20px;';

    const label = document.createElement('label');
    label.style.cssText = 'display:block;margin-bottom:6px;';

    const labelText = document.createElement('span');
    labelText.textContent = config.label;

    const valueSpan = document.createElement('span');
    valueSpan.textContent = formatValue(name, settings[name]);
    valueSpan.style.cssText = 'float:right;';
    valueDisplays[name] = valueSpan;

    label.appendChild(labelText);
    label.appendChild(valueSpan);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = String(config.min);
    slider.max = String(config.max);
    slider.step = String(config.step);
    slider.value = String(settings[name]);
    slider.style.cssText = 'width:100%;';
    sliders[name] = slider;

    slider.addEventListener('input', () => {
      const val = clampSetting(name, slider.value);
      valueSpan.textContent = formatValue(name, val);
      _onChange(name, val);
    });

    row.appendChild(label);
    row.appendChild(slider);
    panel.appendChild(row);
  }

  // Button click toggles panel; swap icon between ☰ and ✕
  gearButton.addEventListener('click', () => {
    settings.panelOpen = !settings.panelOpen;
    settings.panelTimer = 0;
    panel.style.display = settings.panelOpen ? 'block' : 'none';
    gearButton.textContent = settings.panelOpen ? '\u2715' : '\u2630';
  });

  // Escape closes panel
  const onKeydown = (e) => {
    if (e.key === 'Escape') {
      settings.panelOpen = false;
      panel.style.display = 'none';
      gearButton.textContent = '\u2630';
    }
  };
  document.addEventListener('keydown', onKeydown);

  return {
    gearButton,
    panel,
    sliders,
    valueDisplays,
    selects,
    checkboxes,
    directionSelect: selects.starDirection,
    set onChange(fn) {
      _onChange = fn;
    },
    get onChange() {
      return _onChange;
    },
    destroy() {
      document.removeEventListener('keydown', onKeydown);
    },
  };
}

// ===== ship.js =====
/**
 * Ship size constant (half-height of the chevron shape).
 * Used for rendering and later for collision radius.
 */
const SHIP_SIZE = 15;

/** Rotation speed in radians per second. */
const ROTATION_SPEED = 4.0;

/** Thrust acceleration in pixels/s². */
const THRUST_POWER = 2000;

/** Drag coefficient per second (mild friction). */
const DRAG = 0.5;

/** Braking deceleration in pixels/s². */
const BRAKE_POWER = 800;

/** Maximum ship speed in pixels/s. */
const MAX_SPEED = 400;

/** Maximum number of trail points (~4 seconds at 60 fps). */
const TRAIL_MAX_LENGTH = 240;

/** Opacity of the newest coasting trail segment. */
const TRAIL_BASE_OPACITY = 0.2;

/** Opacity of the newest thrust trail segment. */
const TRAIL_THRUST_OPACITY = 0.6;

/** Line width for coasting trail segments. */
const TRAIL_BASE_WIDTH = 1;

/** Line width for thrust trail segments. */
const TRAIL_THRUST_WIDTH = 2.5;

/** Engine spool rate — thrust intensity ramp speed (per second). Full transition ~0.17s. */
const THRUST_RAMP_SPEED = 6.0;

/** Blue exhaust color (Rebel / player). */
const PLAYER_TRAIL_COLOR = { r: 80, g: 140, b: 255 };

/** Red exhaust color (Empire / enemy). */
const ENEMY_TRAIL_COLOR = { r: 255, g: 50, b: 30 };

/** Dark red ship stroke for enemy. */
const ENEMY_SHIP_COLOR = '#CC3333';

/**
 * Normalize an angle to the range [-PI, PI].
 */
function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create a ship entity.
 */
function createShip({ x, y, heading, owner = 'player' }) {
  return {
    x,
    y,
    vx: 0,
    vy: 0,
    heading,
    alive: true,
    thrust: false,
    rotatingLeft: false,
    rotatingRight: false,
    braking: false,
    fire: false,
    thrustIntensity: 0,
    fireCooldown: 0,
    collisionRadius: SHIP_SIZE,
    owner,
  };
}

/**
 * Update ship state for one frame.
 * Applies rotation, thrust, braking, drag, speed cap, and position update.
 */
function updateShip(ship, dt) {
  // 1. Rotation
  if (ship.rotatingLeft) ship.heading -= ROTATION_SPEED * dt;
  if (ship.rotatingRight) ship.heading += ROTATION_SPEED * dt;
  ship.heading = normalizeAngle(ship.heading);

  // 2. Thrust intensity ramp
  if (ship.thrust) {
    ship.thrustIntensity = Math.min(
      ship.thrustIntensity + THRUST_RAMP_SPEED * dt,
      1.0,
    );
  } else {
    ship.thrustIntensity = Math.max(
      ship.thrustIntensity - THRUST_RAMP_SPEED * dt,
      0.0,
    );
  }

  // 3. Thrust — accelerate in heading direction, scaled by intensity
  if (ship.thrustIntensity > 0) {
    const power = ship.thrustPower ?? THRUST_POWER;
    ship.vx += Math.cos(ship.heading) * power * ship.thrustIntensity * dt;
    ship.vy += Math.sin(ship.heading) * power * ship.thrustIntensity * dt;
  }

  // 4. Braking — decelerate opposite to velocity direction
  if (ship.braking) {
    const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
    if (speed > 0) {
      const decel = Math.min(BRAKE_POWER * dt, speed);
      ship.vx -= (ship.vx / speed) * decel;
      ship.vy -= (ship.vy / speed) * decel;
    }
  }

  // 5. Drag — friction always applied
  ship.vx *= 1 - DRAG * dt;
  ship.vy *= 1 - DRAG * dt;

  // 6. Speed cap
  const currentSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  if (currentSpeed > MAX_SPEED) {
    ship.vx = (ship.vx / currentSpeed) * MAX_SPEED;
    ship.vy = (ship.vy / currentSpeed) * MAX_SPEED;
  }

  // 7. Position update
  ship.x += ship.vx * dt;
  ship.y += ship.vy * dt;
}

/**
 * Draw a classic Asteroids chevron/triangle at the ship's position,
 * rotated by its heading. White wireframe, no fill.
 */
function drawShip(ctx, ship) {
  if (!ship.alive) return;

  const s = SHIP_SIZE;

  ctx.save();
  ctx.translate(ship.x, ship.y);
  ctx.rotate(ship.heading);

  ctx.strokeStyle = ship.owner === 'enemy' ? ENEMY_SHIP_COLOR : '#FFFFFF';
  ctx.lineWidth = 1.5;

  if (ship.owner === 'enemy') {
    ctx.setLineDash([4, 4]);
  }

  // Chevron shape: nose at right (+x), two rear points, notch in back
  ctx.beginPath();
  ctx.moveTo(s, 0); // nose
  ctx.lineTo(-s, -s * 0.7); // top-left wing
  ctx.lineTo(-s * 0.5, 0); // rear notch
  ctx.lineTo(-s, s * 0.7); // bottom-left wing
  ctx.closePath();
  ctx.stroke();

  if (ship.owner === 'enemy') {
    ctx.setLineDash([]);
  }

  ctx.restore();
}

/**
 * Create a new motion trail with the given exhaust color.
 */
function createTrail(color = PLAYER_TRAIL_COLOR) {
  return { points: [], color };
}

/**
 * Record the ship's rear-nozzle position in the trail.
 * Always records a point. Stores the passed thrustIntensity per-point
 * for gradient rendering. Evicts oldest when full.
 */
function updateTrail(trail, x, y, heading, thrustIntensity) {
  const nozzleOffset = SHIP_SIZE * 0.5;
  const rearX = x - Math.cos(heading) * nozzleOffset;
  const rearY = y - Math.sin(heading) * nozzleOffset;
  trail.points.push({ x: rearX, y: rearY, intensity: thrustIntensity });
  if (trail.points.length > TRAIL_MAX_LENGTH) {
    trail.points.shift();
  }
}

/** Number of trail points to drain per second after ship death. */
const TRAIL_DRAIN_RATE = 400;

/**
 * Gradually drain the trail after the ship dies.
 * Removes points from the oldest end so the trail shrinks toward the ship.
 */
function drainTrail(trail, dt) {
  const pointsToDrain = Math.ceil(TRAIL_DRAIN_RATE * dt);
  trail.points.splice(0, Math.min(pointsToDrain, trail.points.length));
}

/**
 * Draw the exhaust trail as fading line segments.
 * Width and opacity are interpolated per-segment using the stored
 * thrust intensity (0=coasting, 1=full thrust) for smooth gradients.
 * Alpha increases linearly from 0 (oldest) to max opacity (newest).
 */
function drawTrail(ctx, trail) {
  if (trail.points.length < 2) return;

  const { r, g, b } = trail.color;
  const len = trail.points.length;

  for (let i = 1; i < len; i++) {
    const ageFactor = i / (len - 1);
    const intensity = trail.points[i].intensity;
    const maxAlpha =
      TRAIL_BASE_OPACITY +
      (TRAIL_THRUST_OPACITY - TRAIL_BASE_OPACITY) * intensity;
    const alpha = ageFactor * maxAlpha;
    ctx.lineWidth =
      TRAIL_BASE_WIDTH + (TRAIL_THRUST_WIDTH - TRAIL_BASE_WIDTH) * intensity;
    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
    ctx.beginPath();
    ctx.moveTo(trail.points[i - 1].x, trail.points[i - 1].y);
    ctx.lineTo(trail.points[i].x, trail.points[i].y);
    ctx.stroke();
  }
}

// ===== simulation.js =====

const SPAWN_BORDER = 300; // px, width of border ring
const RECYCLE_MARGIN = 5; // px, hysteresis beyond spawn bounds
const MAX_SPAWN_PER_FRAME = 10; // cap spawns per frame
const BASE_EDGE_WEIGHT = 100; // min weight per edge (prevents starvation)

/**
 * Expand viewport bounds by SPAWN_BORDER on each side to get spawn bounds.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @returns {object} - { minX, maxX, minY, maxY }
 */
function computeSpawnBounds(viewportBounds) {
  return {
    minX: viewportBounds.minX - SPAWN_BORDER,
    maxX: viewportBounds.maxX + SPAWN_BORDER,
    minY: viewportBounds.minY - SPAWN_BORDER,
    maxY: viewportBounds.maxY + SPAWN_BORDER,
  };
}

/**
 * Compute direction-biased edge selection weights from ship velocity.
 * Edge outward normals: left=(-1,0), right=(+1,0), top=(0,-1), bottom=(0,+1)
 * weight[edge] = max(dot(shipVelocity, edgeOutward), 0) + BASE_EDGE_WEIGHT
 * Normalized to sum to 1.0.
 * @param {number} shipVx
 * @param {number} shipVy
 * @returns {number[]} - [left, right, top, bottom] weights summing to 1.0
 */
function computeEdgeWeights(shipVx, shipVy) {
  const raw = [
    Math.max(-shipVx, 0) + BASE_EDGE_WEIGHT, // left: outward = (-1, 0)
    Math.max(shipVx, 0) + BASE_EDGE_WEIGHT, // right: outward = (+1, 0)
    Math.max(-shipVy, 0) + BASE_EDGE_WEIGHT, // top: outward = (0, -1)
    Math.max(shipVy, 0) + BASE_EDGE_WEIGHT, // bottom: outward = (0, +1)
  ];
  const total = raw[0] + raw[1] + raw[2] + raw[3];
  return [raw[0] / total, raw[1] / total, raw[2] / total, raw[3] / total];
}

/**
 * Pick an edge using cumulative weighted random selection.
 * @param {number[]} weights - [left, right, top, bottom] summing to 1.0
 * @returns {number} - 0=left, 1=right, 2=top, 3=bottom
 */
function pickWeightedEdge(weights) {
  const r = Math.random();
  let cumulative = 0;
  for (let i = 0; i < 3; i++) {
    cumulative += weights[i];
    if (r < cumulative) return i;
  }
  return 3;
}

/**
 * Pick a random size class with the spec distribution:
 * ~20% large (50–80), ~40% medium (25–49), ~40% small (10–24)
 */
function randomRadius() {
  const roll = Math.random();
  if (roll < 0.2) return 50 + Math.random() * 30;
  if (roll < 0.6) return 25 + Math.random() * 24;
  return 10 + Math.random() * 14;
}

/**
 * Get speed range for a given radius.
 * Large (50–80): 15–30 px/s, Medium (25–49): 30–60 px/s, Small (10–24): 60–120 px/s
 */
function speedForRadius(radius) {
  if (radius >= 50) return 15 + Math.random() * 15;
  if (radius >= 25) return 30 + Math.random() * 30;
  return 60 + Math.random() * 60;
}

/**
 * Check if an asteroid is outside the spawn zone (past spawn bounds + recycle margin).
 * @param {object} asteroid
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @returns {boolean}
 */
function isOutsideZone(asteroid, spawnBounds) {
  const { x, y, radius } = asteroid;
  return (
    x + radius + RECYCLE_MARGIN < spawnBounds.minX ||
    x - radius - RECYCLE_MARGIN > spawnBounds.maxX ||
    y + radius + RECYCLE_MARGIN < spawnBounds.minY ||
    y - radius - RECYCLE_MARGIN > spawnBounds.maxY
  );
}

/**
 * Spawn a new asteroid in the border ring (outside viewport, inside spawn bounds).
 * Uses direction-biased edge selection and aims roughly toward viewport center.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @param {number[]} edgeWeights - [left, right, top, bottom]
 * @param {number} speedMultiplier
 * @returns {object} asteroid
 */
function spawnAsteroidInBorder(
  viewportBounds,
  spawnBounds,
  edgeWeights,
  speedMultiplier = 1.0,
  headless = false,
) {
  const radius = randomRadius();
  const speed = speedForRadius(radius) * speedMultiplier;
  const edge = pickWeightedEdge(edgeWeights);

  const vpCenterX = (viewportBounds.minX + viewportBounds.maxX) / 2;
  const vpCenterY = (viewportBounds.minY + viewportBounds.maxY) / 2;

  let x, y;

  switch (edge) {
    case 0: // left border: between spawnBounds.minX and viewportBounds.minX
      x =
        spawnBounds.minX +
        Math.random() * (viewportBounds.minX - spawnBounds.minX);
      y =
        spawnBounds.minY +
        Math.random() * (spawnBounds.maxY - spawnBounds.minY);
      break;
    case 1: // right border: between viewportBounds.maxX and spawnBounds.maxX
      x =
        viewportBounds.maxX +
        Math.random() * (spawnBounds.maxX - viewportBounds.maxX);
      y =
        spawnBounds.minY +
        Math.random() * (spawnBounds.maxY - spawnBounds.minY);
      break;
    case 2: // top border: between spawnBounds.minY and viewportBounds.minY
      x =
        spawnBounds.minX +
        Math.random() * (spawnBounds.maxX - spawnBounds.minX);
      y =
        spawnBounds.minY +
        Math.random() * (viewportBounds.minY - spawnBounds.minY);
      break;
    default: // bottom border: between viewportBounds.maxY and spawnBounds.maxY
      x =
        spawnBounds.minX +
        Math.random() * (spawnBounds.maxX - spawnBounds.minX);
      y =
        viewportBounds.maxY +
        Math.random() * (spawnBounds.maxY - viewportBounds.maxY);
      break;
  }

  // Aim toward viewport center with ±30° spread
  const baseAngle = Math.atan2(vpCenterY - y, vpCenterX - x);
  const spread = (Math.random() * 2 - 1) * (Math.PI / 6);
  const angle = baseAngle + spread;

  return createAsteroid({
    x,
    y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius,
    headless,
  });
}

/**
 * Spawn a new asteroid at a random position within the full zone (spawn bounds),
 * with a random direction. Used for initial population.
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @param {number} speedMultiplier
 * @param {boolean} headless
 * @returns {object} asteroid
 */
function spawnAsteroidInZone(
  spawnBounds,
  speedMultiplier = 1.0,
  headless = false,
) {
  const radius = randomRadius();
  const speed = speedForRadius(radius) * speedMultiplier;
  const x =
    spawnBounds.minX + Math.random() * (spawnBounds.maxX - spawnBounds.minX);
  const y =
    spawnBounds.minY + Math.random() * (spawnBounds.maxY - spawnBounds.minY);
  const angle = Math.random() * Math.PI * 2;

  return createAsteroid({
    x,
    y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius,
    headless,
  });
}

/**
 * Create the simulation state with an initial population of asteroids.
 * Asteroids are distributed across the entire zone (viewport + border) for
 * immediate visibility and pre-populated border.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {number} targetCount
 */
function createSimulation(
  viewportBounds,
  targetCount = 20,
  headless = false,
) {
  const spawnBounds = computeSpawnBounds(viewportBounds);
  const asteroids = [];
  for (let i = 0; i < targetCount; i++) {
    asteroids.push(spawnAsteroidInZone(spawnBounds, 1.0, headless));
  }

  const baselineKEPerAsteroid = computeTotalKE(asteroids) / asteroids.length;

  return {
    asteroids,
    targetCount,
    baselineKEPerAsteroid,
    headless,
  };
}

/**
 * Update the simulation: move asteroids, resolve collisions, recycle outside zone,
 * spawn in border when below target with direction-biased edge selection.
 * @param {object} sim
 * @param {number} dt
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {number} shipVx - ship x velocity for direction bias
 * @param {number} shipVy - ship y velocity for direction bias
 */
function updateSimulation(
  sim,
  dt,
  viewportBounds,
  shipVx = 0,
  shipVy = 0,
) {
  // Move all asteroids
  for (const a of sim.asteroids) {
    updateAsteroid(a, dt);
  }

  // Detect and resolve collisions
  const pairs = detectCollisions(sim.asteroids);
  for (const [a, b] of pairs) {
    separateOverlap(a, b);
    resolveCollision(a, b);
  }

  // Compute spawn bounds and remove asteroids outside zone
  const spawnBounds = computeSpawnBounds(viewportBounds);
  sim.asteroids = sim.asteroids.filter((a) => !isOutsideZone(a, spawnBounds));

  // Compute energy boost
  const boost = computeSpeedBoost(
    sim.baselineKEPerAsteroid,
    sim.targetCount,
    sim.asteroids,
  );

  // Compute direction-biased edge weights
  const edgeWeights = computeEdgeWeights(shipVx, shipVy);

  // Spawn in border when below target
  const deficit = sim.targetCount - sim.asteroids.length;
  const toSpawn = Math.min(Math.max(deficit, 0), MAX_SPAWN_PER_FRAME);
  for (let i = 0; i < toSpawn; i++) {
    sim.asteroids.push(
      spawnAsteroidInBorder(
        viewportBounds,
        spawnBounds,
        edgeWeights,
        boost,
        sim.headless,
      ),
    );
  }
}

// ===== starfield.js =====
/**
 * Create a single star with random position, size, and brightness.
 */
function createStar(canvasWidth, canvasHeight, options = {}) {
  const minSize = options.minSize ?? 1;
  const maxSize = options.maxSize ?? 2;
  const minBrightness = options.minBrightness ?? 0.3;
  const maxBrightness = options.maxBrightness ?? 1.0;

  const brightness =
    minBrightness + Math.random() * (maxBrightness - minBrightness);

  const star = {
    x: Math.random() * canvasWidth,
    y: Math.random() * canvasHeight,
    size: minSize + Math.random() * (maxSize - minSize),
    brightness,
  };

  if (options.twinkle) {
    star.twinklePhase = Math.random() * Math.PI * 2;
    star.twinkleFreq = 0.3 + Math.random() * 2.7; // 0.3–3.0 Hz
    star.twinkleAmplitude = brightness * (0.1 + Math.random() * 0.2); // 10–30% of base
  }

  return star;
}

/**
 * Create a star layer: a collection of stars that scroll together at a given speed.
 */
function createStarLayer(
  count,
  canvasWidth,
  canvasHeight,
  options = {},
) {
  const stars = [];
  for (let i = 0; i < count; i++) {
    stars.push(createStar(canvasWidth, canvasHeight, options));
  }
  return {
    stars,
    speed: options.speed ?? 10,
  };
}

/**
 * Update a star layer: move all stars leftward by speed * dt.
 * Stars that exit the left edge wrap to the right edge with a new random y.
 */
function updateStarLayer(layer, dt, canvasWidth, canvasHeight) {
  const dx = layer.speed * dt;
  for (const star of layer.stars) {
    star.x -= dx;
    if (star.x < 0) {
      star.x = canvasWidth + star.x;
      star.y = Math.random() * canvasHeight;
    }
  }
}

/**
 * Compute the effective brightness of a star at a given elapsed time.
 * Stars without twinkle properties return their base brightness.
 * Formula: base + amplitude * sin(time * freq * 2π + phase), clamped to [0, 1].
 */
function applyTwinkle(star, elapsedTime) {
  if (star.twinklePhase == null) return star.brightness;
  const value =
    star.brightness +
    star.twinkleAmplitude *
      Math.sin(
        elapsedTime * star.twinkleFreq * Math.PI * 2 + star.twinklePhase,
      );
  return Math.min(1.0, Math.max(0, value));
}

// Layer presets for the default 3-layer parallax (far, mid, near).
// Base star counts are calibrated for 1920×1080; scaled by canvas area ratio.
const LAYER_PRESETS = [
  {
    baseCount: 100,
    minSize: 1,
    maxSize: 1,
    minBrightness: 0.3,
    maxBrightness: 0.5,
    minSpeed: 2,
    maxSpeed: 5,
  },
  {
    baseCount: 60,
    minSize: 1,
    maxSize: 2,
    minBrightness: 0.5,
    maxBrightness: 0.7,
    minSpeed: 8,
    maxSpeed: 15,
  },
  {
    baseCount: 30,
    minSize: 2,
    maxSize: 3,
    minBrightness: 0.7,
    maxBrightness: 1.0,
    minSpeed: 20,
    maxSpeed: 35,
  },
];

/**
 * Linearly interpolate between a and b by factor t (0–1).
 */
function lerp(a, b, t) {
  return a + (b - a) * t;
}

/**
 * Create parallax star layers. Default is 3 (far, mid, near).
 * Extra layers interpolate properties between far and near presets.
 */
function createParallaxLayers(
  canvasWidth,
  canvasHeight,
  layerCount = 3,
) {
  const baseArea = 1920 * 1080;
  const areaRatio = (canvasWidth * canvasHeight) / baseArea;
  const far = LAYER_PRESETS[0];
  const near = LAYER_PRESETS[2];

  const layers = [];
  for (let i = 0; i < layerCount; i++) {
    const t = layerCount === 1 ? 0 : i / (layerCount - 1);

    let preset;
    if (layerCount === 3 && i < 3) {
      preset = LAYER_PRESETS[i];
    } else {
      preset = {
        baseCount: Math.round(lerp(far.baseCount, near.baseCount, t)),
        minSize: lerp(far.minSize, near.minSize, t),
        maxSize: lerp(far.maxSize, near.maxSize, t),
        minBrightness: lerp(far.minBrightness, near.minBrightness, t),
        maxBrightness: lerp(far.maxBrightness, near.maxBrightness, t),
        minSpeed: lerp(far.minSpeed, near.minSpeed, t),
        maxSpeed: lerp(far.maxSpeed, near.maxSpeed, t),
      };
    }

    const count = Math.max(1, Math.round(preset.baseCount * areaRatio));
    // Use midpoint of speed range for interpolated layers to guarantee monotonic ordering;
    // the 3-layer preset path already has non-overlapping ranges so random is fine there.
    const speed =
      layerCount === 3 && i < 3
        ? preset.minSpeed + Math.random() * (preset.maxSpeed - preset.minSpeed)
        : (preset.minSpeed + preset.maxSpeed) / 2;

    const isNearLayer = i === layerCount - 1 && layerCount > 1;

    layers.push(
      createStarLayer(count, canvasWidth, canvasHeight, {
        speed,
        minSize: preset.minSize,
        maxSize: preset.maxSize,
        minBrightness: preset.minBrightness,
        maxBrightness: preset.maxBrightness,
        twinkle: !isNearLayer,
      }),
    );
  }
  return layers;
}

/**
 * Update a star layer with a configurable direction.
 * Directions: 'left', 'right', 'up', 'down', 'radial'.
 */
function updateStarLayerDirectional(
  layer,
  dt,
  canvasWidth,
  canvasHeight,
  direction,
) {
  const baseDelta = layer.speed * dt;
  if (baseDelta === 0) return;

  const cx = canvasWidth / 2;
  const cy = canvasHeight / 2;
  // Reference distance for perspective scaling (half the shorter dimension)
  const refDist = Math.min(canvasWidth, canvasHeight) / 2;

  for (const star of layer.stars) {
    if (direction === 'radial') {
      let dx = star.x - cx;
      let dy = star.y - cy;
      const dist = Math.hypot(dx, dy);

      if (dist < 0.01) {
        // Star at exact center — assign a random angle to push it outward
        const angle = Math.random() * Math.PI * 2;
        dx = Math.cos(angle);
        dy = Math.sin(angle);
      } else {
        dx /= dist;
        dy /= dist;
      }

      // Perspective acceleration: speed scales with distance from center
      const speedFactor = Math.max(dist / refDist, 0.05);
      star.x += dx * baseDelta * speedFactor;
      star.y += dy * baseDelta * speedFactor;

      // Brightness fades in with distance from center
      const newDist = Math.hypot(star.x - cx, star.y - cy);
      star.radialBrightness = Math.min(newDist / refDist, 1.0);

      // Recycle if outside canvas
      if (
        star.x < 0 ||
        star.x > canvasWidth ||
        star.y < 0 ||
        star.y > canvasHeight
      ) {
        const angle = Math.random() * Math.PI * 2;
        const spawnDist = 5 + Math.random() * 25;
        star.x = cx + Math.cos(angle) * spawnDist;
        star.y = cy + Math.sin(angle) * spawnDist;
        star.radialBrightness = spawnDist / refDist;
      }
    } else {
      // Clear radialBrightness when not in radial mode
      delete star.radialBrightness;

      if (direction === 'right') {
        star.x += baseDelta;
        if (star.x > canvasWidth) {
          star.x = star.x - canvasWidth;
          star.y = Math.random() * canvasHeight;
        }
      } else if (direction === 'up') {
        star.y -= baseDelta;
        if (star.y < 0) {
          star.y = canvasHeight + star.y;
          star.x = Math.random() * canvasWidth;
        }
      } else if (direction === 'down') {
        star.y += baseDelta;
        if (star.y > canvasHeight) {
          star.y = star.y - canvasHeight;
          star.x = Math.random() * canvasWidth;
        }
      } else {
        // 'left' (default)
        star.x -= baseDelta;
        if (star.x < 0) {
          star.x = canvasWidth + star.x;
          star.y = Math.random() * canvasHeight;
        }
      }
    }
  }
}

/**
 * Redistribute all stars across layers for a new direction mode.
 * Call when the user switches direction to avoid visual artifacts
 * (e.g. stars clustered at center after leaving radial mode).
 */
function redistributeStars(
  layers,
  canvasWidth,
  canvasHeight,
  direction,
) {
  const cx = canvasWidth / 2;
  const cy = canvasHeight / 2;
  const refDist = Math.min(canvasWidth, canvasHeight) / 2;

  for (const layer of layers) {
    for (const star of layer.stars) {
      if (direction === 'radial') {
        const angle = Math.random() * Math.PI * 2;
        const maxDist = Math.hypot(cx, cy);
        const dist = Math.random() * maxDist;
        star.x = cx + Math.cos(angle) * dist;
        star.y = cy + Math.sin(angle) * dist;
        star.radialBrightness = Math.min(dist / refDist, 1.0);
      } else {
        star.x = Math.random() * canvasWidth;
        star.y = Math.random() * canvasHeight;
        delete star.radialBrightness;
      }
    }
  }
}

/**
 * Parallax scaling factor for camera-relative star movement.
 * Keeps star drift speeds comparable to directional scroll speeds.
 */
const CAMERA_PARALLAX_SCALE = 0.6;

/**
 * Update star layers based on camera movement deltas (screen-space).
 * Stars shift opposite to camera motion with per-layer depth parallax.
 * Camera rotation rotates stars around the screen center.
 *
 * @param {Array} layers - Star layers from createParallaxLayers
 * @param {number} screenDx - Camera delta X in screen space (pre-rotated)
 * @param {number} screenDy - Camera delta Y in screen space (pre-rotated)
 * @param {number} deltaRotation - Camera rotation delta (radians)
 * @param {number} viewportW - Viewport width
 * @param {number} viewportH - Viewport height
 */
function updateStarLayersCamera(
  layers,
  screenDx,
  screenDy,
  deltaRotation,
  viewportW,
  viewportH,
) {
  if (layers.length === 0) return;
  const maxSpeed = Math.max(...layers.map((l) => l.speed));
  if (maxSpeed === 0) return;

  const noMovement = screenDx === 0 && screenDy === 0 && deltaRotation === 0;
  const cx = viewportW / 2;
  const cy = viewportH / 2;

  for (const layer of layers) {
    const depth = (layer.speed / maxSpeed) * CAMERA_PARALLAX_SCALE;

    const shiftX = -screenDx * depth;
    const shiftY = -screenDy * depth;

    const rotAngle = -deltaRotation * depth;
    const cosR = Math.cos(rotAngle);
    const sinR = Math.sin(rotAngle);

    for (const star of layer.stars) {
      delete star.radialBrightness;

      if (noMovement) continue;

      if (rotAngle !== 0) {
        const dx = star.x - cx;
        const dy = star.y - cy;
        star.x = cx + dx * cosR - dy * sinR;
        star.y = cy + dx * sinR + dy * cosR;
      }

      star.x += shiftX;
      star.y += shiftY;

      star.x = ((star.x % viewportW) + viewportW) % viewportW;
      star.y = ((star.y % viewportH) + viewportH) % viewportH;
    }
  }
}

/**
 * Update all parallax layers.
 */
function updateParallaxLayers(layers, dt, canvasWidth, canvasHeight) {
  for (const layer of layers) {
    updateStarLayer(layer, dt, canvasWidth, canvasHeight);
  }
}

/**
 * Draw all parallax layers (far to near, back to front).
 */
function drawParallaxLayers(ctx, layers, elapsedTime = 0) {
  for (const layer of layers) {
    drawStarLayer(ctx, layer, elapsedTime);
  }
}

/**
 * Draw a star layer onto a canvas 2D context.
 */
function drawStarLayer(ctx, layer, elapsedTime = 0) {
  for (const star of layer.stars) {
    let brightness = applyTwinkle(star, elapsedTime);
    if (star.radialBrightness != null) {
      brightness *= star.radialBrightness;
    }
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
    ctx.fillRect(star.x, star.y, star.size, star.size);
  }
}


startApp();
</script>
</body>
</html>
