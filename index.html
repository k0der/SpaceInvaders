<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroid Screensaver </title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
// ===== asteroid.js =====
/**
 * Generate an irregular polygon shape for an asteroid.
 * Returns an array of [x, y] vertex pairs centered at origin.
 * Vertices are ordered by increasing angle (no crossed edges).
 */
function generateShape(radius) {
  const vertexCount = 8 + Math.floor(Math.random() * 7); // 8–14
  const step = (Math.PI * 2) / vertexCount;
  const vertices = [];

  for (let i = 0; i < vertexCount; i++) {
    const angle = -Math.PI + step * i; // start at -PI so angles are monotonically increasing
    const r = radius * (0.6 + Math.random() * 0.4); // 0.6–1.0 of radius
    vertices.push([r * Math.cos(angle), r * Math.sin(angle)]);
  }

  return vertices;
}

/**
 * Determine stroke width from asteroid radius (size class).
 */
function getStrokeWidth(radius) {
  if (radius >= 50) return 2.0;  // large
  if (radius >= 25) return 1.5;  // medium
  return 1.0;                     // small
}

/**
 * Create an asteroid object.
 */
function createAsteroid({ x, y, vx, vy, radius }) {
  // Angular velocity scaled inversely to radius: smaller = faster spin
  const maxAngVel = 0.5 * (20 / Math.max(radius, 10));
  const angularVelocity = (Math.random() * 2 - 1) * Math.min(maxAngVel, 0.5);

  return {
    x,
    y,
    vx,
    vy,
    radius,
    rotation: 0,
    angularVelocity,
    shape: generateShape(radius),
    strokeWidth: getStrokeWidth(radius),
  };
}

/**
 * Update asteroid position and rotation by delta time.
 */
function updateAsteroid(asteroid, dt) {
  asteroid.x += asteroid.vx * dt;
  asteroid.y += asteroid.vy * dt;
  asteroid.rotation += asteroid.angularVelocity * dt;
}

/**
 * Draw an asteroid as a white wireframe polygon on a canvas 2D context.
 */
function drawAsteroid(ctx, asteroid) {
  const { x, y, rotation, shape, strokeWidth } = asteroid;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = strokeWidth;

  ctx.beginPath();
  ctx.moveTo(shape[0][0], shape[0][1]);
  for (let i = 1; i < shape.length; i++) {
    ctx.lineTo(shape[i][0], shape[i][1]);
  }
  ctx.closePath();
  ctx.stroke();

  ctx.restore();
}

// ===== main.js =====



/**
 * Calculate delta time in seconds between two timestamps (ms).
 * Caps at 0.1s to avoid spiral-of-death after tab backgrounding.
 * Never returns negative values.
 */
function calculateDeltaTime(currentTimestamp, previousTimestamp) {
  const dtSeconds = (currentTimestamp - previousTimestamp) / 1000;
  return Math.min(Math.max(dtSeconds, 0), 0.1);
}

/**
 * Create an animation loop state object.
 * Call loop.tick(timestamp) each frame from requestAnimationFrame.
 * First tick returns dt=0 (no previous frame to diff against).
 */
function createLoop() {
  let started = false;

  const state = {
    frameCount: 0,
    lastTimestamp: 0,

    tick(timestamp) {
      let dt = 0;
      if (started) {
        dt = calculateDeltaTime(timestamp, state.lastTimestamp);
      }
      started = true;
      state.lastTimestamp = timestamp;
      state.frameCount++;
      return dt;
    },
  };
  return state;
}

/**
 * Bootstrap the application: set up canvas, resize handling, and start the loop.
 */
function startApp() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  const loop = createLoop();
  const starLayers = createParallaxLayers(canvas.width, canvas.height);
  const sim = createSimulation(canvas.width, canvas.height);
  let elapsedTime = 0;

  function frame(timestamp) {
    const dt = loop.tick(timestamp);
    elapsedTime += dt;

    updateParallaxLayers(starLayers, dt, canvas.width, canvas.height);
    updateSimulation(sim, dt, canvas.width, canvas.height);

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawParallaxLayers(ctx, starLayers, elapsedTime);

    for (const asteroid of sim.asteroids) {
      drawAsteroid(ctx, asteroid);
    }

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

// ===== simulation.js =====

const SPAWN_STAGGER = 0.3; // seconds between spawns
const MARGIN = 5; // px margin beyond radius for off-screen detection

/**
 * Check if an asteroid is fully off-screen (center + radius + margin past all edges).
 */
function isOffScreen(asteroid, canvasWidth, canvasHeight) {
  const { x, y, radius } = asteroid;
  return (
    x + radius + MARGIN < 0 ||
    x - radius - MARGIN > canvasWidth ||
    y + radius + MARGIN < 0 ||
    y - radius - MARGIN > canvasHeight
  );
}

/**
 * Pick a random size class with the spec distribution:
 * ~20% large (50–80), ~40% medium (25–49), ~40% small (10–24)
 */
function randomRadius() {
  const roll = Math.random();
  if (roll < 0.2) {
    // Large: 50–80
    return 50 + Math.random() * 30;
  } else if (roll < 0.6) {
    // Medium: 25–49
    return 25 + Math.random() * 24;
  } else {
    // Small: 10–24
    return 10 + Math.random() * 14;
  }
}

/**
 * Get speed range for a given radius.
 * Large (50–80): 15–30 px/s
 * Medium (25–49): 30–60 px/s
 * Small (10–24): 60–120 px/s
 */
function speedForRadius(radius) {
  if (radius >= 50) return 15 + Math.random() * 15;
  if (radius >= 25) return 30 + Math.random() * 30;
  return 60 + Math.random() * 60;
}

/**
 * Spawn a new asteroid from a random screen edge, aimed roughly inward.
 */
function spawnAsteroidFromEdge(canvasWidth, canvasHeight) {
  const radius = randomRadius();
  const speed = speedForRadius(radius);
  const edge = Math.floor(Math.random() * 4); // 0=left, 1=right, 2=top, 3=bottom

  let x, y, baseAngle;

  switch (edge) {
    case 0: // left
      x = -radius - 1;
      y = Math.random() * canvasHeight;
      baseAngle = 0; // aiming right
      break;
    case 1: // right
      x = canvasWidth + radius + 1;
      y = Math.random() * canvasHeight;
      baseAngle = Math.PI; // aiming left
      break;
    case 2: // top
      x = Math.random() * canvasWidth;
      y = -radius - 1;
      baseAngle = Math.PI / 2; // aiming down
      break;
    default: // bottom
      x = Math.random() * canvasWidth;
      y = canvasHeight + radius + 1;
      baseAngle = -Math.PI / 2; // aiming up
      break;
  }

  // Add angular spread of ±30° (±PI/6)
  const spread = (Math.random() * 2 - 1) * (Math.PI / 6);
  const angle = baseAngle + spread;

  return createAsteroid({
    x,
    y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius,
  });
}

/**
 * Create the simulation state with an initial population of asteroids.
 */
function createSimulation(canvasWidth, canvasHeight, targetCount = 20) {
  const asteroids = [];
  for (let i = 0; i < targetCount; i++) {
    asteroids.push(spawnAsteroidFromEdge(canvasWidth, canvasHeight));
  }

  return {
    asteroids,
    targetCount,
    spawnTimer: 0,
  };
}

/**
 * Update the simulation: move asteroids, remove off-screen ones, spawn replacements.
 */
function updateSimulation(sim, dt, canvasWidth, canvasHeight) {
  // Update all asteroids
  for (const a of sim.asteroids) {
    updateAsteroid(a, dt);
  }

  // Remove off-screen asteroids
  sim.asteroids = sim.asteroids.filter(a => !isOffScreen(a, canvasWidth, canvasHeight));

  // Spawn new asteroids if below target (staggered)
  sim.spawnTimer += dt;
  if (sim.asteroids.length < sim.targetCount && sim.spawnTimer >= SPAWN_STAGGER) {
    sim.asteroids.push(spawnAsteroidFromEdge(canvasWidth, canvasHeight));
    sim.spawnTimer = 0;
  }
}

// ===== starfield.js =====
/**
 * Create a single star with random position, size, and brightness.
 */
function createStar(canvasWidth, canvasHeight, options = {}) {
  const minSize = options.minSize ?? 1;
  const maxSize = options.maxSize ?? 2;
  const minBrightness = options.minBrightness ?? 0.3;
  const maxBrightness = options.maxBrightness ?? 1.0;

  const brightness = minBrightness + Math.random() * (maxBrightness - minBrightness);

  const star = {
    x: Math.random() * canvasWidth,
    y: Math.random() * canvasHeight,
    size: minSize + Math.random() * (maxSize - minSize),
    brightness,
  };

  if (options.twinkle) {
    star.twinklePhase = Math.random() * Math.PI * 2;
    star.twinkleFreq = 0.5 + Math.random() * 1.5;           // 0.5–2.0 Hz
    star.twinkleAmplitude = brightness * (0.1 + Math.random() * 0.1); // 10–20% of base
  }

  return star;
}

/**
 * Create a star layer: a collection of stars that scroll together at a given speed.
 */
function createStarLayer(count, canvasWidth, canvasHeight, options = {}) {
  const stars = [];
  for (let i = 0; i < count; i++) {
    stars.push(createStar(canvasWidth, canvasHeight, options));
  }
  return {
    stars,
    speed: options.speed ?? 10,
  };
}

/**
 * Update a star layer: move all stars leftward by speed * dt.
 * Stars that exit the left edge wrap to the right edge with a new random y.
 */
function updateStarLayer(layer, dt, canvasWidth, canvasHeight) {
  const dx = layer.speed * dt;
  for (const star of layer.stars) {
    star.x -= dx;
    if (star.x < 0) {
      star.x = canvasWidth + star.x;
      star.y = Math.random() * canvasHeight;
    }
  }
}

/**
 * Compute the effective brightness of a star at a given elapsed time.
 * Stars without twinkle properties return their base brightness.
 * Formula: base + amplitude * sin(time * freq * 2π + phase), clamped to [0, 1].
 */
function applyTwinkle(star, elapsedTime) {
  if (star.twinklePhase == null) return star.brightness;
  const value = star.brightness + star.twinkleAmplitude * Math.sin(elapsedTime * star.twinkleFreq * Math.PI * 2 + star.twinklePhase);
  return Math.min(1.0, Math.max(0, value));
}

// Layer presets for the default 3-layer parallax (far, mid, near).
// Base star counts are calibrated for 1920×1080; scaled by canvas area ratio.
const LAYER_PRESETS = [
  { baseCount: 100, minSize: 1, maxSize: 1, minBrightness: 0.3, maxBrightness: 0.5, minSpeed: 2, maxSpeed: 5 },
  { baseCount: 60,  minSize: 1, maxSize: 2, minBrightness: 0.5, maxBrightness: 0.7, minSpeed: 8, maxSpeed: 15 },
  { baseCount: 30,  minSize: 2, maxSize: 3, minBrightness: 0.7, maxBrightness: 1.0, minSpeed: 20, maxSpeed: 35 },
];

/**
 * Linearly interpolate between a and b by factor t (0–1).
 */
function lerp(a, b, t) {
  return a + (b - a) * t;
}

/**
 * Create parallax star layers. Default is 3 (far, mid, near).
 * Extra layers interpolate properties between far and near presets.
 */
function createParallaxLayers(canvasWidth, canvasHeight, layerCount = 3) {
  const baseArea = 1920 * 1080;
  const areaRatio = (canvasWidth * canvasHeight) / baseArea;
  const far = LAYER_PRESETS[0];
  const near = LAYER_PRESETS[2];

  const layers = [];
  for (let i = 0; i < layerCount; i++) {
    const t = layerCount === 1 ? 0 : i / (layerCount - 1);

    let preset;
    if (layerCount === 3 && i < 3) {
      preset = LAYER_PRESETS[i];
    } else {
      preset = {
        baseCount: Math.round(lerp(far.baseCount, near.baseCount, t)),
        minSize: lerp(far.minSize, near.minSize, t),
        maxSize: lerp(far.maxSize, near.maxSize, t),
        minBrightness: lerp(far.minBrightness, near.minBrightness, t),
        maxBrightness: lerp(far.maxBrightness, near.maxBrightness, t),
        minSpeed: lerp(far.minSpeed, near.minSpeed, t),
        maxSpeed: lerp(far.maxSpeed, near.maxSpeed, t),
      };
    }

    const count = Math.max(1, Math.round(preset.baseCount * areaRatio));
    // Use midpoint of speed range for interpolated layers to guarantee monotonic ordering;
    // the 3-layer preset path already has non-overlapping ranges so random is fine there.
    const speed = (layerCount === 3 && i < 3)
      ? preset.minSpeed + Math.random() * (preset.maxSpeed - preset.minSpeed)
      : (preset.minSpeed + preset.maxSpeed) / 2;

    const isNearLayer = (i === layerCount - 1) && layerCount > 1;

    layers.push(createStarLayer(count, canvasWidth, canvasHeight, {
      speed,
      minSize: preset.minSize,
      maxSize: preset.maxSize,
      minBrightness: preset.minBrightness,
      maxBrightness: preset.maxBrightness,
      twinkle: !isNearLayer,
    }));
  }
  return layers;
}

/**
 * Update all parallax layers.
 */
function updateParallaxLayers(layers, dt, canvasWidth, canvasHeight) {
  for (const layer of layers) {
    updateStarLayer(layer, dt, canvasWidth, canvasHeight);
  }
}

/**
 * Draw all parallax layers (far to near, back to front).
 */
function drawParallaxLayers(ctx, layers, elapsedTime = 0) {
  for (const layer of layers) {
    drawStarLayer(ctx, layer, elapsedTime);
  }
}

/**
 * Draw a star layer onto a canvas 2D context.
 */
function drawStarLayer(ctx, layer, elapsedTime = 0) {
  for (const star of layer.stars) {
    const brightness = applyTwinkle(star, elapsedTime);
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
    ctx.fillRect(
      Math.round(star.x),
      Math.round(star.y),
      star.size,
      star.size,
    );
  }
}


startApp();
</script>
</body>
</html>
