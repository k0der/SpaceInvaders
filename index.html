<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroid Screensaver </title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
// ===== ai-core.js =====
/**
 * AI Strategy Registry
 *
 * Pluggable AI system — register named strategies and retrieve them at runtime.
 * Each strategy implements { createState(), update(state, ship, target, asteroids, dt) }.
 */

const strategies = new Map();

/**
 * Register a named AI strategy.
 */
function registerStrategy(name, strategy) {
  strategies.set(name, strategy);
}

/**
 * Retrieve a registered strategy by name.
 * Throws if the name is not registered.
 */
function getStrategy(name) {
  const strategy = strategies.get(name);
  if (!strategy) {
    throw new Error(`Unknown AI strategy: "${name}"`);
  }
  return strategy;
}

/**
 * Return the names of all registered strategies.
 */
function listStrategies() {
  return [...strategies.keys()];
}

/**
 * Clear all registered strategies (for testing).
 */
function resetRegistry() {
  strategies.clear();
}

// ===== ai-predictive-optimized.js =====
;(function() {
/**
 * Predictive-Optimized AI — trajectory simulation strategy.
 *
 * Each frame, generates 7 fixed-action candidates plus 2 dynamic pursuit
 * candidates, simulates each forward ~1.5s using real ship physics, scores
 * the outcomes, and picks the best action.
 * Firing is a separate snap decision based on current aim geometry.
 */



/** Angular threshold for AI firing (~8.6°) — duplicated from ai-reactive for decoupling. */
const FIRE_ANGLE = 0.15;

/** Max distance (px) at which AI will fire — duplicated from ai-reactive for decoupling. */
const MAX_FIRE_RANGE = 500;

/** Last debug info captured by selectBestAction. */
let _lastDebugInfo = null;

/**
 * Return the last debug info captured by selectBestAction, or null.
 */
function getLastDebugInfo() {
  return _lastDebugInfo;
}

/** Number of simulation steps per candidate. */
const SIM_STEPS = 15;

/** Time step for each simulation step (seconds). */
const SIM_DT = 0.1;

/** Base penalty for collision — always catastrophic (collision = death). */
const COLLISION_BASE_PENALTY = -20000;

/** Linear tiebreaker: later collisions are slightly less bad (more time to re-evaluate). */
const COLLISION_EARLY_BONUS = 50;

/** Number of brake steps before pursuit in the brake-pursuit candidate. */
const BRAKE_PURSUIT_STEPS = 5;

/** Rotation deadzone for pursuit candidates (rad). */
const PURSUIT_DEADZONE = 0.05;

/** Thrust angle for pursuit candidates (rad) — thrust when facing within this. */
const PURSUIT_THRUST_ANGLE = Math.PI / 3;

/** Speed threshold for pursuit braking. */
const PURSUIT_BRAKE_SPEED = 50;

/** Weight applied to distance-to-target (negative = closer is better). */
const DISTANCE_WEIGHT = -8;

/** Bonus for aiming toward target at closest approach. */
const AIM_BONUS = 400;

/** Weight for closing speed bonus (dot of velocity toward target). */
const CLOSING_SPEED_WEIGHT = 8;

/** Proximity scaling factor for aim bonus — amplifies aim importance at close range. */
const AIM_PROXIMITY_SCALE = 5;

/** Bonus per sim step where ship has a viable firing solution. */
const FIRE_OPPORTUNITY_BONUS = 300;

/** Distance below which current scoring balance applies (close-range combat zone). */
const ENGAGE_RANGE = 350;

/** Minimum time (seconds) to hold an action before reconsidering. */
const HOLD_TIME = 0.15;

/** Simulation steps to check for imminent collision during hold. */
const COLLISION_BREAK_STEPS = 3;

/** Score bonus for matching the previous frame's action (reduces oscillation). */
const HYSTERESIS_BONUS = 250;

/** Danger zone extends to this factor × collision distance. Near-misses within
 *  this zone receive a graduated penalty (quadratic ramp from 0 at edge to
 *  full collision penalty at the collision boundary). */
const DANGER_ZONE_FACTOR = 3;

/** Within ENGAGE_RANGE, closing speed weight scales up linearly from 1× at the
 *  boundary to (1 + ENGAGE_CLOSING_SCALE)× at zero distance. Prevents formation
 *  flight stagnation by making the AI progressively more aggressive about
 *  closing distance as it enters combat range. */
const ENGAGE_CLOSING_SCALE = 3;

/**
 * Clone only the physics-relevant fields of a ship for simulation.
 */
function cloneShipForSim(ship) {
  return {
    x: ship.x,
    y: ship.y,
    vx: ship.vx,
    vy: ship.vy,
    heading: ship.heading,
    thrustIntensity: ship.thrustIntensity,
    thrustPower: ship.thrustPower,
    alive: true,
    thrust: false,
    rotatingLeft: false,
    rotatingRight: false,
    braking: false,
  };
}

/**
 * Linearly extrapolate an asteroid's position at time t.
 * Returns { x, y, radius } for collision checking.
 */
function predictAsteroidAt(asteroid, t) {
  return {
    x: asteroid.x + asteroid.vx * t,
    y: asteroid.y + asteroid.vy * t,
    radius: asteroid.collisionRadius,
  };
}

/**
 * Define the 7 candidate actions for trajectory simulation.
 */
function defineCandidates() {
  return [
    { thrust: true, rotatingLeft: false, rotatingRight: false, braking: false },
    { thrust: true, rotatingLeft: true, rotatingRight: false, braking: false },
    { thrust: true, rotatingLeft: false, rotatingRight: true, braking: false },
    {
      thrust: false,
      rotatingLeft: false,
      rotatingRight: false,
      braking: false,
    },
    { thrust: false, rotatingLeft: true, rotatingRight: false, braking: false },
    { thrust: false, rotatingLeft: false, rotatingRight: true, braking: false },
    { thrust: false, rotatingLeft: false, rotatingRight: false, braking: true },
  ];
}

/**
 * Simulate a ship clone forward for `steps` time steps, applying the given action.
 * Returns an array of positions (length = steps + 1, including the initial position).
 */
function simulateTrajectory(clone, action, steps, dt) {
  const positions = [
    {
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    },
  ];

  clone.thrust = action.thrust;
  clone.rotatingLeft = action.rotatingLeft;
  clone.rotatingRight = action.rotatingRight;
  clone.braking = action.braking;

  for (let i = 0; i < steps; i++) {
    updateShip(clone, dt);
    positions.push({
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    });
  }

  return positions;
}

/**
 * Score a simulated trajectory based on:
 * - Catastrophic collision penalty (first collision only — ship would be dead)
 * - Closest approach to target across trajectory (lower = better)
 * - Average aim bonus across all steps (avoids crossover artifact at overshoot)
 * - Approach rate bonus (net distance closed, immune to overshoot terror)
 * - Fire opportunity bonus for steps with viable firing solutions (proximity-scaled)
 */
function scoreTrajectory(positions, target, asteroids, simDt) {
  let score = 0;

  // Check for first collision only (ship dies on first hit, later ones are moot)
  // Also track worst near-miss within the danger zone for graduated penalty.
  const shipRadius = SHIP_SIZE;
  let collided = false;
  let worstDanger = 0;
  for (let i = 1; i < positions.length && !collided; i++) {
    const t = i * simDt;
    const pos = positions[i];

    for (const ast of asteroids) {
      const predicted = predictAsteroidAt(ast, t);
      const dx = pos.x - predicted.x;
      const dy = pos.y - predicted.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const collisionDist = predicted.radius + shipRadius;

      if (dist < collisionDist) {
        score += COLLISION_BASE_PENALTY + COLLISION_EARLY_BONUS * i;
        collided = true;
        break;
      }

      const dangerZone = DANGER_ZONE_FACTOR * collisionDist;
      if (dist < dangerZone) {
        const proximity = (dangerZone - dist) / (dangerZone - collisionDist);
        worstDanger = Math.max(worstDanger, proximity * proximity);
      }
    }
  }

  if (!collided && worstDanger > 0) {
    score += COLLISION_BASE_PENALTY * worstDanger;
  }

  // Compute initial distance to target (used for approach urgency and closing rate)
  const initDx = positions[0].x - target.x;
  const initDy = positions[0].y - target.y;
  const initialDist = Math.sqrt(initDx * initDx + initDy * initDy);

  // Find the closest approach to the predicted target across the trajectory
  let minDist = Infinity;
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const ddx = positions[i].x - predX;
    const ddy = positions[i].y - predY;
    const d = Math.sqrt(ddx * ddx + ddy * ddy);
    if (d < minDist) {
      minDist = d;
    }
  }

  // Distance-scaled approach urgency: stronger pull to close at long range
  const distanceScale =
    1 + Math.max(0, initialDist - ENGAGE_RANGE) / ENGAGE_RANGE;
  score += DISTANCE_WEIGHT * distanceScale * minDist;

  // Aim bonus: average alignment across all trajectory steps.
  // Averaging avoids the "crossover artifact" where a ship passing through
  // the target gets a negative aim reading at the single crossover point,
  // despite being well-aimed for most of the trajectory.
  let aimSum = 0;
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const angleToTarget = Math.atan2(
      predY - positions[i].y,
      predX - positions[i].x,
    );
    let angleDiff = angleToTarget - positions[i].heading;
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    aimSum += Math.cos(angleDiff);
  }
  const aimProximityFactor =
    1 + AIM_PROXIMITY_SCALE * Math.max(0, 1 - minDist / MAX_FIRE_RANGE);
  score += AIM_BONUS * (aimSum / (positions.length - 1)) * aimProximityFactor;

  // Approach rate: reward net distance closed over the simulation.
  // Uses (initialDist - finalDist) / simTime instead of instantaneous velocity
  // at a single point, avoiding "overshoot terror" where passing through the
  // target produces a massive negative closing speed.
  const lastIdx = positions.length - 1;
  const lastT = lastIdx * simDt;
  const finalTargetX = target.x + target.vx * lastT;
  const finalTargetY = target.y + target.vy * lastT;
  const finDx = positions[lastIdx].x - finalTargetX;
  const finDy = positions[lastIdx].y - finalTargetY;
  const finalDist = Math.sqrt(finDx * finDx + finDy * finDy);

  const simTime = simDt * lastIdx;
  if (simTime > 0) {
    const closingRate = (initialDist - finalDist) / simTime;
    const closingScale =
      initialDist < ENGAGE_RANGE
        ? 1 + ENGAGE_CLOSING_SCALE * (1 - initialDist / ENGAGE_RANGE)
        : 1;
    score += CLOSING_SPEED_WEIGHT * closingScale * closingRate;
  }

  // Fire opportunity bonus: count steps with a viable firing solution
  // (aimed within FIRE_ANGLE and within MAX_FIRE_RANGE of predicted target).
  // Scaled by proximity — closer shots are worth more, breaking orbits
  // while not rewarding standing still at max range.
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const fdx = predX - positions[i].x;
    const fdy = predY - positions[i].y;
    const fDist = Math.sqrt(fdx * fdx + fdy * fdy);
    if (fDist > MAX_FIRE_RANGE) continue;
    const fireAngle = Math.atan2(fdy, fdx);
    let fireDiff = fireAngle - positions[i].heading;
    while (fireDiff > Math.PI) fireDiff -= 2 * Math.PI;
    while (fireDiff < -Math.PI) fireDiff += 2 * Math.PI;
    if (Math.abs(fireDiff) < FIRE_ANGLE) {
      score += FIRE_OPPORTUNITY_BONUS * (1 - fDist / MAX_FIRE_RANGE);
    }
  }

  return score;
}

/**
 * Simulate a dynamic pursuit trajectory where the ship adapts each step:
 * rotate toward the predicted target, thrust when facing it, brake otherwise.
 * Optionally brakes for `brakeSteps` before engaging pursuit.
 *
 * Returns { positions, firstAction } where firstAction is the action at step 0.
 */
function simulatePursuitTrajectory(
  clone,
  target,
  steps,
  dt,
  brakeSteps = 0,
) {
  const positions = [
    {
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    },
  ];
  let firstAction = null;

  for (let i = 0; i < steps; i++) {
    const t = (i + 1) * dt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const dx = predX - clone.x;
    const dy = predY - clone.y;
    const headingDiff = normalizeAngle(Math.atan2(dy, dx) - clone.heading);
    const speed = Math.sqrt(clone.vx * clone.vx + clone.vy * clone.vy);

    if (i < brakeSteps) {
      clone.thrust = false;
      clone.braking = speed > 10;
      clone.rotatingLeft = headingDiff < -PURSUIT_DEADZONE;
      clone.rotatingRight = headingDiff > PURSUIT_DEADZONE;
    } else {
      const facingTarget = Math.abs(headingDiff) < PURSUIT_THRUST_ANGLE;
      clone.thrust = facingTarget;
      clone.braking = !facingTarget && speed > PURSUIT_BRAKE_SPEED;
      clone.rotatingLeft = headingDiff < -PURSUIT_DEADZONE;
      clone.rotatingRight = headingDiff > PURSUIT_DEADZONE;
    }

    if (i === 0) {
      firstAction = {
        thrust: clone.thrust,
        rotatingLeft: clone.rotatingLeft,
        rotatingRight: clone.rotatingRight,
        braking: clone.braking,
      };
    }

    updateShip(clone, dt);
    positions.push({
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    });
  }

  return { positions, firstAction };
}

/**
 * Check if a held action would cause an imminent collision (within a few steps).
 * Used as an emergency escape hatch during action hold periods.
 */
function hasImminentCollision(ship, action, asteroids) {
  const clone = cloneShipForSim(ship);
  const positions = simulateTrajectory(
    clone,
    action,
    COLLISION_BREAK_STEPS,
    SIM_DT,
  );
  const shipRadius = SHIP_SIZE;
  for (let i = 1; i < positions.length; i++) {
    const t = i * SIM_DT;
    for (const ast of asteroids) {
      const predicted = predictAsteroidAt(ast, t);
      const dx = positions[i].x - predicted.x;
      const dy = positions[i].y - predicted.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < predicted.radius + shipRadius) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Check if two action objects have identical control flags.
 */
function actionsMatch(a, b) {
  return (
    a.thrust === b.thrust &&
    a.rotatingLeft === b.rotatingLeft &&
    a.rotatingRight === b.rotatingRight &&
    a.braking === b.braking
  );
}

/**
 * Select the best action by simulating all candidates and picking the highest score.
 * Optional prevAction enables hysteresis — matching candidates get a small bonus
 * to prevent frame-by-frame oscillation between similar-scoring actions.
 */
function selectBestAction(ship, target, asteroids, prevAction = null) {
  const candidates = defineCandidates();
  let bestScore = -Infinity;
  let bestAction = candidates[0];
  let bestName = '';
  const debugCandidates = [];

  // Evaluate fixed-action candidates
  for (const action of candidates) {
    const clone = cloneShipForSim(ship);
    const positions = simulateTrajectory(clone, action, SIM_STEPS, SIM_DT);
    let score = scoreTrajectory(positions, target, asteroids, SIM_DT);
    if (prevAction && actionsMatch(action, prevAction)) {
      score += HYSTERESIS_BONUS;
    }
    const name = fmtAction(action);
    debugCandidates.push({ name, score });

    if (score > bestScore) {
      bestScore = score;
      bestAction = action;
      bestName = name;
    }
  }

  // Evaluate dynamic pursuit candidate (rotate toward target, thrust when facing)
  const pursuitClone = cloneShipForSim(ship);
  const pursuit = simulatePursuitTrajectory(
    pursuitClone,
    target,
    SIM_STEPS,
    SIM_DT,
    0,
  );
  let pursuitScore = scoreTrajectory(
    pursuit.positions,
    target,
    asteroids,
    SIM_DT,
  );
  if (
    prevAction &&
    pursuit.firstAction &&
    actionsMatch(pursuit.firstAction, prevAction)
  ) {
    pursuitScore += HYSTERESIS_BONUS;
  }
  debugCandidates.push({ name: 'PUR', score: pursuitScore });
  if (pursuitScore > bestScore) {
    bestScore = pursuitScore;
    bestAction = pursuit.firstAction;
    bestName = 'PUR';
  }

  // Evaluate brake-pursuit candidate (brake first, then pursue).
  // Only useful when ship has significant velocity — otherwise the brake phase
  // does nothing and the trajectory degenerates into delayed pursuit, producing
  // a misleading firstAction (coast) that the AI would repeat every frame.
  const shipSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  if (shipSpeed > PURSUIT_BRAKE_SPEED) {
    const brakeClone = cloneShipForSim(ship);
    const brakePursuit = simulatePursuitTrajectory(
      brakeClone,
      target,
      SIM_STEPS,
      SIM_DT,
      BRAKE_PURSUIT_STEPS,
    );
    let brakeScore = scoreTrajectory(
      brakePursuit.positions,
      target,
      asteroids,
      SIM_DT,
    );
    if (
      prevAction &&
      brakePursuit.firstAction &&
      actionsMatch(brakePursuit.firstAction, prevAction)
    ) {
      brakeScore += HYSTERESIS_BONUS;
    }
    debugCandidates.push({ name: 'BRK', score: brakeScore });
    if (brakeScore > bestScore) {
      bestScore = brakeScore;
      bestAction = brakePursuit.firstAction;
      bestName = 'BRK';
    }
  }

  _lastDebugInfo = { candidates: debugCandidates, winner: bestName };

  return bestAction;
}

/**
 * Normalize an angle to [-PI, PI].
 */
function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create predictive-optimized AI state.
 */
function createPredictiveOptimizedState() {
  return { prevAction: null, holdTimer: 0 };
}

/**
 * Predictive-optimized AI update function.
 * Holds selected action for HOLD_TIME to prevent oscillation, with an
 * emergency escape if the held action predicts an imminent collision.
 * Firing decision is a separate snap check based on current aim.
 */
function updatePredictiveOptimizedAI(state, ship, target, asteroids, _dt) {
  if (!ship.alive || !target.alive) {
    ship.thrust = false;
    ship.rotatingLeft = false;
    ship.rotatingRight = false;
    ship.braking = false;
    ship.fire = false;
    return;
  }

  state.holdTimer = Math.max(0, state.holdTimer - _dt);

  const holdExpired = state.holdTimer <= 0;
  const emergency =
    !holdExpired &&
    state.prevAction &&
    hasImminentCollision(ship, state.prevAction, asteroids);

  if (holdExpired || emergency || !state.prevAction) {
    const action = selectBestAction(ship, target, asteroids, state.prevAction);
    state.prevAction = action;
    state.holdTimer = HOLD_TIME;
  }

  ship.thrust = state.prevAction.thrust;
  ship.rotatingLeft = state.prevAction.rotatingLeft;
  ship.rotatingRight = state.prevAction.rotatingRight;
  ship.braking = state.prevAction.braking;

  // Fire decision: snap check based on current aim geometry
  const dx = target.x - ship.x;
  const dy = target.y - ship.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angleToTarget = Math.atan2(dy, dx);
  const headingDiff = Math.abs(normalizeAngle(angleToTarget - ship.heading));

  ship.fire = headingDiff < FIRE_ANGLE && dist < MAX_FIRE_RANGE;
}

/**
 * Predictive-optimized AI strategy object — pluggable interface.
 */
const predictiveOptimizedStrategy = {
  createState: createPredictiveOptimizedState,
  update: updatePredictiveOptimizedAI,
};

// Self-register in the strategy registry
registerStrategy('predictive-optimized', predictiveOptimizedStrategy);

})();
// ===== ai-predictive.js =====
/**
 * Predictive AI — trajectory simulation strategy.
 *
 * Each frame, generates 7 fixed-action candidates plus 2 dynamic pursuit
 * candidates, simulates each forward ~1.5s using real ship physics, scores
 * the outcomes, and picks the best action.
 * Firing is a separate snap decision based on current aim geometry.
 */



/** Last debug info captured by selectBestAction. */
let _lastDebugInfo = null;

/**
 * Return the last debug info captured by selectBestAction, or null.
 */
function getLastDebugInfo() {
  return _lastDebugInfo;
}

/** Number of simulation steps per candidate. */
const SIM_STEPS = 15;

/** Time step for each simulation step (seconds). */
const SIM_DT = 0.1;

/** Base penalty for collision — always catastrophic (collision = death). */
const COLLISION_BASE_PENALTY = -20000;

/** Linear tiebreaker: later collisions are slightly less bad (more time to re-evaluate). */
const COLLISION_EARLY_BONUS = 50;

/** Number of brake steps before pursuit in the brake-pursuit candidate. */
const BRAKE_PURSUIT_STEPS = 5;

/** Rotation deadzone for pursuit candidates (rad). */
const PURSUIT_DEADZONE = 0.05;

/** Thrust angle for pursuit candidates (rad) — thrust when facing within this. */
const PURSUIT_THRUST_ANGLE = Math.PI / 3;

/** Speed threshold for pursuit braking. */
const PURSUIT_BRAKE_SPEED = 50;

/** Weight applied to distance-to-target (negative = closer is better). */
const DISTANCE_WEIGHT = -8;

/** Bonus for aiming toward target at closest approach. */
const AIM_BONUS = 400;

/** Weight for closing speed bonus (dot of velocity toward target). */
const CLOSING_SPEED_WEIGHT = 8;

/** Proximity scaling factor for aim bonus — amplifies aim importance at close range. */
const AIM_PROXIMITY_SCALE = 5;

/** Bonus per sim step where ship has a viable firing solution. */
const FIRE_OPPORTUNITY_BONUS = 300;

/** Distance below which current scoring balance applies (close-range combat zone). */
const ENGAGE_RANGE = 350;

/** Minimum time (seconds) to hold an action before reconsidering. */
const HOLD_TIME = 0.15;

/** Simulation steps to check for imminent collision during hold. */
const COLLISION_BREAK_STEPS = 3;

/** Score bonus for matching the previous frame's action (reduces oscillation). */
const HYSTERESIS_BONUS = 250;

/** Danger zone extends to this factor × collision distance. Near-misses within
 *  this zone receive a graduated penalty (quadratic ramp from 0 at edge to
 *  full collision penalty at the collision boundary). */
const DANGER_ZONE_FACTOR = 3;

/** Within ENGAGE_RANGE, closing speed weight scales up linearly from 1× at the
 *  boundary to (1 + ENGAGE_CLOSING_SCALE)× at zero distance. Prevents formation
 *  flight stagnation by making the AI progressively more aggressive about
 *  closing distance as it enters combat range. */
const ENGAGE_CLOSING_SCALE = 3;

/**
 * Clone only the physics-relevant fields of a ship for simulation.
 */
function cloneShipForSim(ship) {
  return {
    x: ship.x,
    y: ship.y,
    vx: ship.vx,
    vy: ship.vy,
    heading: ship.heading,
    thrustIntensity: ship.thrustIntensity,
    thrustPower: ship.thrustPower,
    alive: true,
    thrust: false,
    rotatingLeft: false,
    rotatingRight: false,
    braking: false,
  };
}

/**
 * Linearly extrapolate an asteroid's position at time t.
 * Returns { x, y, radius } for collision checking.
 */
function predictAsteroidAt(asteroid, t) {
  return {
    x: asteroid.x + asteroid.vx * t,
    y: asteroid.y + asteroid.vy * t,
    radius: asteroid.collisionRadius,
  };
}

/**
 * Define the 7 candidate actions for trajectory simulation.
 */
function defineCandidates() {
  return [
    { thrust: true, rotatingLeft: false, rotatingRight: false, braking: false },
    { thrust: true, rotatingLeft: true, rotatingRight: false, braking: false },
    { thrust: true, rotatingLeft: false, rotatingRight: true, braking: false },
    {
      thrust: false,
      rotatingLeft: false,
      rotatingRight: false,
      braking: false,
    },
    { thrust: false, rotatingLeft: true, rotatingRight: false, braking: false },
    { thrust: false, rotatingLeft: false, rotatingRight: true, braking: false },
    { thrust: false, rotatingLeft: false, rotatingRight: false, braking: true },
  ];
}

/**
 * Simulate a ship clone forward for `steps` time steps, applying the given action.
 * Returns an array of positions (length = steps + 1, including the initial position).
 */
function simulateTrajectory(clone, action, steps, dt) {
  const positions = [
    {
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    },
  ];

  clone.thrust = action.thrust;
  clone.rotatingLeft = action.rotatingLeft;
  clone.rotatingRight = action.rotatingRight;
  clone.braking = action.braking;

  for (let i = 0; i < steps; i++) {
    updateShip(clone, dt);
    positions.push({
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    });
  }

  return positions;
}

/**
 * Score a simulated trajectory based on:
 * - Catastrophic collision penalty (first collision only — ship would be dead)
 * - Closest approach to target across trajectory (lower = better)
 * - Average aim bonus across all steps (avoids crossover artifact at overshoot)
 * - Approach rate bonus (net distance closed, immune to overshoot terror)
 * - Fire opportunity bonus for steps with viable firing solutions (proximity-scaled)
 */
function scoreTrajectory(positions, target, asteroids, simDt) {
  let score = 0;

  // Check for first collision only (ship dies on first hit, later ones are moot)
  // Also track worst near-miss within the danger zone for graduated penalty.
  const shipRadius = SHIP_SIZE;
  let collided = false;
  let worstDanger = 0;
  for (let i = 1; i < positions.length && !collided; i++) {
    const t = i * simDt;
    const pos = positions[i];

    for (const ast of asteroids) {
      const predicted = predictAsteroidAt(ast, t);
      const dx = pos.x - predicted.x;
      const dy = pos.y - predicted.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const collisionDist = predicted.radius + shipRadius;

      if (dist < collisionDist) {
        score += COLLISION_BASE_PENALTY + COLLISION_EARLY_BONUS * i;
        collided = true;
        break;
      }

      const dangerZone = DANGER_ZONE_FACTOR * collisionDist;
      if (dist < dangerZone) {
        const proximity = (dangerZone - dist) / (dangerZone - collisionDist);
        worstDanger = Math.max(worstDanger, proximity * proximity);
      }
    }
  }

  if (!collided && worstDanger > 0) {
    score += COLLISION_BASE_PENALTY * worstDanger;
  }

  // Compute initial distance to target (used for approach urgency and closing rate)
  const initDx = positions[0].x - target.x;
  const initDy = positions[0].y - target.y;
  const initialDist = Math.sqrt(initDx * initDx + initDy * initDy);

  // Find the closest approach to the predicted target across the trajectory
  let minDist = Infinity;
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const ddx = positions[i].x - predX;
    const ddy = positions[i].y - predY;
    const d = Math.sqrt(ddx * ddx + ddy * ddy);
    if (d < minDist) {
      minDist = d;
    }
  }

  // Distance-scaled approach urgency: stronger pull to close at long range
  const distanceScale =
    1 + Math.max(0, initialDist - ENGAGE_RANGE) / ENGAGE_RANGE;
  score += DISTANCE_WEIGHT * distanceScale * minDist;

  // Aim bonus: average alignment across all trajectory steps.
  // Averaging avoids the "crossover artifact" where a ship passing through
  // the target gets a negative aim reading at the single crossover point,
  // despite being well-aimed for most of the trajectory.
  let aimSum = 0;
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const angleToTarget = Math.atan2(
      predY - positions[i].y,
      predX - positions[i].x,
    );
    let angleDiff = angleToTarget - positions[i].heading;
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    aimSum += Math.cos(angleDiff);
  }
  const aimProximityFactor =
    1 + AIM_PROXIMITY_SCALE * Math.max(0, 1 - minDist / MAX_FIRE_RANGE);
  score += AIM_BONUS * (aimSum / (positions.length - 1)) * aimProximityFactor;

  // Approach rate: reward net distance closed over the simulation.
  // Uses (initialDist - finalDist) / simTime instead of instantaneous velocity
  // at a single point, avoiding "overshoot terror" where passing through the
  // target produces a massive negative closing speed.
  const lastIdx = positions.length - 1;
  const lastT = lastIdx * simDt;
  const finalTargetX = target.x + target.vx * lastT;
  const finalTargetY = target.y + target.vy * lastT;
  const finDx = positions[lastIdx].x - finalTargetX;
  const finDy = positions[lastIdx].y - finalTargetY;
  const finalDist = Math.sqrt(finDx * finDx + finDy * finDy);

  const simTime = simDt * lastIdx;
  if (simTime > 0) {
    const closingRate = (initialDist - finalDist) / simTime;
    const closingScale =
      initialDist < ENGAGE_RANGE
        ? 1 + ENGAGE_CLOSING_SCALE * (1 - initialDist / ENGAGE_RANGE)
        : 1;
    score += CLOSING_SPEED_WEIGHT * closingScale * closingRate;
  }

  // Fire opportunity bonus: count steps with a viable firing solution
  // (aimed within FIRE_ANGLE and within MAX_FIRE_RANGE of predicted target).
  // Scaled by proximity — closer shots are worth more, breaking orbits
  // while not rewarding standing still at max range.
  for (let i = 1; i < positions.length; i++) {
    const t = i * simDt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const fdx = predX - positions[i].x;
    const fdy = predY - positions[i].y;
    const fDist = Math.sqrt(fdx * fdx + fdy * fdy);
    if (fDist > MAX_FIRE_RANGE) continue;
    const fireAngle = Math.atan2(fdy, fdx);
    let fireDiff = fireAngle - positions[i].heading;
    while (fireDiff > Math.PI) fireDiff -= 2 * Math.PI;
    while (fireDiff < -Math.PI) fireDiff += 2 * Math.PI;
    if (Math.abs(fireDiff) < FIRE_ANGLE) {
      score += FIRE_OPPORTUNITY_BONUS * (1 - fDist / MAX_FIRE_RANGE);
    }
  }

  return score;
}

/**
 * Simulate a dynamic pursuit trajectory where the ship adapts each step:
 * rotate toward the predicted target, thrust when facing it, brake otherwise.
 * Optionally brakes for `brakeSteps` before engaging pursuit.
 *
 * Returns { positions, firstAction } where firstAction is the action at step 0.
 */
function simulatePursuitTrajectory(
  clone,
  target,
  steps,
  dt,
  brakeSteps = 0,
) {
  const positions = [
    {
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    },
  ];
  let firstAction = null;

  for (let i = 0; i < steps; i++) {
    const t = (i + 1) * dt;
    const predX = target.x + target.vx * t;
    const predY = target.y + target.vy * t;
    const dx = predX - clone.x;
    const dy = predY - clone.y;
    const headingDiff = normalizeAngle(Math.atan2(dy, dx) - clone.heading);
    const speed = Math.sqrt(clone.vx * clone.vx + clone.vy * clone.vy);

    if (i < brakeSteps) {
      clone.thrust = false;
      clone.braking = speed > 10;
      clone.rotatingLeft = headingDiff < -PURSUIT_DEADZONE;
      clone.rotatingRight = headingDiff > PURSUIT_DEADZONE;
    } else {
      const facingTarget = Math.abs(headingDiff) < PURSUIT_THRUST_ANGLE;
      clone.thrust = facingTarget;
      clone.braking = !facingTarget && speed > PURSUIT_BRAKE_SPEED;
      clone.rotatingLeft = headingDiff < -PURSUIT_DEADZONE;
      clone.rotatingRight = headingDiff > PURSUIT_DEADZONE;
    }

    if (i === 0) {
      firstAction = {
        thrust: clone.thrust,
        rotatingLeft: clone.rotatingLeft,
        rotatingRight: clone.rotatingRight,
        braking: clone.braking,
      };
    }

    updateShip(clone, dt);
    positions.push({
      x: clone.x,
      y: clone.y,
      heading: clone.heading,
      vx: clone.vx,
      vy: clone.vy,
    });
  }

  return { positions, firstAction };
}

/**
 * Check if a held action would cause an imminent collision (within a few steps).
 * Used as an emergency escape hatch during action hold periods.
 */
function hasImminentCollision(ship, action, asteroids) {
  const clone = cloneShipForSim(ship);
  const positions = simulateTrajectory(
    clone,
    action,
    COLLISION_BREAK_STEPS,
    SIM_DT,
  );
  const shipRadius = SHIP_SIZE;
  for (let i = 1; i < positions.length; i++) {
    const t = i * SIM_DT;
    for (const ast of asteroids) {
      const predicted = predictAsteroidAt(ast, t);
      const dx = positions[i].x - predicted.x;
      const dy = positions[i].y - predicted.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < predicted.radius + shipRadius) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Check if two action objects have identical control flags.
 */
function actionsMatch(a, b) {
  return (
    a.thrust === b.thrust &&
    a.rotatingLeft === b.rotatingLeft &&
    a.rotatingRight === b.rotatingRight &&
    a.braking === b.braking
  );
}

/**
 * Select the best action by simulating all candidates and picking the highest score.
 * Optional prevAction enables hysteresis — matching candidates get a small bonus
 * to prevent frame-by-frame oscillation between similar-scoring actions.
 */
function selectBestAction(ship, target, asteroids, prevAction = null) {
  const candidates = defineCandidates();
  let bestScore = -Infinity;
  let bestAction = candidates[0];
  let bestName = '';
  const debugCandidates = [];

  // Evaluate fixed-action candidates
  for (const action of candidates) {
    const clone = cloneShipForSim(ship);
    const positions = simulateTrajectory(clone, action, SIM_STEPS, SIM_DT);
    let score = scoreTrajectory(positions, target, asteroids, SIM_DT);
    if (prevAction && actionsMatch(action, prevAction)) {
      score += HYSTERESIS_BONUS;
    }
    const name = fmtAction(action);
    debugCandidates.push({ name, score });

    if (score > bestScore) {
      bestScore = score;
      bestAction = action;
      bestName = name;
    }
  }

  // Evaluate dynamic pursuit candidate (rotate toward target, thrust when facing)
  const pursuitClone = cloneShipForSim(ship);
  const pursuit = simulatePursuitTrajectory(
    pursuitClone,
    target,
    SIM_STEPS,
    SIM_DT,
    0,
  );
  let pursuitScore = scoreTrajectory(
    pursuit.positions,
    target,
    asteroids,
    SIM_DT,
  );
  if (
    prevAction &&
    pursuit.firstAction &&
    actionsMatch(pursuit.firstAction, prevAction)
  ) {
    pursuitScore += HYSTERESIS_BONUS;
  }
  debugCandidates.push({ name: 'PUR', score: pursuitScore });
  if (pursuitScore > bestScore) {
    bestScore = pursuitScore;
    bestAction = pursuit.firstAction;
    bestName = 'PUR';
  }

  // Evaluate brake-pursuit candidate (brake first, then pursue).
  // Only useful when ship has significant velocity — otherwise the brake phase
  // does nothing and the trajectory degenerates into delayed pursuit, producing
  // a misleading firstAction (coast) that the AI would repeat every frame.
  const shipSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  if (shipSpeed > PURSUIT_BRAKE_SPEED) {
    const brakeClone = cloneShipForSim(ship);
    const brakePursuit = simulatePursuitTrajectory(
      brakeClone,
      target,
      SIM_STEPS,
      SIM_DT,
      BRAKE_PURSUIT_STEPS,
    );
    let brakeScore = scoreTrajectory(
      brakePursuit.positions,
      target,
      asteroids,
      SIM_DT,
    );
    if (
      prevAction &&
      brakePursuit.firstAction &&
      actionsMatch(brakePursuit.firstAction, prevAction)
    ) {
      brakeScore += HYSTERESIS_BONUS;
    }
    debugCandidates.push({ name: 'BRK', score: brakeScore });
    if (brakeScore > bestScore) {
      bestScore = brakeScore;
      bestAction = brakePursuit.firstAction;
      bestName = 'BRK';
    }
  }

  _lastDebugInfo = { candidates: debugCandidates, winner: bestName };

  return bestAction;
}

/**
 * Normalize an angle to [-PI, PI].
 */
function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create predictive AI state.
 */
function createPredictiveState() {
  return { prevAction: null, holdTimer: 0 };
}

/**
 * Predictive AI update function.
 * Holds selected action for HOLD_TIME to prevent oscillation, with an
 * emergency escape if the held action predicts an imminent collision.
 * Firing decision is a separate snap check based on current aim.
 */
function updatePredictiveAI(state, ship, target, asteroids, _dt) {
  if (!ship.alive || !target.alive) {
    ship.thrust = false;
    ship.rotatingLeft = false;
    ship.rotatingRight = false;
    ship.braking = false;
    ship.fire = false;
    return;
  }

  state.holdTimer = Math.max(0, state.holdTimer - _dt);

  const holdExpired = state.holdTimer <= 0;
  const emergency =
    !holdExpired &&
    state.prevAction &&
    hasImminentCollision(ship, state.prevAction, asteroids);

  if (holdExpired || emergency || !state.prevAction) {
    const action = selectBestAction(ship, target, asteroids, state.prevAction);
    state.prevAction = action;
    state.holdTimer = HOLD_TIME;
  }

  ship.thrust = state.prevAction.thrust;
  ship.rotatingLeft = state.prevAction.rotatingLeft;
  ship.rotatingRight = state.prevAction.rotatingRight;
  ship.braking = state.prevAction.braking;

  // Fire decision: snap check based on current aim geometry
  const dx = target.x - ship.x;
  const dy = target.y - ship.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const angleToTarget = Math.atan2(dy, dx);
  const headingDiff = Math.abs(normalizeAngle(angleToTarget - ship.heading));

  ship.fire = headingDiff < FIRE_ANGLE && dist < MAX_FIRE_RANGE;
}

/**
 * Predictive AI strategy object — pluggable interface.
 */
const predictiveStrategy = {
  createState: createPredictiveState,
  update: updatePredictiveAI,
};

// ===== ai-reactive.js =====

/** Dead zone for rotation — prevents oscillation (~3°). */
const ROTATION_DEADZONE = 0.05;

/** Thrust engages when heading is within this angle of target (~60°). */
const THRUST_ANGLE = Math.PI / 3;

/** Brake threshold — brake when not facing target and speed exceeds this. */
const BRAKE_SPEED = 50;

/** Lead calculation divisor (~MAX_SPEED). */
const PREDICTION_SPEED = 400;

/** Maximum look-ahead time for target prediction (seconds). */
const MAX_PREDICTION_TIME = 2.0;

/** Angular threshold for AI firing (~8.6°). */
const FIRE_ANGLE = 0.15;

/** Max distance (px) at which AI will fire. */
const MAX_FIRE_RANGE = 500;

/** How far ahead (px) the AI scans for obstacles along its predicted path. */
const AVOID_LOOKAHEAD = 800;

/** Buffer (px) around obstacle collision radius for avoidance. */
const AVOID_MARGIN = 50;

/** Maximum steering offset (rad) from avoidance. */
const AVOID_STRENGTH = 2.5;

/** Proximity detection radius (px) — catches obstacles the cylinder misses. */
const AVOID_PROXIMITY = 80;

/** How aggressively avoidance suppresses pursuit (urgency * this >= 1 → pure avoidance). */
const AVOIDANCE_PRIORITY = 2;

/** Time horizon (seconds) for predicting future velocity in avoidance. */
const AVOID_PREDICT_TIME = 0.3;

/** Speed threshold below which avoidance falls back to heading direction. */
const AVOID_MIN_SPEED = 1;

/**
 * Normalize an angle to the range [-PI, PI].
 */
function normalizeAngleAI(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create reactive AI decision state.
 */
function createReactiveState() {
  return {};
}

/**
 * Compute a steering angle offset to avoid obstacles on a collision course.
 *
 * Projects a look-ahead cylinder along the ship's predicted velocity
 * direction (accounting for current momentum + thrust input). Falls back
 * to heading when nearly stationary.
 *
 * Returns { offset, maxUrgency } where offset is the summed angle in
 * radians (positive = steer right, negative = steer left) and maxUrgency
 * is the highest raw urgency (before squaring) across all obstacles.
 */
function computeAvoidanceOffset(aiShip, obstacles) {
  let totalOffset = 0;
  let maxRawUrgency = 0;

  // Compute predicted velocity: current velocity + thrust acceleration
  const power = aiShip.thrustPower ?? THRUST_POWER;
  const thrustAccel =
    aiShip.thrust && aiShip.thrustIntensity > 0
      ? power * aiShip.thrustIntensity
      : 0;
  const predVx =
    aiShip.vx + Math.cos(aiShip.heading) * thrustAccel * AVOID_PREDICT_TIME;
  const predVy =
    aiShip.vy + Math.sin(aiShip.heading) * thrustAccel * AVOID_PREDICT_TIME;
  const predSpeed = Math.sqrt(predVx * predVx + predVy * predVy);

  // Determine look-ahead direction: predicted velocity, or heading fallback
  let dirX;
  let dirY;
  if (predSpeed >= AVOID_MIN_SPEED) {
    dirX = predVx / predSpeed;
    dirY = predVy / predSpeed;
  } else {
    dirX = Math.cos(aiShip.heading);
    dirY = Math.sin(aiShip.heading);
  }

  // dirX, dirY form the forward axis; perpendicular is (-dirY, dirX)
  for (const obs of obstacles) {
    const dx = obs.x - aiShip.x;
    const dy = obs.y - aiShip.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Project onto predicted velocity axis (ahead) and perpendicular (lateral)
    const ahead = dx * dirX + dy * dirY;
    const lateral = -dx * dirY + dy * dirX;

    // --- Cylinder threat ---
    let cylinderUrgency = 0;
    if (ahead > 0 && ahead < AVOID_LOOKAHEAD) {
      const dangerRadius = obs.radius + AVOID_MARGIN;
      if (Math.abs(lateral) < dangerRadius) {
        cylinderUrgency = 1 - ahead / AVOID_LOOKAHEAD;
      }
    }

    // --- Proximity threat ---
    let proximityUrgency = 0;
    const proximityRadius = obs.radius + AVOID_PROXIMITY;
    if (dist < proximityRadius) {
      proximityUrgency = 1 - dist / proximityRadius;
    }

    // Combined urgency: take the stronger signal (linear — stronger medium-range response)
    const rawUrgency = Math.max(cylinderUrgency, proximityUrgency);
    if (rawUrgency <= 0) continue;
    maxRawUrgency = Math.max(maxRawUrgency, rawUrgency);

    // Steer away from obstacle: obstacle to right (lateral > 0) → steer left (negative)
    // Dead center (lateral ≈ 0) → default to steering right (positive)
    const steerDirection = lateral > 0 ? -1 : 1;

    totalOffset += steerDirection * AVOID_STRENGTH * rawUrgency;
  }

  return { offset: totalOffset, maxUrgency: maxRawUrgency };
}

/**
 * Update reactive AI control flags on aiShip to pursue targetShip,
 * fire when aimed, and avoid obstacles.
 *
 * Sets the same 5 control flags as keyboard input so the ship physics
 * engine treats AI and player identically.
 */
function updateReactiveAI(_aiState, aiShip, targetShip, asteroids, _dt) {
  // If either ship is dead, clear all flags
  if (!aiShip.alive || !targetShip.alive) {
    aiShip.thrust = false;
    aiShip.rotatingLeft = false;
    aiShip.rotatingRight = false;
    aiShip.braking = false;
    aiShip.fire = false;
    return;
  }

  // Distance to target
  const dx = targetShip.x - aiShip.x;
  const dy = targetShip.y - aiShip.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  // Lead prediction
  const lookAheadTime = Math.min(dist / PREDICTION_SPEED, MAX_PREDICTION_TIME);
  const predictedX = targetShip.x + targetShip.vx * lookAheadTime;
  const predictedY = targetShip.y + targetShip.vy * lookAheadTime;

  // Angle to predicted position (pursuit angle)
  const pursuitAngle = Math.atan2(predictedY - aiShip.y, predictedX - aiShip.x);

  // Build obstacle list: asteroids only (target ship excluded — AI pursues it)
  const obstacles = asteroids.map((a) => ({
    x: a.x,
    y: a.y,
    radius: a.collisionRadius,
  }));

  // Compute avoidance offset and survival-first blending
  const { offset: avoidanceOffset, maxUrgency } = computeAvoidanceOffset(
    aiShip,
    obstacles,
  );

  // Heading diff to raw pursuit target (for firing decision — fire at target, not avoidance direction)
  const pursuitHeadingDiff = normalizeAngleAI(pursuitAngle - aiShip.heading);

  // Survival-first: suppress pursuit proportionally to threat urgency
  const survivalWeight = Math.min(maxUrgency * AVOIDANCE_PRIORITY, 1.0);
  const pursuitDiff = pursuitHeadingDiff * (1 - survivalWeight);
  const headingDiff = normalizeAngleAI(pursuitDiff + avoidanceOffset);

  // Rotation: turn toward effective angle with dead zone
  aiShip.rotatingLeft = headingDiff < -ROTATION_DEADZONE;
  aiShip.rotatingRight = headingDiff > ROTATION_DEADZONE;

  // Thrust: engage when roughly facing effective direction, or during active avoidance
  const facingEffective = Math.abs(headingDiff) < THRUST_ANGLE;
  const avoidanceActive = avoidanceOffset !== 0;
  aiShip.thrust = facingEffective || avoidanceActive;

  // Brake: engage when NOT facing target AND speed exceeds threshold AND no avoidance
  const speed = Math.sqrt(aiShip.vx * aiShip.vx + aiShip.vy * aiShip.vy);
  aiShip.braking = !facingEffective && !avoidanceActive && speed > BRAKE_SPEED;

  // Fire: aimed within FIRE_ANGLE of predicted target AND within range
  aiShip.fire =
    Math.abs(pursuitHeadingDiff) < FIRE_ANGLE && dist < MAX_FIRE_RANGE;
}

/**
 * Reactive AI strategy object — pluggable interface.
 */
const reactiveStrategy = {
  createState: createReactiveState,
  update: updateReactiveAI,
};

// ===== ai.js =====
/**
 * AI Facade — registers strategies and provides backward-compatible aliases.
 *
 * Registers all available AI strategies in the ai-core registry. Provides
 * createAIState/updateAI as backward-compatible aliases for the reactive
 * strategy, and spawnEnemyPosition for enemy ship placement.
 *
 * In ES module mode, consumers import getStrategy/listStrategies from
 * ai-core.js and reactive constants from ai-reactive.js directly.
 * In the build (single scope), all symbols are already global.
 */

// ── Register strategies ──────────────────────────────────────────────
registerStrategy('reactive', reactiveStrategy);
registerStrategy('predictive', predictiveStrategy);

// ── Backward-compatible aliases (new names — no redeclaration conflict) ──
const createAIState = createReactiveState;
const updateAI = updateReactiveAI;

/** Minimum enemy spawn offset from player (px). */
const MIN_SPAWN_DISTANCE = 600;

/** Maximum enemy spawn offset from player (px). */
const MAX_SPAWN_DISTANCE = 1000;

/**
 * Compute a random spawn position for the enemy ship at
 * MIN_SPAWN_DISTANCE–MAX_SPAWN_DISTANCE from the player.
 */
function spawnEnemyPosition(playerX, playerY) {
  const angle = Math.random() * 2 * Math.PI;
  const distance =
    MIN_SPAWN_DISTANCE +
    Math.random() * (MAX_SPAWN_DISTANCE - MIN_SPAWN_DISTANCE);
  return {
    x: playerX + Math.cos(angle) * distance,
    y: playerY + Math.sin(angle) * distance,
  };
}

// ===== asteroid.js =====
/**
 * Generate an irregular polygon shape for an asteroid.
 * Returns an array of [x, y] vertex pairs centered at origin.
 * Vertices are ordered by increasing angle (no crossed edges).
 */
function generateShape(radius) {
  const vertexCount = 8 + Math.floor(Math.random() * 7); // 8–14
  const step = (Math.PI * 2) / vertexCount;
  const vertices = [];

  for (let i = 0; i < vertexCount; i++) {
    const angle = -Math.PI + step * i; // start at -PI so angles are monotonically increasing
    const r = radius * (0.6 + Math.random() * 0.4); // 0.6–1.0 of radius
    vertices.push([r * Math.cos(angle), r * Math.sin(angle)]);
  }

  return vertices;
}

/**
 * Determine stroke width from asteroid radius (size class).
 */
function getStrokeWidth(radius) {
  if (radius >= 50) return 2.0; // large
  if (radius >= 25) return 1.5; // medium
  return 1.0; // small
}

/**
 * Create an asteroid object.
 */
function createAsteroid({ x, y, vx, vy, radius }) {
  // Angular velocity scaled inversely to radius: smaller = faster spin
  const maxAngVel = 0.5 * (20 / Math.max(radius, 10));
  const angularVelocity = (Math.random() * 2 - 1) * Math.min(maxAngVel, 0.5);

  const shape = generateShape(radius);

  // Compute effective collision radius as average vertex distance from center
  const collisionRadius =
    shape.reduce((sum, [px, py]) => sum + Math.sqrt(px * px + py * py), 0) /
    shape.length;

  return {
    x,
    y,
    vx,
    vy,
    radius,
    collisionRadius,
    rotation: 0,
    angularVelocity,
    shape,
    strokeWidth: getStrokeWidth(radius),
  };
}

/**
 * Update asteroid position and rotation by delta time.
 */
function updateAsteroid(asteroid, dt) {
  asteroid.x += asteroid.vx * dt;
  asteroid.y += asteroid.vy * dt;
  asteroid.rotation += asteroid.angularVelocity * dt;
}

/**
 * Draw an asteroid as a white wireframe polygon on a canvas 2D context.
 */
function drawAsteroid(ctx, asteroid) {
  const { x, y, rotation, shape, strokeWidth } = asteroid;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = strokeWidth;

  ctx.beginPath();
  ctx.moveTo(shape[0][0], shape[0][1]);
  for (let i = 1; i < shape.length; i++) {
    ctx.lineTo(shape[i][0], shape[i][1]);
  }
  ctx.closePath();
  ctx.stroke();

  ctx.restore();
}

// ===== bullet.js =====
/** Bullet travel speed in pixels/second. */
const BULLET_SPEED = 600;

/** Bullet lifetime in seconds before expiry. */
const BULLET_LIFETIME = 2;

/** Minimum interval between shots in seconds. */
const FIRE_COOLDOWN = 0.2;

/** Visual line length of a bullet in pixels. */
const BULLET_LENGTH = 4;

/**
 * Create a bullet entity at the given position, traveling in heading
 * direction at BULLET_SPEED plus inherited ship velocity.
 */
function createBullet(x, y, heading, shipVx, shipVy, owner) {
  return {
    x,
    y,
    vx: Math.cos(heading) * BULLET_SPEED + shipVx,
    vy: Math.sin(heading) * BULLET_SPEED + shipVy,
    heading,
    age: 0,
    owner,
  };
}

/**
 * Update bullet position and age for one frame.
 */
function updateBullet(bullet, dt) {
  bullet.x += bullet.vx * dt;
  bullet.y += bullet.vy * dt;
  bullet.age += dt;
}

/**
 * Returns true when the bullet has exceeded its lifetime.
 */
function isBulletExpired(bullet) {
  return bullet.age >= BULLET_LIFETIME;
}

/**
 * Draw a bullet as a short white line segment oriented along its heading.
 */
function drawBullet(ctx, bullet) {
  const halfLen = BULLET_LENGTH / 2;
  const dx = Math.cos(bullet.heading) * halfLen;
  const dy = Math.sin(bullet.heading) * halfLen;

  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(bullet.x - dx, bullet.y - dy);
  ctx.lineTo(bullet.x + dx, bullet.y + dy);
  ctx.stroke();
}

/**
 * Remove bullets that are inside any asteroid's collision radius.
 * Returns the filtered array of surviving bullets. Asteroids are unaffected.
 */
function checkBulletAsteroidCollisions(bullets, asteroids) {
  return bullets.filter((bullet) => {
    for (const asteroid of asteroids) {
      const dx = bullet.x - asteroid.x;
      const dy = bullet.y - asteroid.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < asteroid.collisionRadius) {
        return false;
      }
    }
    return true;
  });
}

// ===== camera.js =====
/**
 * Create a camera state object.
 */
function createCamera(x, y, rotation) {
  return { x, y, rotation };
}

/**
 * Apply camera transform to a canvas context.
 * Saves context, then applies: translate to screen center →
 * rotate by -rotation → translate by (-x, -y).
 */
function applyCameraTransform(ctx, camera, viewportW, viewportH) {
  ctx.save();
  ctx.translate(viewportW / 2, viewportH / 2);
  ctx.rotate(-camera.rotation);
  ctx.translate(-camera.x, -camera.y);
}

/**
 * Reset camera transform by restoring the saved context.
 */
function resetCameraTransform(ctx) {
  ctx.restore();
}

/**
 * Compute the axis-aligned bounding box of the rotated viewport in world-space.
 * Returns { minX, maxX, minY, maxY } with optional padding margin.
 */
function getViewportBounds(camera, viewportW, viewportH, margin = 0) {
  const cosA = Math.abs(Math.cos(camera.rotation));
  const sinA = Math.abs(Math.sin(camera.rotation));
  const halfW = (viewportW * cosA + viewportH * sinA) / 2;
  const halfH = (viewportW * sinA + viewportH * cosA) / 2;
  return {
    minX: camera.x - halfW - margin,
    maxX: camera.x + halfW + margin,
    minY: camera.y - halfH - margin,
    maxY: camera.y + halfH + margin,
  };
}

/**
 * Convert a world-space coordinate to screen-space.
 * Returns [screenX, screenY].
 */
function worldToScreen(wx, wy, camera, viewportW, viewportH) {
  // Translate by (-camera.x, -camera.y)
  const dx = wx - camera.x;
  const dy = wy - camera.y;
  // Rotate by -camera.rotation
  const cosR = Math.cos(-camera.rotation);
  const sinR = Math.sin(-camera.rotation);
  const rx = dx * cosR - dy * sinR;
  const ry = dx * sinR + dy * cosR;
  // Translate to screen center
  return [rx + viewportW / 2, ry + viewportH / 2];
}

/**
 * Convert a screen-space coordinate to world-space.
 * Returns [worldX, worldY]. Inverse of worldToScreen.
 */
function screenToWorld(sx, sy, camera, viewportW, viewportH) {
  // Reverse translate from screen center
  const cx = sx - viewportW / 2;
  const cy = sy - viewportH / 2;
  // Reverse rotate (rotate by +camera.rotation)
  const cosR = Math.cos(camera.rotation);
  const sinR = Math.sin(camera.rotation);
  const rx = cx * cosR - cy * sinR;
  const ry = cx * sinR + cy * cosR;
  // Reverse translate
  return [rx + camera.x, ry + camera.y];
}

// ===== debug.js =====
/**
 * AI Debug Logger — structured console telemetry for diagnosing AI behavior.
 *
 * Toggled via settings checkbox or window.aiDebug.enable()/disable().
 * Zero cost when disabled — all functions are no-ops.
 */

/** Rate limit interval for periodic logs (seconds). */
const LOG_INTERVAL = 0.5;

/**
 * Format ship control flags as a compact 4-character string.
 * T=thrust, L=left, R=right, B=brake, _=inactive.
 */
function fmtAction(ship) {
  return (
    (ship.thrust ? 'T' : '_') +
    (ship.rotatingLeft ? 'L' : '_') +
    (ship.rotatingRight ? 'R' : '_') +
    (ship.braking ? 'B' : '_')
  );
}

/**
 * Create a debug logger instance.
 */
function createDebugLogger() {
  let enabled = false;
  let lastLogTime = -Infinity;
  let lastAction = '';

  function enable() {
    enabled = true;
  }

  function disable() {
    enabled = false;
  }

  function isEnabled() {
    return enabled;
  }

  /**
   * Log AI frame telemetry. Rate-limited to LOG_INTERVAL, but always
   * logs immediately on action change.
   */
  function logAIFrame(elapsed, enemy, player, debugInfo) {
    if (!enabled) return;

    const action = fmtAction(enemy);
    const actionChanged = action !== lastAction && lastAction !== '';
    const timeSinceLastLog = elapsed - lastLogTime;

    if (!actionChanged && timeSinceLastLog < LOG_INTERVAL && lastLogTime >= 0) {
      return;
    }

    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const dist = Math.round(Math.sqrt(dx * dx + dy * dy));
    const spd = Math.round(
      Math.sqrt(enemy.vx * enemy.vx + enemy.vy * enemy.vy),
    );

    if (actionChanged) {
      console.log(
        `[AI ${elapsed.toFixed(2)}s] CHANGE ${lastAction} → ${action} dist=${dist}`,
      );
    } else {
      let msg = `[AI ${elapsed.toFixed(2)}s] dist=${dist} action=${action} spd=${spd} hdg=${enemy.heading.toFixed(2)} pos=(${Math.round(enemy.x)},${Math.round(enemy.y)})`;

      if (debugInfo?.candidates) {
        const scores = debugInfo.candidates
          .map((c) => `${c.name}:${Math.round(c.score)}`)
          .join(' ');
        msg += ` | ${scores}`;
      }

      console.log(msg);
    }

    lastAction = action;
    lastLogTime = elapsed;
  }

  /**
   * Log an immediate event (fire, collision, etc.).
   */
  function logEvent(elapsed, type, data) {
    if (!enabled) return;

    const parts = Object.entries(data)
      .map(([k, v]) => {
        if (typeof v === 'number') {
          return `${k}=${Number.isInteger(v) ? v : v.toFixed(2)}`;
        }
        return `${k}=${v}`;
      })
      .join(' ');

    console.log(`[${type} ${elapsed.toFixed(2)}s] ${parts}`);
  }

  return {
    enable,
    disable,
    isEnabled,
    logAIFrame,
    logEvent,
  };
}

// ===== energy.js =====
/**
 * Compute kinetic energy for a single asteroid.
 * KE = 0.5 * mass * speed², where mass = collisionRadius²
 */
function computeKE(asteroid) {
  const mass = asteroid.collisionRadius * asteroid.collisionRadius;
  return 0.5 * mass * (asteroid.vx * asteroid.vx + asteroid.vy * asteroid.vy);
}

/**
 * Sum kinetic energy across all asteroids.
 */
function computeTotalKE(asteroids) {
  let total = 0;
  for (const a of asteroids) {
    total += computeKE(a);
  }
  return total;
}

/**
 * Compute a speed multiplier for new spawns to sustain system energy.
 * Returns clamp(sqrt(targetKE / actualKE), 1.0, 1.5).
 */
function computeSpeedBoost(
  baselineKEPerAsteroid,
  targetCount,
  asteroids,
) {
  const targetKE = baselineKEPerAsteroid * targetCount;
  if (targetKE <= 0) return 1.0;

  const actualKE = computeTotalKE(asteroids);
  if (actualKE <= 0) return 1.5;
  if (actualKE >= targetKE) return 1.0;

  return Math.min(Math.sqrt(targetKE / actualKE), 1.5);
}

// ===== game.js =====
/** Duration of the explosion effect in seconds. */
const EXPLOSION_DURATION = 1.0;

/** Maximum radius the explosion circle expands to (pixels). */
const EXPLOSION_MAX_RADIUS = 60;

/**
 * Check if a bullet is within a ship's collision radius.
 * Returns true when distance(bullet, ship) < ship.collisionRadius.
 */
function checkBulletShipHit(bullet, ship) {
  const dx = bullet.x - ship.x;
  const dy = bullet.y - ship.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  return dist < ship.collisionRadius;
}

/**
 * Process bullet-ship collisions for both ships.
 * Player bullets can only hit the enemy; enemy bullets can only hit the player.
 * Dead ships cannot be hit.
 *
 * Returns { bullets, playerHit, enemyHit } — surviving bullets and hit flags.
 * Does NOT mutate ships (caller handles death).
 */
function processBulletShipCollisions(bullets, playerShip, enemyShip) {
  let playerHit = false;
  let enemyHit = false;

  const surviving = bullets.filter((bullet) => {
    if (bullet.owner === 'player' && enemyShip.alive) {
      if (checkBulletShipHit(bullet, enemyShip)) {
        enemyHit = true;
        return false;
      }
    }
    if (bullet.owner === 'enemy' && playerShip.alive) {
      if (checkBulletShipHit(bullet, playerShip)) {
        playerHit = true;
        return false;
      }
    }
    return true;
  });

  return { bullets: surviving, playerHit, enemyHit };
}

/**
 * Create an explosion effect at the given world position.
 * @param {number} x
 * @param {number} y
 * @param {{ r: number, g: number, b: number }} color - RGB color for the rings
 */
function createExplosion(x, y, color = { r: 255, g: 255, b: 255 }) {
  return { x, y, age: 0, color };
}

/**
 * Advance explosion age by dt.
 */
function updateExplosion(explosion, dt) {
  explosion.age += dt;
}

/**
 * Returns true when the explosion has completed its animation.
 */
function isExplosionDone(explosion) {
  return explosion.age >= EXPLOSION_DURATION;
}

/** Inner circle radius ratio relative to the outer circle. */
const EXPLOSION_INNER_RATIO = 0.5;

/**
 * Draw two expanding concentric wireframe circles that fade out over lifetime.
 * The inner circle is smaller and slightly brighter, creating depth.
 */
function drawExplosion(ctx, explosion) {
  const progress = explosion.age / EXPLOSION_DURATION;
  const outerRadius = progress * EXPLOSION_MAX_RADIUS;
  const innerRadius = outerRadius * EXPLOSION_INNER_RATIO;
  const alpha = 1.0 - progress;

  const { r, g, b } = explosion.color;

  ctx.save();

  // Outer circle
  ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(explosion.x, explosion.y, outerRadius, 0, Math.PI * 2);
  ctx.stroke();

  // Inner circle — slightly brighter
  ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${Math.min(alpha * 1.4, 1.0)})`;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(explosion.x, explosion.y, innerRadius, 0, Math.PI * 2);
  ctx.stroke();

  ctx.restore();
}

/**
 * Create the initial game state.
 */
function createGameState() {
  return {
    phase: 'playing',
    explosions: [],
  };
}

/**
 * Transition game phase based on ship alive status.
 * Only transitions from 'playing' — terminal states are sticky.
 */
function updateGameState(state, playerShip, enemyShip) {
  if (state.phase !== 'playing') return;

  if (!playerShip.alive) {
    state.phase = 'playerDead';
  } else if (!enemyShip.alive) {
    state.phase = 'playerWin';
  }
}

// ===== input.js =====
/**
 * Create a fresh input state with all flags false.
 */
function createInputState() {
  return {
    thrust: false,
    rotateLeft: false,
    rotateRight: false,
    brake: false,
    fire: false,
  };
}

const KEY_MAP = {
  w: 'thrust',
  arrowup: 'thrust',
  a: 'rotateLeft',
  arrowleft: 'rotateLeft',
  d: 'rotateRight',
  arrowright: 'rotateRight',
  s: 'brake',
  arrowdown: 'brake',
  ' ': 'fire',
};

function resolveKey(key) {
  return KEY_MAP[key.toLowerCase()] || null;
}

/**
 * Handle a keydown event — set the corresponding input flag to true.
 */
function handleKeyDown(state, key) {
  const flag = resolveKey(key);
  if (flag) state[flag] = true;
}

/**
 * Handle a keyup event — clear the corresponding input flag.
 */
function handleKeyUp(state, key) {
  const flag = resolveKey(key);
  if (flag) state[flag] = false;
}

/**
 * Copy input flags onto ship control booleans.
 */
function applyInput(inputState, ship) {
  ship.thrust = inputState.thrust;
  ship.rotatingLeft = inputState.rotateLeft;
  ship.rotatingRight = inputState.rotateRight;
  ship.braking = inputState.brake;
  ship.fire = inputState.fire;
}

// ===== main.js =====






/**
 * Calculate delta time in seconds between two timestamps (ms).
 * Caps at 0.1s to avoid spiral-of-death after tab backgrounding.
 * Never returns negative values.
 */
function calculateDeltaTime(currentTimestamp, previousTimestamp) {
  const dtSeconds = (currentTimestamp - previousTimestamp) / 1000;
  return Math.min(Math.max(dtSeconds, 0), 0.1);
}

/**
 * Create an animation loop state object.
 * Call loop.tick(timestamp) each frame from requestAnimationFrame.
 * First tick returns dt=0 (no previous frame to diff against).
 */
function createLoop() {
  let started = false;

  const state = {
    frameCount: 0,
    lastTimestamp: 0,

    tick(timestamp) {
      let dt = 0;
      if (started) {
        dt = calculateDeltaTime(timestamp, state.lastTimestamp);
      }
      started = true;
      state.lastTimestamp = timestamp;
      state.frameCount++;
      return dt;
    },
  };
  return state;
}

/**
 * Bootstrap the application: set up canvas, resize handling, and start the loop.
 */
const BASE_ASTEROID_COUNT = 40;
function startApp() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  let logicalSize = setupHiDPICanvas(
    canvas,
    ctx,
    window.innerWidth,
    window.innerHeight,
    dpr,
  );

  const loop = createLoop();
  let starLayers = createParallaxLayers(logicalSize.width, logicalSize.height);
  const initialBounds = {
    minX: 0,
    maxX: logicalSize.width,
    minY: 0,
    maxY: logicalSize.height,
  };
  const sim = createSimulation(initialBounds);
  const playerShip = createShip({
    x: logicalSize.width / 2,
    y: logicalSize.height / 2,
    heading: -Math.PI / 2,
  });
  const camera = createCamera(
    playerShip.x,
    playerShip.y,
    playerShip.heading + Math.PI / 2,
  );
  const playerTrail = createTrail();
  const enemySpawn = spawnEnemyPosition(playerShip.x, playerShip.y);
  const headingToPlayer = Math.atan2(
    playerShip.y - enemySpawn.y,
    playerShip.x - enemySpawn.x,
  );
  const enemyShip = createShip({
    x: enemySpawn.x,
    y: enemySpawn.y,
    heading: headingToPlayer,
    owner: 'enemy',
  });
  const enemyTrail = createTrail(ENEMY_TRAIL_COLOR);
  let bullets = [];
  const gameState = createGameState();
  let prevCameraX = camera.x;
  let prevCameraY = camera.y;
  let prevCameraRotation = camera.rotation;
  const inputState = createInputState();
  const loaded = loadSettings();
  const settings = createSettings(loaded);
  let enemyStrategy = getStrategy(settings.enemyIntelligence);
  let enemyAIState = enemyStrategy.createState();
  let playerStrategy =
    settings.playerIntelligence !== 'human'
      ? getStrategy(settings.playerIntelligence)
      : null;
  let playerAIState = playerStrategy?.createState() ?? null;
  let elapsedTime = 0;
  const debugLogger = createDebugLogger();
  if (settings.aiDebugLog) debugLogger.enable();
  // Expose on window for console access
  if (typeof window !== 'undefined') {
    window.aiDebug = {
      enable: () => {
        debugLogger.enable();
        settings.aiDebugLog = true;
      },
      disable: () => {
        debugLogger.disable();
        settings.aiDebugLog = false;
      },
    };
  }

  // Settings UI
  const ui = createSettingsUI(document.body, settings);
  // Apply loaded settings to simulation, ships, and starfield
  sim.targetCount = Math.round(BASE_ASTEROID_COUNT * settings.asteroidDensity);
  playerShip.thrustPower = settings.thrustPower;
  enemyShip.thrustPower = settings.thrustPower;
  if (settings.starLayers !== 3) {
    starLayers = createParallaxLayers(
      logicalSize.width,
      logicalSize.height,
      settings.starLayers,
    );
  }
  if (settings.starDirection !== 'left') {
    redistributeStars(
      starLayers,
      logicalSize.width,
      logicalSize.height,
      settings.starDirection,
    );
  }

  ui.onChange = (name, value) => {
    settings[name] = value;
    if (name === 'starLayers') {
      starLayers = createParallaxLayers(
        logicalSize.width,
        logicalSize.height,
        value,
      );
    }
    if (name === 'thrustPower') {
      playerShip.thrustPower = value;
      enemyShip.thrustPower = value;
    }
    if (name === 'starDirection') {
      redistributeStars(
        starLayers,
        logicalSize.width,
        logicalSize.height,
        value,
      );
    }
    if (name === 'enemyIntelligence') {
      enemyStrategy = getStrategy(value);
      enemyAIState = enemyStrategy.createState();
    }
    if (name === 'playerIntelligence') {
      if (value === 'human') {
        playerStrategy = null;
        playerAIState = null;
      } else {
        playerStrategy = getStrategy(value);
        playerAIState = playerStrategy.createState();
      }
    }
    if (name === 'aiDebugLog') {
      if (value) {
        debugLogger.enable();
      } else {
        debugLogger.disable();
      }
    }
    saveSettings(settings);
  };

  // Resize: update canvas with HiDPI and redistribute stars
  window.addEventListener('resize', () => {
    logicalSize = setupHiDPICanvas(
      canvas,
      ctx,
      window.innerWidth,
      window.innerHeight,
      dpr,
    );
    redistributeStars(
      starLayers,
      logicalSize.width,
      logicalSize.height,
      settings.starDirection,
    );
  });

  // Auto-hide: reset gear timer on any mouse movement
  window.addEventListener('mousemove', () => {
    settings.gearTimer = 0;
    if (settings.panelOpen) {
      settings.panelTimer = 0;
    }
  });

  // Keyboard input for ship controls
  window.addEventListener('keydown', (e) => handleKeyDown(inputState, e.key));
  window.addEventListener('keyup', (e) => handleKeyUp(inputState, e.key));

  function frame(timestamp) {
    const dt = loop.tick(timestamp);
    elapsedTime += dt;

    // Apply speed multiplier to simulation dt
    const scaledDt = dt * settings.speedMultiplier;

    updateAutoHide(settings, dt);

    // When panel is open, button acts as close icon — always fully visible
    if (settings.panelOpen) {
      ui.gearButton.style.opacity = '0.8';
      ui.gearButton.style.pointerEvents = 'auto';
    } else {
      ui.gearButton.style.opacity = settings.gearVisible
        ? settings.gearHovered
          ? '0.8'
          : '0.3'
        : '0';
      ui.gearButton.style.pointerEvents = settings.gearVisible
        ? 'auto'
        : 'none';
    }
    ui.panel.style.display = settings.panelOpen ? 'block' : 'none';
    ui.gearButton.textContent = settings.panelOpen ? '\u2715' : '\u2630';

    // Player input: keyboard or AI
    if (playerShip.alive) {
      if (playerStrategy) {
        playerStrategy.update(
          playerAIState,
          playerShip,
          enemyShip,
          sim.asteroids,
          scaledDt,
        );
      } else {
        applyInput(inputState, playerShip);
      }
      updateShip(playerShip, scaledDt);
    }

    // Enemy always AI
    if (enemyShip.alive) {
      enemyStrategy.update(
        enemyAIState,
        enemyShip,
        playerShip,
        sim.asteroids,
        scaledDt,
      );
      updateShip(enemyShip, scaledDt);
    }

    // AI debug logging
    debugLogger.logAIFrame(
      elapsedTime,
      enemyShip,
      playerShip,
      getLastDebugInfo(),
    );

    // Bullet firing — player
    playerShip.fireCooldown = Math.max(playerShip.fireCooldown - scaledDt, 0);
    if (playerShip.fire && playerShip.fireCooldown <= 0 && playerShip.alive) {
      const noseX = playerShip.x + Math.cos(playerShip.heading) * SHIP_SIZE;
      const noseY = playerShip.y + Math.sin(playerShip.heading) * SHIP_SIZE;
      bullets.push(
        createBullet(
          noseX,
          noseY,
          playerShip.heading,
          playerShip.vx,
          playerShip.vy,
          'player',
        ),
      );
      playerShip.fireCooldown = FIRE_COOLDOWN;
      const pdx = enemyShip.x - playerShip.x;
      const pdy = enemyShip.y - playerShip.y;
      debugLogger.logEvent(elapsedTime, 'FIRE', {
        owner: 'player',
        dist: Math.round(Math.sqrt(pdx * pdx + pdy * pdy)),
        angle: Math.abs(Math.atan2(pdy, pdx) - playerShip.heading).toFixed(2),
      });
    }

    // Bullet firing — enemy (AI)
    enemyShip.fireCooldown = Math.max(enemyShip.fireCooldown - scaledDt, 0);
    if (enemyShip.fire && enemyShip.fireCooldown <= 0 && enemyShip.alive) {
      const noseX = enemyShip.x + Math.cos(enemyShip.heading) * SHIP_SIZE;
      const noseY = enemyShip.y + Math.sin(enemyShip.heading) * SHIP_SIZE;
      bullets.push(
        createBullet(
          noseX,
          noseY,
          enemyShip.heading,
          enemyShip.vx,
          enemyShip.vy,
          'enemy',
        ),
      );
      enemyShip.fireCooldown = FIRE_COOLDOWN;
      const edx = playerShip.x - enemyShip.x;
      const edy = playerShip.y - enemyShip.y;
      debugLogger.logEvent(elapsedTime, 'FIRE', {
        owner: 'enemy',
        dist: Math.round(Math.sqrt(edx * edx + edy * edy)),
        angle: Math.abs(Math.atan2(edy, edx) - enemyShip.heading).toFixed(2),
      });
    }

    if (playerShip.alive) {
      updateTrail(
        playerTrail,
        playerShip.x,
        playerShip.y,
        playerShip.heading,
        playerShip.thrustIntensity,
      );
    } else {
      drainTrail(playerTrail, scaledDt);
    }
    if (enemyShip.alive) {
      updateTrail(
        enemyTrail,
        enemyShip.x,
        enemyShip.y,
        enemyShip.heading,
        enemyShip.thrustIntensity,
      );
    } else {
      drainTrail(enemyTrail, scaledDt);
    }

    // Camera follows ship (PI/2 offset so ship nose points UP on screen)
    camera.x = playerShip.x;
    camera.y = playerShip.y;
    camera.rotation = playerShip.heading + Math.PI / 2;

    // Compute camera deltas and rotate to screen space for starfield parallax
    const cameraDeltaX = camera.x - prevCameraX;
    const cameraDeltaY = camera.y - prevCameraY;
    // Normalize rotation delta to [-PI, PI] so heading wrapping doesn't
    // produce a ±2PI spike that snaps stars across the screen
    let cameraDeltaRotation = camera.rotation - prevCameraRotation;
    while (cameraDeltaRotation > Math.PI) cameraDeltaRotation -= 2 * Math.PI;
    while (cameraDeltaRotation < -Math.PI) cameraDeltaRotation += 2 * Math.PI;
    const cosR = Math.cos(-camera.rotation);
    const sinR = Math.sin(-camera.rotation);
    const screenDx = cameraDeltaX * cosR - cameraDeltaY * sinR;
    const screenDy = cameraDeltaX * sinR + cameraDeltaY * cosR;

    updateStarLayersCamera(
      starLayers,
      screenDx,
      screenDy,
      cameraDeltaRotation,
      logicalSize.width,
      logicalSize.height,
    );

    prevCameraX = camera.x;
    prevCameraY = camera.y;
    prevCameraRotation = camera.rotation;
    // Tight viewport bounds (no margin — simulation handles its own zones)
    const viewportBounds = getViewportBounds(
      camera,
      logicalSize.width,
      logicalSize.height,
    );
    // Target count uses zone area (viewport + border) for proportional density
    const spawnBounds = computeSpawnBounds(viewportBounds);
    const zoneArea =
      (spawnBounds.maxX - spawnBounds.minX) *
      (spawnBounds.maxY - spawnBounds.minY);
    const viewportArea = logicalSize.width * logicalSize.height;
    sim.targetCount = Math.round(
      BASE_ASTEROID_COUNT *
        settings.asteroidDensity *
        (zoneArea / viewportArea),
    );
    updateSimulation(
      sim,
      scaledDt,
      viewportBounds,
      playerShip.vx,
      playerShip.vy,
    );

    // Bullet update, expiry, and asteroid collisions
    for (const bullet of bullets) {
      updateBullet(bullet, scaledDt);
    }
    bullets = bullets.filter((b) => !isBulletExpired(b));
    bullets = checkBulletAsteroidCollisions(bullets, sim.asteroids);

    // Bullet-ship collisions
    if (gameState.phase === 'playing') {
      const collisionResult = processBulletShipCollisions(
        bullets,
        playerShip,
        enemyShip,
      );
      bullets = collisionResult.bullets;
      if (collisionResult.playerHit) {
        playerShip.alive = false;
        gameState.explosions.push(
          createExplosion(playerShip.x, playerShip.y, PLAYER_TRAIL_COLOR),
        );
      }
      if (collisionResult.enemyHit) {
        enemyShip.alive = false;
        gameState.explosions.push(
          createExplosion(enemyShip.x, enemyShip.y, ENEMY_TRAIL_COLOR),
        );
      }
      updateGameState(gameState, playerShip, enemyShip);
    }

    // Update explosions
    for (const explosion of gameState.explosions) {
      updateExplosion(explosion, scaledDt);
    }
    gameState.explosions = gameState.explosions.filter(
      (e) => !isExplosionDone(e),
    );

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, logicalSize.width, logicalSize.height);

    drawParallaxLayers(ctx, starLayers, elapsedTime);

    applyCameraTransform(ctx, camera, logicalSize.width, logicalSize.height);

    for (const asteroid of sim.asteroids) {
      drawAsteroid(ctx, asteroid);
    }

    drawTrail(ctx, enemyTrail);
    drawShip(ctx, enemyShip);
    drawTrail(ctx, playerTrail);
    drawShip(ctx, playerShip);

    for (const bullet of bullets) {
      drawBullet(ctx, bullet);
    }

    for (const explosion of gameState.explosions) {
      drawExplosion(ctx, explosion);
    }

    resetCameraTransform(ctx);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

// ===== physics.js =====
/**
 * Detect all colliding asteroid pairs using circle-circle collision.
 * Returns an array of [asteroidA, asteroidB] pairs.
 * A collision occurs when distance between centers < sum of collision radii.
 * Exactly touching (distance === sum) is NOT a collision.
 */
function detectCollisions(asteroids) {
  const pairs = [];
  for (let i = 0; i < asteroids.length; i++) {
    for (let j = i + 1; j < asteroids.length; j++) {
      const a = asteroids[i];
      const b = asteroids[j];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const radiiSum = a.collisionRadius + b.collisionRadius;
      if (dist < radiiSum) {
        pairs.push([a, b]);
      }
    }
  }
  return pairs;
}

/**
 * Separate two overlapping asteroids along the collision normal.
 * Lighter asteroid (smaller collisionRadius²) is pushed proportionally more.
 */
function separateOverlap(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist === 0) {
    // Perfectly coincident — push apart along arbitrary axis
    b.x += a.collisionRadius + b.collisionRadius;
    return;
  }

  const overlap = a.collisionRadius + b.collisionRadius - dist;
  if (overlap <= 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const massA = a.collisionRadius * a.collisionRadius;
  const massB = b.collisionRadius * b.collisionRadius;
  const totalMass = massA + massB;

  // Lighter asteroid moves more
  const pushA = overlap * (massB / totalMass);
  const pushB = overlap * (massA / totalMass);

  a.x -= nx * pushA;
  a.y -= ny * pushA;
  b.x += nx * pushB;
  b.y += ny * pushB;
}

/**
 * Resolve an elastic collision between two asteroids.
 * Uses 2D elastic collision formula with mass = collisionRadius².
 * Applies ±1% random perturbation and angular velocity nudge.
 */
function resolveCollision(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist === 0) return;

  const nx = dx / dist;
  const ny = dy / dist;

  const massA = a.collisionRadius * a.collisionRadius;
  const massB = b.collisionRadius * b.collisionRadius;

  // Relative velocity along collision normal
  const dvx = a.vx - b.vx;
  const dvy = a.vy - b.vy;
  const dvDotN = dvx * nx + dvy * ny;

  // Don't resolve if asteroids are moving apart
  if (dvDotN <= 0) return;

  const totalMass = massA + massB;

  // 2D elastic collision impulse with ±1% perturbation on magnitude.
  // Using a single factor for both asteroids preserves momentum exactly
  // while adding enough variation to prevent repeating collision patterns.
  // Kept at ±1% to maintain KE conservation within 5%.
  const perturbation = 1 + (Math.random() * 0.02 - 0.01);
  const impulseA = ((2 * massB) / totalMass) * dvDotN * perturbation;
  const impulseB = ((2 * massA) / totalMass) * dvDotN * perturbation;

  a.vx -= impulseA * nx;
  a.vy -= impulseA * ny;
  b.vx += impulseB * nx;
  b.vy += impulseB * ny;

  // Nudge angular velocity slightly on impact
  const angularNudge = () => Math.random() * 0.2 - 0.1;
  a.angularVelocity += angularNudge();
  b.angularVelocity += angularNudge();
}

// ===== renderer.js =====
/**
 * Set up a canvas for HiDPI rendering.
 * Sets internal resolution to CSS size × dpr, applies CSS size,
 * and scales the context so all drawing uses CSS (logical) coordinates.
 * Returns the logical size { width, height } for use by game systems.
 */
function setupHiDPICanvas(canvas, ctx, cssWidth, cssHeight, dpr) {
  canvas.width = cssWidth * dpr;
  canvas.height = cssHeight * dpr;
  canvas.style.width = `${cssWidth}px`;
  canvas.style.height = `${cssHeight}px`;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { width: cssWidth, height: cssHeight };
}

// ===== settings.js =====
/**
 * Configuration for each setting: range, step, default, and display label.
 */
const SETTINGS_CONFIG = {
  asteroidDensity: {
    min: 0.5,
    max: 3.0,
    step: 0.1,
    default: 1.0,
    label: 'Density',
  },
  speedMultiplier: {
    min: 0.2,
    max: 3.0,
    step: 0.1,
    default: 1.0,
    label: 'Speed',
  },
  starLayers: { min: 3, max: 6, step: 1, default: 3, label: 'Star Layers' },
  thrustPower: {
    min: 1000,
    max: 5000,
    step: 50,
    default: 2000,
    label: 'Thrust',
  },
  starDirection: {
    options: ['left', 'right', 'up', 'down', 'radial'],
    default: 'left',
    label: 'Direction',
  },
  playerIntelligence: {
    options: ['human', 'reactive', 'predictive', 'predictive-optimized'],
    default: 'human',
    label: 'Player',
  },
  enemyIntelligence: {
    options: ['reactive', 'predictive', 'predictive-optimized'],
    default: 'predictive',
    label: 'Enemy AI',
  },
  aiDebugLog: {
    type: 'boolean',
    default: false,
    label: 'AI Debug Log',
  },
};

const STORAGE_KEY = 'asteroidSettings';

/**
 * Create settings state with defaults, optionally applying overrides.
 */
function createSettings(overrides = {}) {
  return {
    asteroidDensity:
      overrides.asteroidDensity ?? SETTINGS_CONFIG.asteroidDensity.default,
    speedMultiplier:
      overrides.speedMultiplier ?? SETTINGS_CONFIG.speedMultiplier.default,
    starLayers: overrides.starLayers ?? SETTINGS_CONFIG.starLayers.default,
    thrustPower: overrides.thrustPower ?? SETTINGS_CONFIG.thrustPower.default,
    starDirection:
      overrides.starDirection ?? SETTINGS_CONFIG.starDirection.default,
    playerIntelligence:
      overrides.playerIntelligence ??
      SETTINGS_CONFIG.playerIntelligence.default,
    enemyIntelligence:
      overrides.enemyIntelligence ?? SETTINGS_CONFIG.enemyIntelligence.default,
    aiDebugLog: overrides.aiDebugLog ?? SETTINGS_CONFIG.aiDebugLog.default,
    panelOpen: false,
    gearVisible: true,
    gearHovered: false,
    gearTimer: 0,
    panelTimer: 0,
  };
}

/**
 * Save tunable settings to localStorage.
 */
function saveSettings(settings) {
  const data = {
    asteroidDensity: settings.asteroidDensity,
    speedMultiplier: settings.speedMultiplier,
    starLayers: settings.starLayers,
    thrustPower: settings.thrustPower,
    starDirection: settings.starDirection,
    playerIntelligence: settings.playerIntelligence,
    enemyIntelligence: settings.enemyIntelligence,
    aiDebugLog: settings.aiDebugLog,
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

/**
 * Load settings from localStorage. Returns an object with tunable values.
 * Falls back to defaults if storage is empty, corrupt, or contains invalid values.
 */
function loadSettings() {
  const defaults = {
    asteroidDensity: SETTINGS_CONFIG.asteroidDensity.default,
    speedMultiplier: SETTINGS_CONFIG.speedMultiplier.default,
    starLayers: SETTINGS_CONFIG.starLayers.default,
    thrustPower: SETTINGS_CONFIG.thrustPower.default,
    starDirection: SETTINGS_CONFIG.starDirection.default,
    playerIntelligence: SETTINGS_CONFIG.playerIntelligence.default,
    enemyIntelligence: SETTINGS_CONFIG.enemyIntelligence.default,
    aiDebugLog: SETTINGS_CONFIG.aiDebugLog.default,
  };

  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw === null) return defaults;

    const parsed = JSON.parse(raw);
    if (
      typeof parsed !== 'object' ||
      parsed === null ||
      Array.isArray(parsed)
    ) {
      return defaults;
    }

    // Backward compat: migrate old aiStrategy → enemyIntelligence
    if (parsed.aiStrategy && parsed.enemyIntelligence === undefined) {
      parsed.enemyIntelligence = parsed.aiStrategy;
    }

    const result = {};
    for (const name of Object.keys(defaults)) {
      const config = SETTINGS_CONFIG[name];
      const val = parsed[name];

      if (config.type === 'boolean') {
        // Boolean setting (e.g. aiDebugLog)
        result[name] = typeof val === 'boolean' ? val : defaults[name];
      } else if (config.options) {
        // String enum setting (e.g. starDirection)
        result[name] = config.options.includes(val) ? val : defaults[name];
      } else if (typeof val === 'number' && !Number.isNaN(val)) {
        result[name] = clampSetting(name, val);
      } else {
        result[name] = defaults[name];
      }
    }
    return result;
  } catch {
    return defaults;
  }
}

/**
 * Clamp a setting value to its valid range.
 * Integer settings (step=1) are rounded to the nearest integer.
 */
function clampSetting(name, value) {
  const config = SETTINGS_CONFIG[name];
  let v = Number(value);
  if (config.step >= 1) v = Math.round(v);
  return Math.min(config.max, Math.max(config.min, v));
}

/**
 * Update auto-hide timers. Call each frame with dt.
 * - Gear hides after 3s of no mouse movement (caller resets gearTimer to 0 on mouse move)
 * - Panel closes after 4s of no mouse activity over it (caller resets panelTimer to 0)
 */
function updateAutoHide(settings, dt) {
  settings.gearTimer += dt;
  if (settings.gearTimer < 3) {
    settings.gearVisible = true;
  } else {
    settings.gearVisible = false;
  }

  if (settings.panelOpen) {
    settings.panelTimer += dt;
    if (settings.panelTimer >= 4) {
      settings.panelOpen = false;
    }
  }
}

/**
 * Format a setting value for display.
 */
function formatValue(name, value) {
  if (name === 'speedMultiplier' || name === 'asteroidDensity')
    return `${value.toFixed(1)}x`;
  return String(value);
}

/**
 * Create the settings UI: gear button, panel with sliders.
 * Returns { gearButton, panel, sliders, valueDisplays, onChange }.
 */
function createSettingsUI(container, settings) {
  // Hamburger menu button
  const gearButton = document.createElement('button');
  gearButton.textContent = '\u2630';
  gearButton.style.cssText =
    'position:fixed;top:20px;left:20px;background:none;border:none;' +
    'color:#fff;font-size:28px;cursor:pointer;opacity:0.3;z-index:1001;' +
    'padding:8px;line-height:1;transition:opacity 0.2s;';
  gearButton.addEventListener('mouseenter', () => {
    settings.gearHovered = true;
    gearButton.style.opacity = '0.8';
  });
  gearButton.addEventListener('mouseleave', () => {
    settings.gearHovered = false;
    gearButton.style.opacity = '0.3';
  });
  container.appendChild(gearButton);

  // Panel
  const panel = document.createElement('div');
  panel.style.cssText =
    'position:fixed;top:0;left:0;width:260px;height:100%;' +
    'background:rgba(0,0,0,0.85);color:#fff;font-family:"Courier New",monospace;' +
    'font-size:14px;padding:70px 20px 24px;box-sizing:border-box;z-index:1000;' +
    'display:none;';
  container.appendChild(panel);

  const title = document.createElement('div');
  title.textContent = 'Settings';
  title.style.cssText = 'font-size:18px;margin-bottom:24px;';
  panel.appendChild(title);

  let _onChange = () => {};

  const sliders = {};
  const valueDisplays = {};

  const selects = {};
  const checkboxes = {};

  for (const [name, config] of Object.entries(SETTINGS_CONFIG)) {
    if (config.type === 'boolean') {
      // Boolean setting — render as a checkbox
      const row = document.createElement('div');
      row.style.cssText = 'margin-bottom:20px;';

      const label = document.createElement('label');
      label.style.cssText = 'display:flex;align-items:center;cursor:pointer;';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = settings[name];
      checkbox.style.cssText = 'margin-right:8px;';
      checkboxes[name] = checkbox;

      checkbox.addEventListener('change', () => {
        _onChange(name, checkbox.checked);
      });

      const labelText = document.createElement('span');
      labelText.textContent = config.label;

      label.appendChild(checkbox);
      label.appendChild(labelText);
      row.appendChild(label);
      panel.appendChild(row);
      continue;
    }

    if (config.options) {
      // Enum setting — render as a <select> dropdown
      const row = document.createElement('div');
      row.style.cssText = 'margin-bottom:20px;';

      const label = document.createElement('label');
      label.style.cssText = 'display:block;margin-bottom:6px;';
      label.textContent = config.label;

      const select = document.createElement('select');
      select.style.cssText =
        'width:100%;background:#222;color:#fff;border:1px solid #555;' +
        'padding:4px;font-family:"Courier New",monospace;font-size:14px;';
      for (const opt of config.options) {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        select.appendChild(option);
      }
      select.value = settings[name];
      selects[name] = select;

      select.addEventListener('change', () => {
        _onChange(name, select.value);
      });

      row.appendChild(label);
      row.appendChild(select);
      panel.appendChild(row);
      continue;
    }

    // Numeric setting — render as a slider
    const row = document.createElement('div');
    row.style.cssText = 'margin-bottom:20px;';

    const label = document.createElement('label');
    label.style.cssText = 'display:block;margin-bottom:6px;';

    const labelText = document.createElement('span');
    labelText.textContent = config.label;

    const valueSpan = document.createElement('span');
    valueSpan.textContent = formatValue(name, settings[name]);
    valueSpan.style.cssText = 'float:right;';
    valueDisplays[name] = valueSpan;

    label.appendChild(labelText);
    label.appendChild(valueSpan);

    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = String(config.min);
    slider.max = String(config.max);
    slider.step = String(config.step);
    slider.value = String(settings[name]);
    slider.style.cssText = 'width:100%;';
    sliders[name] = slider;

    slider.addEventListener('input', () => {
      const val = clampSetting(name, slider.value);
      valueSpan.textContent = formatValue(name, val);
      _onChange(name, val);
    });

    row.appendChild(label);
    row.appendChild(slider);
    panel.appendChild(row);
  }

  // Button click toggles panel; swap icon between ☰ and ✕
  gearButton.addEventListener('click', () => {
    settings.panelOpen = !settings.panelOpen;
    settings.panelTimer = 0;
    panel.style.display = settings.panelOpen ? 'block' : 'none';
    gearButton.textContent = settings.panelOpen ? '\u2715' : '\u2630';
  });

  // Escape closes panel
  const onKeydown = (e) => {
    if (e.key === 'Escape') {
      settings.panelOpen = false;
      panel.style.display = 'none';
      gearButton.textContent = '\u2630';
    }
  };
  document.addEventListener('keydown', onKeydown);

  return {
    gearButton,
    panel,
    sliders,
    valueDisplays,
    selects,
    checkboxes,
    directionSelect: selects.starDirection,
    set onChange(fn) {
      _onChange = fn;
    },
    get onChange() {
      return _onChange;
    },
    destroy() {
      document.removeEventListener('keydown', onKeydown);
    },
  };
}

// ===== ship.js =====
/**
 * Ship size constant (half-height of the chevron shape).
 * Used for rendering and later for collision radius.
 */
const SHIP_SIZE = 15;

/** Rotation speed in radians per second. */
const ROTATION_SPEED = 4.0;

/** Thrust acceleration in pixels/s². */
const THRUST_POWER = 2000;

/** Drag coefficient per second (mild friction). */
const DRAG = 0.5;

/** Braking deceleration in pixels/s². */
const BRAKE_POWER = 200;

/** Maximum ship speed in pixels/s. */
const MAX_SPEED = 400;

/** Maximum number of trail points (~4 seconds at 60 fps). */
const TRAIL_MAX_LENGTH = 240;

/** Opacity of the newest coasting trail segment. */
const TRAIL_BASE_OPACITY = 0.2;

/** Opacity of the newest thrust trail segment. */
const TRAIL_THRUST_OPACITY = 0.6;

/** Line width for coasting trail segments. */
const TRAIL_BASE_WIDTH = 1;

/** Line width for thrust trail segments. */
const TRAIL_THRUST_WIDTH = 2.5;

/** Engine spool rate — thrust intensity ramp speed (per second). Full transition ~0.17s. */
const THRUST_RAMP_SPEED = 6.0;

/** Blue exhaust color (Rebel / player). */
const PLAYER_TRAIL_COLOR = { r: 80, g: 140, b: 255 };

/** Red exhaust color (Empire / enemy). */
const ENEMY_TRAIL_COLOR = { r: 255, g: 50, b: 30 };

/** Dark red ship stroke for enemy. */
const ENEMY_SHIP_COLOR = '#CC3333';

/**
 * Normalize an angle to the range [-PI, PI].
 */
function normalizeAngle(angle) {
  while (angle > Math.PI) angle -= 2 * Math.PI;
  while (angle < -Math.PI) angle += 2 * Math.PI;
  return angle;
}

/**
 * Create a ship entity.
 */
function createShip({ x, y, heading, owner = 'player' }) {
  return {
    x,
    y,
    vx: 0,
    vy: 0,
    heading,
    alive: true,
    thrust: false,
    rotatingLeft: false,
    rotatingRight: false,
    braking: false,
    fire: false,
    thrustIntensity: 0,
    fireCooldown: 0,
    collisionRadius: SHIP_SIZE,
    owner,
  };
}

/**
 * Update ship state for one frame.
 * Applies rotation, thrust, braking, drag, speed cap, and position update.
 */
function updateShip(ship, dt) {
  // 1. Rotation
  if (ship.rotatingLeft) ship.heading -= ROTATION_SPEED * dt;
  if (ship.rotatingRight) ship.heading += ROTATION_SPEED * dt;
  ship.heading = normalizeAngle(ship.heading);

  // 2. Thrust intensity ramp
  if (ship.thrust) {
    ship.thrustIntensity = Math.min(
      ship.thrustIntensity + THRUST_RAMP_SPEED * dt,
      1.0,
    );
  } else {
    ship.thrustIntensity = Math.max(
      ship.thrustIntensity - THRUST_RAMP_SPEED * dt,
      0.0,
    );
  }

  // 3. Thrust — accelerate in heading direction, scaled by intensity
  if (ship.thrustIntensity > 0) {
    const power = ship.thrustPower ?? THRUST_POWER;
    ship.vx += Math.cos(ship.heading) * power * ship.thrustIntensity * dt;
    ship.vy += Math.sin(ship.heading) * power * ship.thrustIntensity * dt;
  }

  // 4. Braking — decelerate opposite to velocity direction
  if (ship.braking) {
    const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
    if (speed > 0) {
      const decel = Math.min(BRAKE_POWER * dt, speed);
      ship.vx -= (ship.vx / speed) * decel;
      ship.vy -= (ship.vy / speed) * decel;
    }
  }

  // 5. Drag — friction always applied
  ship.vx *= 1 - DRAG * dt;
  ship.vy *= 1 - DRAG * dt;

  // 6. Speed cap
  const currentSpeed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
  if (currentSpeed > MAX_SPEED) {
    ship.vx = (ship.vx / currentSpeed) * MAX_SPEED;
    ship.vy = (ship.vy / currentSpeed) * MAX_SPEED;
  }

  // 7. Position update
  ship.x += ship.vx * dt;
  ship.y += ship.vy * dt;
}

/**
 * Draw a classic Asteroids chevron/triangle at the ship's position,
 * rotated by its heading. White wireframe, no fill.
 */
function drawShip(ctx, ship) {
  if (!ship.alive) return;

  const s = SHIP_SIZE;

  ctx.save();
  ctx.translate(ship.x, ship.y);
  ctx.rotate(ship.heading);

  ctx.strokeStyle = ship.owner === 'enemy' ? ENEMY_SHIP_COLOR : '#FFFFFF';
  ctx.lineWidth = 1.5;

  if (ship.owner === 'enemy') {
    ctx.setLineDash([4, 4]);
  }

  // Chevron shape: nose at right (+x), two rear points, notch in back
  ctx.beginPath();
  ctx.moveTo(s, 0); // nose
  ctx.lineTo(-s, -s * 0.7); // top-left wing
  ctx.lineTo(-s * 0.5, 0); // rear notch
  ctx.lineTo(-s, s * 0.7); // bottom-left wing
  ctx.closePath();
  ctx.stroke();

  if (ship.owner === 'enemy') {
    ctx.setLineDash([]);
  }

  ctx.restore();
}

/**
 * Create a new motion trail with the given exhaust color.
 */
function createTrail(color = PLAYER_TRAIL_COLOR) {
  return { points: [], color };
}

/**
 * Record the ship's rear-nozzle position in the trail.
 * Always records a point. Stores the passed thrustIntensity per-point
 * for gradient rendering. Evicts oldest when full.
 */
function updateTrail(trail, x, y, heading, thrustIntensity) {
  const nozzleOffset = SHIP_SIZE * 0.5;
  const rearX = x - Math.cos(heading) * nozzleOffset;
  const rearY = y - Math.sin(heading) * nozzleOffset;
  trail.points.push({ x: rearX, y: rearY, intensity: thrustIntensity });
  if (trail.points.length > TRAIL_MAX_LENGTH) {
    trail.points.shift();
  }
}

/** Number of trail points to drain per second after ship death. */
const TRAIL_DRAIN_RATE = 400;

/**
 * Gradually drain the trail after the ship dies.
 * Removes points from the oldest end so the trail shrinks toward the ship.
 */
function drainTrail(trail, dt) {
  const pointsToDrain = Math.ceil(TRAIL_DRAIN_RATE * dt);
  trail.points.splice(0, Math.min(pointsToDrain, trail.points.length));
}

/**
 * Draw the exhaust trail as fading line segments.
 * Width and opacity are interpolated per-segment using the stored
 * thrust intensity (0=coasting, 1=full thrust) for smooth gradients.
 * Alpha increases linearly from 0 (oldest) to max opacity (newest).
 */
function drawTrail(ctx, trail) {
  if (trail.points.length < 2) return;

  const { r, g, b } = trail.color;
  const len = trail.points.length;

  for (let i = 1; i < len; i++) {
    const ageFactor = i / (len - 1);
    const intensity = trail.points[i].intensity;
    const maxAlpha =
      TRAIL_BASE_OPACITY +
      (TRAIL_THRUST_OPACITY - TRAIL_BASE_OPACITY) * intensity;
    const alpha = ageFactor * maxAlpha;
    ctx.lineWidth =
      TRAIL_BASE_WIDTH + (TRAIL_THRUST_WIDTH - TRAIL_BASE_WIDTH) * intensity;
    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
    ctx.beginPath();
    ctx.moveTo(trail.points[i - 1].x, trail.points[i - 1].y);
    ctx.lineTo(trail.points[i].x, trail.points[i].y);
    ctx.stroke();
  }
}

// ===== simulation.js =====

const SPAWN_BORDER = 300; // px, width of border ring
const RECYCLE_MARGIN = 5; // px, hysteresis beyond spawn bounds
const MAX_SPAWN_PER_FRAME = 10; // cap spawns per frame
const BASE_EDGE_WEIGHT = 100; // min weight per edge (prevents starvation)

/**
 * Expand viewport bounds by SPAWN_BORDER on each side to get spawn bounds.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @returns {object} - { minX, maxX, minY, maxY }
 */
function computeSpawnBounds(viewportBounds) {
  return {
    minX: viewportBounds.minX - SPAWN_BORDER,
    maxX: viewportBounds.maxX + SPAWN_BORDER,
    minY: viewportBounds.minY - SPAWN_BORDER,
    maxY: viewportBounds.maxY + SPAWN_BORDER,
  };
}

/**
 * Compute direction-biased edge selection weights from ship velocity.
 * Edge outward normals: left=(-1,0), right=(+1,0), top=(0,-1), bottom=(0,+1)
 * weight[edge] = max(dot(shipVelocity, edgeOutward), 0) + BASE_EDGE_WEIGHT
 * Normalized to sum to 1.0.
 * @param {number} shipVx
 * @param {number} shipVy
 * @returns {number[]} - [left, right, top, bottom] weights summing to 1.0
 */
function computeEdgeWeights(shipVx, shipVy) {
  const raw = [
    Math.max(-shipVx, 0) + BASE_EDGE_WEIGHT, // left: outward = (-1, 0)
    Math.max(shipVx, 0) + BASE_EDGE_WEIGHT, // right: outward = (+1, 0)
    Math.max(-shipVy, 0) + BASE_EDGE_WEIGHT, // top: outward = (0, -1)
    Math.max(shipVy, 0) + BASE_EDGE_WEIGHT, // bottom: outward = (0, +1)
  ];
  const total = raw[0] + raw[1] + raw[2] + raw[3];
  return [raw[0] / total, raw[1] / total, raw[2] / total, raw[3] / total];
}

/**
 * Pick an edge using cumulative weighted random selection.
 * @param {number[]} weights - [left, right, top, bottom] summing to 1.0
 * @returns {number} - 0=left, 1=right, 2=top, 3=bottom
 */
function pickWeightedEdge(weights) {
  const r = Math.random();
  let cumulative = 0;
  for (let i = 0; i < 3; i++) {
    cumulative += weights[i];
    if (r < cumulative) return i;
  }
  return 3;
}

/**
 * Pick a random size class with the spec distribution:
 * ~20% large (50–80), ~40% medium (25–49), ~40% small (10–24)
 */
function randomRadius() {
  const roll = Math.random();
  if (roll < 0.2) return 50 + Math.random() * 30;
  if (roll < 0.6) return 25 + Math.random() * 24;
  return 10 + Math.random() * 14;
}

/**
 * Get speed range for a given radius.
 * Large (50–80): 15–30 px/s, Medium (25–49): 30–60 px/s, Small (10–24): 60–120 px/s
 */
function speedForRadius(radius) {
  if (radius >= 50) return 15 + Math.random() * 15;
  if (radius >= 25) return 30 + Math.random() * 30;
  return 60 + Math.random() * 60;
}

/**
 * Check if an asteroid is outside the spawn zone (past spawn bounds + recycle margin).
 * @param {object} asteroid
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @returns {boolean}
 */
function isOutsideZone(asteroid, spawnBounds) {
  const { x, y, radius } = asteroid;
  return (
    x + radius + RECYCLE_MARGIN < spawnBounds.minX ||
    x - radius - RECYCLE_MARGIN > spawnBounds.maxX ||
    y + radius + RECYCLE_MARGIN < spawnBounds.minY ||
    y - radius - RECYCLE_MARGIN > spawnBounds.maxY
  );
}

/**
 * Spawn a new asteroid in the border ring (outside viewport, inside spawn bounds).
 * Uses direction-biased edge selection and aims roughly toward viewport center.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @param {number[]} edgeWeights - [left, right, top, bottom]
 * @param {number} speedMultiplier
 * @returns {object} asteroid
 */
function spawnAsteroidInBorder(
  viewportBounds,
  spawnBounds,
  edgeWeights,
  speedMultiplier = 1.0,
) {
  const radius = randomRadius();
  const speed = speedForRadius(radius) * speedMultiplier;
  const edge = pickWeightedEdge(edgeWeights);

  const vpCenterX = (viewportBounds.minX + viewportBounds.maxX) / 2;
  const vpCenterY = (viewportBounds.minY + viewportBounds.maxY) / 2;

  let x, y;

  switch (edge) {
    case 0: // left border: between spawnBounds.minX and viewportBounds.minX
      x =
        spawnBounds.minX +
        Math.random() * (viewportBounds.minX - spawnBounds.minX);
      y =
        spawnBounds.minY +
        Math.random() * (spawnBounds.maxY - spawnBounds.minY);
      break;
    case 1: // right border: between viewportBounds.maxX and spawnBounds.maxX
      x =
        viewportBounds.maxX +
        Math.random() * (spawnBounds.maxX - viewportBounds.maxX);
      y =
        spawnBounds.minY +
        Math.random() * (spawnBounds.maxY - spawnBounds.minY);
      break;
    case 2: // top border: between spawnBounds.minY and viewportBounds.minY
      x =
        spawnBounds.minX +
        Math.random() * (spawnBounds.maxX - spawnBounds.minX);
      y =
        spawnBounds.minY +
        Math.random() * (viewportBounds.minY - spawnBounds.minY);
      break;
    default: // bottom border: between viewportBounds.maxY and spawnBounds.maxY
      x =
        spawnBounds.minX +
        Math.random() * (spawnBounds.maxX - spawnBounds.minX);
      y =
        viewportBounds.maxY +
        Math.random() * (spawnBounds.maxY - viewportBounds.maxY);
      break;
  }

  // Aim toward viewport center with ±30° spread
  const baseAngle = Math.atan2(vpCenterY - y, vpCenterX - x);
  const spread = (Math.random() * 2 - 1) * (Math.PI / 6);
  const angle = baseAngle + spread;

  return createAsteroid({
    x,
    y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius,
  });
}

/**
 * Spawn a new asteroid at a random position within the full zone (spawn bounds),
 * with a random direction. Used for initial population.
 * @param {object} spawnBounds - { minX, maxX, minY, maxY }
 * @param {number} speedMultiplier
 * @returns {object} asteroid
 */
function spawnAsteroidInZone(spawnBounds, speedMultiplier = 1.0) {
  const radius = randomRadius();
  const speed = speedForRadius(radius) * speedMultiplier;
  const x =
    spawnBounds.minX + Math.random() * (spawnBounds.maxX - spawnBounds.minX);
  const y =
    spawnBounds.minY + Math.random() * (spawnBounds.maxY - spawnBounds.minY);
  const angle = Math.random() * Math.PI * 2;

  return createAsteroid({
    x,
    y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed,
    radius,
  });
}

/**
 * Create the simulation state with an initial population of asteroids.
 * Asteroids are distributed across the entire zone (viewport + border) for
 * immediate visibility and pre-populated border.
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {number} targetCount
 */
function createSimulation(viewportBounds, targetCount = 20) {
  const spawnBounds = computeSpawnBounds(viewportBounds);
  const asteroids = [];
  for (let i = 0; i < targetCount; i++) {
    asteroids.push(spawnAsteroidInZone(spawnBounds));
  }

  const baselineKEPerAsteroid = computeTotalKE(asteroids) / asteroids.length;

  return {
    asteroids,
    targetCount,
    baselineKEPerAsteroid,
  };
}

/**
 * Update the simulation: move asteroids, resolve collisions, recycle outside zone,
 * spawn in border when below target with direction-biased edge selection.
 * @param {object} sim
 * @param {number} dt
 * @param {object} viewportBounds - { minX, maxX, minY, maxY }
 * @param {number} shipVx - ship x velocity for direction bias
 * @param {number} shipVy - ship y velocity for direction bias
 */
function updateSimulation(
  sim,
  dt,
  viewportBounds,
  shipVx = 0,
  shipVy = 0,
) {
  // Move all asteroids
  for (const a of sim.asteroids) {
    updateAsteroid(a, dt);
  }

  // Detect and resolve collisions
  const pairs = detectCollisions(sim.asteroids);
  for (const [a, b] of pairs) {
    separateOverlap(a, b);
    resolveCollision(a, b);
  }

  // Compute spawn bounds and remove asteroids outside zone
  const spawnBounds = computeSpawnBounds(viewportBounds);
  sim.asteroids = sim.asteroids.filter((a) => !isOutsideZone(a, spawnBounds));

  // Compute energy boost
  const boost = computeSpeedBoost(
    sim.baselineKEPerAsteroid,
    sim.targetCount,
    sim.asteroids,
  );

  // Compute direction-biased edge weights
  const edgeWeights = computeEdgeWeights(shipVx, shipVy);

  // Spawn in border when below target
  const deficit = sim.targetCount - sim.asteroids.length;
  const toSpawn = Math.min(Math.max(deficit, 0), MAX_SPAWN_PER_FRAME);
  for (let i = 0; i < toSpawn; i++) {
    sim.asteroids.push(
      spawnAsteroidInBorder(viewportBounds, spawnBounds, edgeWeights, boost),
    );
  }
}

// ===== starfield.js =====
/**
 * Create a single star with random position, size, and brightness.
 */
function createStar(canvasWidth, canvasHeight, options = {}) {
  const minSize = options.minSize ?? 1;
  const maxSize = options.maxSize ?? 2;
  const minBrightness = options.minBrightness ?? 0.3;
  const maxBrightness = options.maxBrightness ?? 1.0;

  const brightness =
    minBrightness + Math.random() * (maxBrightness - minBrightness);

  const star = {
    x: Math.random() * canvasWidth,
    y: Math.random() * canvasHeight,
    size: minSize + Math.random() * (maxSize - minSize),
    brightness,
  };

  if (options.twinkle) {
    star.twinklePhase = Math.random() * Math.PI * 2;
    star.twinkleFreq = 0.3 + Math.random() * 2.7; // 0.3–3.0 Hz
    star.twinkleAmplitude = brightness * (0.1 + Math.random() * 0.2); // 10–30% of base
  }

  return star;
}

/**
 * Create a star layer: a collection of stars that scroll together at a given speed.
 */
function createStarLayer(
  count,
  canvasWidth,
  canvasHeight,
  options = {},
) {
  const stars = [];
  for (let i = 0; i < count; i++) {
    stars.push(createStar(canvasWidth, canvasHeight, options));
  }
  return {
    stars,
    speed: options.speed ?? 10,
  };
}

/**
 * Update a star layer: move all stars leftward by speed * dt.
 * Stars that exit the left edge wrap to the right edge with a new random y.
 */
function updateStarLayer(layer, dt, canvasWidth, canvasHeight) {
  const dx = layer.speed * dt;
  for (const star of layer.stars) {
    star.x -= dx;
    if (star.x < 0) {
      star.x = canvasWidth + star.x;
      star.y = Math.random() * canvasHeight;
    }
  }
}

/**
 * Compute the effective brightness of a star at a given elapsed time.
 * Stars without twinkle properties return their base brightness.
 * Formula: base + amplitude * sin(time * freq * 2π + phase), clamped to [0, 1].
 */
function applyTwinkle(star, elapsedTime) {
  if (star.twinklePhase == null) return star.brightness;
  const value =
    star.brightness +
    star.twinkleAmplitude *
      Math.sin(
        elapsedTime * star.twinkleFreq * Math.PI * 2 + star.twinklePhase,
      );
  return Math.min(1.0, Math.max(0, value));
}

// Layer presets for the default 3-layer parallax (far, mid, near).
// Base star counts are calibrated for 1920×1080; scaled by canvas area ratio.
const LAYER_PRESETS = [
  {
    baseCount: 100,
    minSize: 1,
    maxSize: 1,
    minBrightness: 0.3,
    maxBrightness: 0.5,
    minSpeed: 2,
    maxSpeed: 5,
  },
  {
    baseCount: 60,
    minSize: 1,
    maxSize: 2,
    minBrightness: 0.5,
    maxBrightness: 0.7,
    minSpeed: 8,
    maxSpeed: 15,
  },
  {
    baseCount: 30,
    minSize: 2,
    maxSize: 3,
    minBrightness: 0.7,
    maxBrightness: 1.0,
    minSpeed: 20,
    maxSpeed: 35,
  },
];

/**
 * Linearly interpolate between a and b by factor t (0–1).
 */
function lerp(a, b, t) {
  return a + (b - a) * t;
}

/**
 * Create parallax star layers. Default is 3 (far, mid, near).
 * Extra layers interpolate properties between far and near presets.
 */
function createParallaxLayers(
  canvasWidth,
  canvasHeight,
  layerCount = 3,
) {
  const baseArea = 1920 * 1080;
  const areaRatio = (canvasWidth * canvasHeight) / baseArea;
  const far = LAYER_PRESETS[0];
  const near = LAYER_PRESETS[2];

  const layers = [];
  for (let i = 0; i < layerCount; i++) {
    const t = layerCount === 1 ? 0 : i / (layerCount - 1);

    let preset;
    if (layerCount === 3 && i < 3) {
      preset = LAYER_PRESETS[i];
    } else {
      preset = {
        baseCount: Math.round(lerp(far.baseCount, near.baseCount, t)),
        minSize: lerp(far.minSize, near.minSize, t),
        maxSize: lerp(far.maxSize, near.maxSize, t),
        minBrightness: lerp(far.minBrightness, near.minBrightness, t),
        maxBrightness: lerp(far.maxBrightness, near.maxBrightness, t),
        minSpeed: lerp(far.minSpeed, near.minSpeed, t),
        maxSpeed: lerp(far.maxSpeed, near.maxSpeed, t),
      };
    }

    const count = Math.max(1, Math.round(preset.baseCount * areaRatio));
    // Use midpoint of speed range for interpolated layers to guarantee monotonic ordering;
    // the 3-layer preset path already has non-overlapping ranges so random is fine there.
    const speed =
      layerCount === 3 && i < 3
        ? preset.minSpeed + Math.random() * (preset.maxSpeed - preset.minSpeed)
        : (preset.minSpeed + preset.maxSpeed) / 2;

    const isNearLayer = i === layerCount - 1 && layerCount > 1;

    layers.push(
      createStarLayer(count, canvasWidth, canvasHeight, {
        speed,
        minSize: preset.minSize,
        maxSize: preset.maxSize,
        minBrightness: preset.minBrightness,
        maxBrightness: preset.maxBrightness,
        twinkle: !isNearLayer,
      }),
    );
  }
  return layers;
}

/**
 * Update a star layer with a configurable direction.
 * Directions: 'left', 'right', 'up', 'down', 'radial'.
 */
function updateStarLayerDirectional(
  layer,
  dt,
  canvasWidth,
  canvasHeight,
  direction,
) {
  const baseDelta = layer.speed * dt;
  if (baseDelta === 0) return;

  const cx = canvasWidth / 2;
  const cy = canvasHeight / 2;
  // Reference distance for perspective scaling (half the shorter dimension)
  const refDist = Math.min(canvasWidth, canvasHeight) / 2;

  for (const star of layer.stars) {
    if (direction === 'radial') {
      let dx = star.x - cx;
      let dy = star.y - cy;
      const dist = Math.hypot(dx, dy);

      if (dist < 0.01) {
        // Star at exact center — assign a random angle to push it outward
        const angle = Math.random() * Math.PI * 2;
        dx = Math.cos(angle);
        dy = Math.sin(angle);
      } else {
        dx /= dist;
        dy /= dist;
      }

      // Perspective acceleration: speed scales with distance from center
      const speedFactor = Math.max(dist / refDist, 0.05);
      star.x += dx * baseDelta * speedFactor;
      star.y += dy * baseDelta * speedFactor;

      // Brightness fades in with distance from center
      const newDist = Math.hypot(star.x - cx, star.y - cy);
      star.radialBrightness = Math.min(newDist / refDist, 1.0);

      // Recycle if outside canvas
      if (
        star.x < 0 ||
        star.x > canvasWidth ||
        star.y < 0 ||
        star.y > canvasHeight
      ) {
        const angle = Math.random() * Math.PI * 2;
        const spawnDist = 5 + Math.random() * 25;
        star.x = cx + Math.cos(angle) * spawnDist;
        star.y = cy + Math.sin(angle) * spawnDist;
        star.radialBrightness = spawnDist / refDist;
      }
    } else {
      // Clear radialBrightness when not in radial mode
      delete star.radialBrightness;

      if (direction === 'right') {
        star.x += baseDelta;
        if (star.x > canvasWidth) {
          star.x = star.x - canvasWidth;
          star.y = Math.random() * canvasHeight;
        }
      } else if (direction === 'up') {
        star.y -= baseDelta;
        if (star.y < 0) {
          star.y = canvasHeight + star.y;
          star.x = Math.random() * canvasWidth;
        }
      } else if (direction === 'down') {
        star.y += baseDelta;
        if (star.y > canvasHeight) {
          star.y = star.y - canvasHeight;
          star.x = Math.random() * canvasWidth;
        }
      } else {
        // 'left' (default)
        star.x -= baseDelta;
        if (star.x < 0) {
          star.x = canvasWidth + star.x;
          star.y = Math.random() * canvasHeight;
        }
      }
    }
  }
}

/**
 * Redistribute all stars across layers for a new direction mode.
 * Call when the user switches direction to avoid visual artifacts
 * (e.g. stars clustered at center after leaving radial mode).
 */
function redistributeStars(
  layers,
  canvasWidth,
  canvasHeight,
  direction,
) {
  const cx = canvasWidth / 2;
  const cy = canvasHeight / 2;
  const refDist = Math.min(canvasWidth, canvasHeight) / 2;

  for (const layer of layers) {
    for (const star of layer.stars) {
      if (direction === 'radial') {
        const angle = Math.random() * Math.PI * 2;
        const maxDist = Math.hypot(cx, cy);
        const dist = Math.random() * maxDist;
        star.x = cx + Math.cos(angle) * dist;
        star.y = cy + Math.sin(angle) * dist;
        star.radialBrightness = Math.min(dist / refDist, 1.0);
      } else {
        star.x = Math.random() * canvasWidth;
        star.y = Math.random() * canvasHeight;
        delete star.radialBrightness;
      }
    }
  }
}

/**
 * Parallax scaling factor for camera-relative star movement.
 * Keeps star drift speeds comparable to directional scroll speeds.
 */
const CAMERA_PARALLAX_SCALE = 0.1;

/**
 * Update star layers based on camera movement deltas (screen-space).
 * Stars shift opposite to camera motion with per-layer depth parallax.
 * Camera rotation rotates stars around the screen center.
 *
 * @param {Array} layers - Star layers from createParallaxLayers
 * @param {number} screenDx - Camera delta X in screen space (pre-rotated)
 * @param {number} screenDy - Camera delta Y in screen space (pre-rotated)
 * @param {number} deltaRotation - Camera rotation delta (radians)
 * @param {number} viewportW - Viewport width
 * @param {number} viewportH - Viewport height
 */
function updateStarLayersCamera(
  layers,
  screenDx,
  screenDy,
  deltaRotation,
  viewportW,
  viewportH,
) {
  if (layers.length === 0) return;
  const maxSpeed = Math.max(...layers.map((l) => l.speed));
  if (maxSpeed === 0) return;

  const noMovement = screenDx === 0 && screenDy === 0 && deltaRotation === 0;
  const cx = viewportW / 2;
  const cy = viewportH / 2;

  for (const layer of layers) {
    const depth = (layer.speed / maxSpeed) * CAMERA_PARALLAX_SCALE;

    const shiftX = -screenDx * depth;
    const shiftY = -screenDy * depth;

    const rotAngle = -deltaRotation * depth;
    const cosR = Math.cos(rotAngle);
    const sinR = Math.sin(rotAngle);

    for (const star of layer.stars) {
      delete star.radialBrightness;

      if (noMovement) continue;

      if (rotAngle !== 0) {
        const dx = star.x - cx;
        const dy = star.y - cy;
        star.x = cx + dx * cosR - dy * sinR;
        star.y = cy + dx * sinR + dy * cosR;
      }

      star.x += shiftX;
      star.y += shiftY;

      star.x = ((star.x % viewportW) + viewportW) % viewportW;
      star.y = ((star.y % viewportH) + viewportH) % viewportH;
    }
  }
}

/**
 * Update all parallax layers.
 */
function updateParallaxLayers(layers, dt, canvasWidth, canvasHeight) {
  for (const layer of layers) {
    updateStarLayer(layer, dt, canvasWidth, canvasHeight);
  }
}

/**
 * Draw all parallax layers (far to near, back to front).
 */
function drawParallaxLayers(ctx, layers, elapsedTime = 0) {
  for (const layer of layers) {
    drawStarLayer(ctx, layer, elapsedTime);
  }
}

/**
 * Draw a star layer onto a canvas 2D context.
 */
function drawStarLayer(ctx, layer, elapsedTime = 0) {
  for (const star of layer.stars) {
    let brightness = applyTwinkle(star, elapsedTime);
    if (star.radialBrightness != null) {
      brightness *= star.radialBrightness;
    }
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
    ctx.fillRect(star.x, star.y, star.size, star.size);
  }
}


startApp();
</script>
</body>
</html>
