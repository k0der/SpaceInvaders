<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asteroid Screensaver </title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
// ===== main.js =====

/**
 * Calculate delta time in seconds between two timestamps (ms).
 * Caps at 0.1s to avoid spiral-of-death after tab backgrounding.
 * Never returns negative values.
 */
function calculateDeltaTime(currentTimestamp, previousTimestamp) {
  const dtSeconds = (currentTimestamp - previousTimestamp) / 1000;
  return Math.min(Math.max(dtSeconds, 0), 0.1);
}

/**
 * Create an animation loop state object.
 * Call loop.tick(timestamp) each frame from requestAnimationFrame.
 * First tick returns dt=0 (no previous frame to diff against).
 */
function createLoop() {
  let started = false;

  const state = {
    frameCount: 0,
    lastTimestamp: 0,

    tick(timestamp) {
      let dt = 0;
      if (started) {
        dt = calculateDeltaTime(timestamp, state.lastTimestamp);
      }
      started = true;
      state.lastTimestamp = timestamp;
      state.frameCount++;
      return dt;
    },
  };
  return state;
}

/**
 * Bootstrap the application: set up canvas, resize handling, and start the loop.
 */
function startApp() {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  const loop = createLoop();
  const starLayers = createParallaxLayers(canvas.width, canvas.height);

  function frame(timestamp) {
    const dt = loop.tick(timestamp);

    updateParallaxLayers(starLayers, dt, canvas.width, canvas.height);

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawParallaxLayers(ctx, starLayers);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

// ===== starfield.js =====
/**
 * Create a single star with random position, size, and brightness.
 */
function createStar(canvasWidth, canvasHeight, options = {}) {
  const minSize = options.minSize ?? 1;
  const maxSize = options.maxSize ?? 2;
  const minBrightness = options.minBrightness ?? 0.3;
  const maxBrightness = options.maxBrightness ?? 1.0;

  return {
    x: Math.random() * canvasWidth,
    y: Math.random() * canvasHeight,
    size: minSize + Math.random() * (maxSize - minSize),
    brightness: minBrightness + Math.random() * (maxBrightness - minBrightness),
  };
}

/**
 * Create a star layer: a collection of stars that scroll together at a given speed.
 */
function createStarLayer(count, canvasWidth, canvasHeight, options = {}) {
  const stars = [];
  for (let i = 0; i < count; i++) {
    stars.push(createStar(canvasWidth, canvasHeight, options));
  }
  return {
    stars,
    speed: options.speed ?? 10,
  };
}

/**
 * Update a star layer: move all stars leftward by speed * dt.
 * Stars that exit the left edge wrap to the right edge with a new random y.
 */
function updateStarLayer(layer, dt, canvasWidth, canvasHeight) {
  const dx = layer.speed * dt;
  for (const star of layer.stars) {
    star.x -= dx;
    if (star.x < 0) {
      star.x = canvasWidth + star.x;
      star.y = Math.random() * canvasHeight;
    }
  }
}

// Layer presets for the default 3-layer parallax (far, mid, near).
// Base star counts are calibrated for 1920×1080; scaled by canvas area ratio.
const LAYER_PRESETS = [
  { baseCount: 100, minSize: 1, maxSize: 1, minBrightness: 0.3, maxBrightness: 0.5, minSpeed: 2, maxSpeed: 5 },
  { baseCount: 60,  minSize: 1, maxSize: 2, minBrightness: 0.5, maxBrightness: 0.7, minSpeed: 8, maxSpeed: 15 },
  { baseCount: 30,  minSize: 2, maxSize: 3, minBrightness: 0.7, maxBrightness: 1.0, minSpeed: 20, maxSpeed: 35 },
];

/**
 * Linearly interpolate between a and b by factor t (0–1).
 */
function lerp(a, b, t) {
  return a + (b - a) * t;
}

/**
 * Create parallax star layers. Default is 3 (far, mid, near).
 * Extra layers interpolate properties between far and near presets.
 */
function createParallaxLayers(canvasWidth, canvasHeight, layerCount = 3) {
  const baseArea = 1920 * 1080;
  const areaRatio = (canvasWidth * canvasHeight) / baseArea;
  const far = LAYER_PRESETS[0];
  const near = LAYER_PRESETS[2];

  const layers = [];
  for (let i = 0; i < layerCount; i++) {
    const t = layerCount === 1 ? 0 : i / (layerCount - 1);

    let preset;
    if (layerCount === 3 && i < 3) {
      preset = LAYER_PRESETS[i];
    } else {
      preset = {
        baseCount: Math.round(lerp(far.baseCount, near.baseCount, t)),
        minSize: lerp(far.minSize, near.minSize, t),
        maxSize: lerp(far.maxSize, near.maxSize, t),
        minBrightness: lerp(far.minBrightness, near.minBrightness, t),
        maxBrightness: lerp(far.maxBrightness, near.maxBrightness, t),
        minSpeed: lerp(far.minSpeed, near.minSpeed, t),
        maxSpeed: lerp(far.maxSpeed, near.maxSpeed, t),
      };
    }

    const count = Math.max(1, Math.round(preset.baseCount * areaRatio));
    const speed = preset.minSpeed + Math.random() * (preset.maxSpeed - preset.minSpeed);

    layers.push(createStarLayer(count, canvasWidth, canvasHeight, {
      speed,
      minSize: preset.minSize,
      maxSize: preset.maxSize,
      minBrightness: preset.minBrightness,
      maxBrightness: preset.maxBrightness,
    }));
  }
  return layers;
}

/**
 * Update all parallax layers.
 */
function updateParallaxLayers(layers, dt, canvasWidth, canvasHeight) {
  for (const layer of layers) {
    updateStarLayer(layer, dt, canvasWidth, canvasHeight);
  }
}

/**
 * Draw all parallax layers (far to near, back to front).
 */
function drawParallaxLayers(ctx, layers) {
  for (const layer of layers) {
    drawStarLayer(ctx, layer);
  }
}

/**
 * Draw a star layer onto a canvas 2D context.
 */
function drawStarLayer(ctx, layer) {
  for (const star of layer.stars) {
    ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
    ctx.fillRect(
      Math.round(star.x),
      Math.round(star.y),
      star.size,
      star.size,
    );
  }
}


startApp();
</script>
</body>
</html>
