# Space Dogfight — Technical Specification

## Overview

A Star Wars-style dogfighting game built on top of a physics-driven asteroid field.
Two ships (player + AI enemy) fight among drifting, colliding asteroids. The player
ship is fixed at screen center with the world rotating around it — classic Asteroids
controls with Newtonian physics. The same asteroid field serves triple duty: combat
arena, AI-vs-AI screensaver, or classic asteroid screensaver (ships off).

## Technology

- **Single HTML file** (`index.html`) containing all HTML, CSS, and JavaScript
- **HTML5 Canvas 2D** for rendering
- **Zero dependencies** — vanilla JS, opens in any modern browser
- **No build step** required

## Development Process

- **Trunk-based development**: all work lands on `main` — no long-lived feature branches
- **TDD**: write failing tests (RED) → implement until green (GREEN) → refactor
- **Coverage audit**: before committing each increment, explicitly map every acceptance criterion to its test(s) and fill gaps
- **Build**: `node build.js` inlines ES modules from `src/` into a standalone `index.html`
- **Code quality**: follow SOLID principles and clean-code style — small focused functions, single responsibility, descriptive names, no magic numbers, code that is highly maintainable and testable
- **Mandatory human review**: At the end of every iteration, **stop and wait for the human developer to review and manually test** the implementation before proceeding. Do not start the next iteration until the human gives explicit approval. This is not optional.
- **Final test coverage review**: When development of an iteration is complete and all tests are passing, review the code for missing test coverage and add any needed tests before presenting the iteration for human review.

## Visual Style

- **Black background**, white vector-style line art for asteroids and player ship
- **No fill** on asteroids — wireframe outlines only (1–2px stroke)
- Aesthetic: vector graphics with Star Wars-inspired faction colors
- **Player**: white wireframe, blue exhaust trail and explosion (Rebel)
- **Enemy**: dark red wireframe (`#CC3333`) with dashed lines, red exhaust trail and explosion (Empire)
- No textures, no gradients

---

## 1. Asteroids

### 1.1 Shape Generation

Each asteroid is a **randomly generated irregular polygon**:

- Vertex count: 8–14 vertices per asteroid
- Generated by walking around a circle in equal angular steps, with each vertex
  displaced radially by a random factor (0.6–1.0 of the base radius)
- Every asteroid is unique
- Shapes are generated once at spawn time and cached as a vertex list

### 1.2 Size Classes

Three size tiers with continuous variation within each:

| Class  | Radius Range (px) | Stroke Width |
|--------|-------------------|--------------|
| Large  | 50–80             | 2.0 px       |
| Medium | 25–49             | 1.5 px       |
| Small  | 10–24             | 1.0 px       |

Distribution: ~20% large, ~40% medium, ~40% small.

### 1.3 Movement

- Each asteroid has a **velocity vector** `(vx, vy)` assigned at spawn
- **Bigger asteroids move slower**: base speed is inversely proportional to radius
  - Large: 15–30 px/s
  - Medium: 30–60 px/s
  - Small: 60–120 px/s
- All speeds are multiplied by the user-configurable **speed multiplier** (default 1.0)
- Movement is frame-rate independent using delta-time

### 1.4 Rotation

- Each asteroid has a **constant angular velocity** assigned at spawn
- Rotation speed: random value between -0.5 and +0.5 radians/second
- Larger asteroids rotate more slowly (scaled inversely to radius)
- Rotation is purely visual; collision uses a bounding circle

### 1.5 Spawning & Despawning

All spawning and despawning uses a **three-zone architecture** relative to the
camera viewport, creating an infinite asteroid field where the viewport is always
populated and asteroids never appear out of thin air.

**Three zones**:

```
+------------------------------------------------------+
|                OUTSIDE (recycle immediately)          |
|    +------------------------------------------+      |
|    |       SPAWN BORDER (300px ring)          |      |
|    |  (new asteroids appear here at runtime)  |      |
|    |    +--------------------------------+    |      |
|    |    |        VIEWPORT (AABB)         |    |      |
|    |    |   (what the player sees)       |    |      |
|    |    +--------------------------------+    |      |
|    +------------------------------------------+      |
+------------------------------------------------------+
```

- **Viewport bounds**: tight AABB of rotated viewport (no padding)
- **Spawn bounds**: viewport bounds expanded by `SPAWN_BORDER` (300px) on each side
- **Outside**: anything beyond spawn bounds → remove immediately

**Rules**:

- **Initial population**: At startup, asteroids are spawned across the entire
  zone (viewport + border) using random positions and directions, for immediate
  visibility
- **Runtime spawning**: New asteroids spawn ONLY in the border ring (never inside
  the viewport), aimed roughly toward the viewport center with ±30° spread
- **Direction bias**: Spawning is biased toward the ship's movement direction.
  Edge weights are computed as `max(dot(shipVelocity, edgeOutward), 0) + BASE_EDGE_WEIGHT`.
  The forward edge gets ~60% of spawns at full speed; all edges get ≥12.5%
- **No stagger**: Border spawns are invisible to the player, so clustering doesn't
  matter. Up to `MAX_SPAWN_PER_FRAME` (10) asteroids spawn per frame when below target
- **Aggressive recycling**: Any asteroid outside the spawn bounds (+ 5px hysteresis)
  is removed immediately
- **Target count**: `BASE_COUNT (40) × density_setting × (zoneArea / viewportArea)`.
  The area ratio ensures both viewport and border are populated proportionally

### 1.6 Energy Homeostasis

The open boundary preferentially removes fast, light asteroids (they exit the
screen sooner after collisions), gradually draining the system's kinetic energy.
To compensate, the spawner acts as a feedback-controlled energy pump:

- At initialization, the average kinetic energy per asteroid is recorded as the
  baseline (KE = 0.5 × collisionRadius² × speed²)
- When spawning a replacement, the current total system KE is compared to the
  target (baseline × target count)
- If the system is below target, the spawn speed is boosted by
  `sqrt(targetKE / actualKE)`, capped at 1.5×
- If the system is at or above target, spawns use normal spec speeds
- This keeps the asteroid field's energy level constant indefinitely, regardless
  of collision history

---

## 2. Collision Physics

### 2.1 Detection

- **Circle-circle collision** using each asteroid's **effective collision radius**
- The collision radius is computed from the actual generated shape: the average vertex
  distance from center. This gives a tighter fit than the bounding radius, so asteroids
  only collide when their visible surfaces are close to touching.
- Check every pair each frame (with spatial optimization if needed for high counts)
- A collision is detected when `distance(centerA, centerB) < collisionRadiusA + collisionRadiusB`

### 2.2 Response — Elastic Collision

- Collisions are **fully elastic** (conserve kinetic energy and momentum)
- Mass is proportional to `radius^2` (area, simulating 2D mass)
- On collision:
  1. Separate overlapping asteroids so they no longer intersect
  2. Calculate new velocities using the 2D elastic collision formula:
     - `v1' = v1 - (2*m2/(m1+m2)) * dot(v1-v2, x1-x2) / |x1-x2|^2 * (x1-x2)`
     - `v2' = v2 - (2*m1/(m1+m2)) * dot(v2-v1, x2-x1) / |x2-x1|^2 * (x2-x1)`
  3. Apply a slight random perturbation (±2%) to post-collision velocities to
     prevent perfectly repeating patterns
- **Result**: small asteroids ricochet dramatically off large ones; two large
  asteroids gently nudge each other

---

## 3. Starfield Background

### 3.1 Parallax Layers

- Minimum **3 layers** of stars (configurable: 3–6 layers via settings)
- Each layer scrolls at a different speed to create depth:

| Layer | Dot Size  | Brightness   | Scroll Speed     | Star Count   |
|-------|-----------|--------------|------------------|--------------|
| Far   | 1 px      | 30–50% white | 2–5 px/s         | ~100 stars   |
| Mid   | 1–2 px    | 50–70% white | 8–15 px/s        | ~60 stars    |
| Near  | 2–3 px    | 70–100% white| 20–35 px/s       | ~30 stars    |

- Intermediate layers (if user adds more) interpolate between these values
- Stars scroll in a configurable direction (default: left, suggesting the
  "camera" is panning right through space)

#### Direction Modes

The star field direction is user-configurable with 5 modes:

- **left** (default): Stars drift leftward. Camera pans right through space.
- **right**: Stars drift rightward. Camera pans left.
- **up**: Stars drift upward. Camera descends.
- **down**: Stars drift downward. Camera ascends.
- **radial**: Stars emanate from the screen center outward in all directions,
  creating a "traveling through hyperspace" effect (like the Star Wars jump to
  lightspeed). Key properties:
  - **Perspective acceleration**: speed scales with distance from center —
    stars creep slowly near the center and accelerate toward the edges
  - **Brightness fade-in**: stars are dim near the center (far away) and
    brighten as they fly outward (closer to the viewer)
  - Stars respawn at a small offset from center (5–30px), not at the exact
    center point, so they emerge subtly rather than popping into view
  - Parallax is preserved — near-layer stars fly outward faster than far-layer
    stars

#### Camera-Relative Parallax Mode

When ships are active, the starfield switches from directional scrolling to
**camera-relative parallax**. Stars shift based on camera movement deltas
rather than a fixed direction:

- **Per-layer depth**: `depth = layer.speed / maxLayerSpeed`, scaled by
  `CAMERA_PARALLAX_SCALE` (0.1). Near stars shift more than far stars.
- **Translation**: Stars shift opposite to camera movement in screen space.
  `main.js` pre-rotates world-space camera deltas into screen space before
  passing them to the starfield function.
- **Rotation**: Camera rotation rotates stars around the screen center.
  Near stars rotate more than far stars: `rotAngle = -deltaRotation * depth`.
- **Wrapping**: Stars wrap at viewport edges using modulo arithmetic.
- **Directional modes preserved**: The existing direction modes
  (`left`/`right`/`up`/`down`/`radial`) remain available for a future
  ships-off screensaver mode.

### 3.2 Twinkling

- Each star has a **base brightness** and a **twinkle phase** (random offset)
- Brightness oscillates sinusoidally: `brightness = base + amplitude * sin(time * frequency + phase)`
- Twinkle amplitude: 10–30% of base brightness (wider range for visual variety)
- Twinkle frequency: 0.3–3.0 Hz (wide range so stars feel independent, not synchronized)
- Phases must be well-distributed across the full cycle to avoid clusters of stars pulsing together
- The overall effect should look organic and natural — like real stars — not like a synchronized Christmas tree
- Only the far and mid layers twinkle; near-layer stars are steady

### 3.3 Star Recycling

- **Linear modes** (left/right/up/down): Stars that scroll off the exit edge
  are repositioned at the opposite (entry) edge with a new random position on
  the perpendicular axis
- **Radial mode**: Stars that exit any screen edge respawn at a small offset
  from center (5–30px) with a new random outward angle and dim brightness
- Star positions are initialized randomly across the full canvas at startup
- **Direction change**: When the user switches direction, all stars are
  redistributed randomly for the new mode — linear modes scatter across
  the full canvas, radial mode distributes at various distances from center
  with brightness matching distance

---

## 4. Render Pipeline

### 4.1 Draw Order (back to front)

1. Clear canvas to **black** (`#000000`)
2. Draw **star layers** (far to near)
3. Draw **asteroids** (no particular z-order needed — they're all in the same plane)

### 4.2 Asteroid Rendering

- `ctx.strokeStyle = '#FFFFFF'`
- `ctx.lineWidth` per size class (see table in 1.2)
- Draw using `beginPath()` → `moveTo()` → `lineTo()` loop → `closePath()` → `stroke()`
- Apply rotation via `ctx.translate(x, y)` → `ctx.rotate(angle)`

### 4.3 Performance

- Target: **60 FPS** on modern hardware
- Use `requestAnimationFrame` for the main loop
- Delta-time based updates (no fixed timestep)
- Canvas resolution matches `window.innerWidth * devicePixelRatio` for crisp lines
  on HiDPI displays

---

## 5. Settings Menu

### 5.1 Trigger & Appearance

- **Hamburger menu icon** (☰) in the top-left corner
- Icon is semi-transparent (30% opacity) and brightens on hover (80%)
- Clicking the icon opens a **translucent overlay panel** (dark background, ~80% opacity)
- Panel slides in from the left edge; icon swaps to a close symbol (✕)
- When panel is open, the close icon stays at full visibility (80% opacity)
- Panel **auto-hides after 4 seconds** of no mouse movement over it
- Menu icon auto-hides after 3 seconds of no mouse movement anywhere, reappears on
  mouse move
- Pressing **Escape** also closes the panel

### 5.2 Controls

| Setting              | Control  | Range                          | Default | Step |
|----------------------|----------|--------------------------------|---------|------|
| Asteroid Density     | Slider   | 0.0x – 3.0x                   | 1.0x    | 0.1  |
| Speed Multiplier     | Slider   | 0.2 – 3.0                     | 1.0     | 0.1  |
| Star Parallax Layers | Slider   | 3 – 6                         | 3       | 1    |
| Thrust Power         | Slider   | 1000 – 5000                       | 2000    | 50   |
| Star Field Direction | Select   | left / right / up / down / radial | left    | —    |
| Player Intelligence  | Select   | human / reactive / predictive     | human      | —  |
| Enemy Intelligence   | Select   | reactive / predictive             | predictive | —  |
| AI Debug Log         | Checkbox | on / off                          | off        | —  |

- Each slider shows its **current value** as a label
- Changes are applied **immediately** (live preview)
- Asteroid density is a multiplier on the base count (40). The actual target
  count is computed dynamically each frame as `40 × density × (boundsArea / viewportArea)`.
  Reducing density lets excess asteroids drift off naturally; increasing it
  triggers burst spawning to repopulate.
- Settings are persisted to `localStorage` so they survive page reload

### 5.3 Visual Style of Menu

- Monochrome to match the aesthetic — white text, white slider tracks on dark panel
- Font: system monospace (`'Courier New', monospace`)
- Minimal, clean layout

---

## 6. Responsive Behavior

- Canvas fills the **entire browser viewport** (`100vw x 100vh`)
- On window resize:
  - Canvas dimensions update immediately
  - Existing asteroids continue on their current trajectories
  - **Stars are redistributed** across the new canvas dimensions for the
    current direction mode (prevents clustering or off-screen stars after
    mobile screen rotation)
  - Star counts adjust proportionally to new area on next recycle
- No scrollbars, no overflow — `body { margin: 0; overflow: hidden; }`
- Works on both desktop and mobile (touch triggers gear icon visibility)

---

## 7. Animation Loop Summary

Each frame (`requestAnimationFrame` callback):

```
1. Calculate deltaTime
2. Update input state
3. Apply input to player ship (keyboard when playerIntelligence='human', AI otherwise)
4. Update AI for enemy ship (and player ship when playerIntelligence is non-human)
5. Update ships (physics: thrust, drag, brake, rotation, position)
6. Update camera (follow player ship)
7. Update stars:
   a. Camera-relative parallax shift (when ships active)
   b. Update twinkle phase
   c. Wrap off-screen stars
8. Update asteroids:
   a. Move each by velocity * dt
   b. Rotate each by angular velocity * dt
   c. Detect and resolve asteroid collisions
   d. Remove asteroids outside spawn bounds (aggressive recycling)
   e. Spawn in border ring when below target (up to 10/frame, direction-biased)
9. Update bullets (move, expire)
10. Check bullet-asteroid collisions (remove blocked bullets)
11. Check bullet-ship collisions
12. Check ship-asteroid collisions
13. Update game state (phase transitions, explosions)
14. Render:
    a. Clear canvas
    b. Draw star layers (screen-space)
    c. Apply camera transform
    d. Draw asteroids
    e. Draw ships + flames
    f. Draw bullets
    g. Reset camera transform
    h. Draw end screen overlay + HUD (win/lose/draw text)
    i. Draw settings menu icon (if visible)
```

*(When a future `'off'` mode is added, steps 2–6, 10–14 would be skipped and the
camera would stay at origin with no rotation. The starfield would use directional
scroll mode instead of camera-relative.)*

---

## 8. File Structure

```
SpaceInvaders/
  src/
    main.js         ← entry point, integration, animation loop
    asteroid.js     ← asteroid entity (shape, rendering, movement)
    starfield.js    ← parallax star layers
    simulation.js   ← asteroid spawn/despawn, population management
    physics.js      ← collision detection and elastic response
    energy.js       ← kinetic energy computation and homeostasis
    settings.js     ← settings menu UI and persistence
    renderer.js     ← HiDPI canvas setup
    ship.js         ← ship entity: creation, Newtonian physics, rendering
    input.js        ← keyboard state tracking (WASD + arrows + space)
    camera.js       ← camera state, canvas transform, viewport bounds
    bullet.js       ← bullet entity: creation, movement, lifetime
    ai-core.js      ← pluggable AI strategy registry
    ai-predictive.js ← predictive AI: trajectory simulation
    ai-reactive.js  ← reactive AI: pursuit, combat, obstacle avoidance
    ai-predictive-optimized.js ← predictive AI clone for autonomous optimization
    ai.js           ← AI facade: registers strategies, re-exports for compat
    ai-neural.js    ← neural AI: ONNX inference, control flag mapping
    debug.js        ← AI debug logging (console telemetry, rate-limited)
    game.js         ← game state: phases, bullet-ship collisions, explosions
    observation.js  ← shared observation builder (ego-centric vectors)
    reward.js       ← configurable dense reward function for training
    game-env.js     ← GameEnv class: gym-style reset/step interface
  simulate.js       ← headless simulation harness (CLI, no browser)
  models/
    policy.onnx     ← trained neural model weights (not in git)
  training/
    env.py          ← Gymnasium wrapper (spawns Node.js bridge)
    train.py        ← PPO training script with curriculum stages
    export_onnx.py  ← export PyTorch model to ONNX format
    config.yaml     ← curriculum stage definitions and hyperparameters
    dashboard.html  ← live training dashboard (Chart.js, auto-refresh)
    logs/           ← JSONL training logs + dashboard data (not in git)
  test/             ← Vitest test files (one per module)
  dev.html          ← development entry point (ES module imports)
  index.html        ← production build (single file, all JS inlined)
  build.js          ← custom bundler (strips imports, inlines into index.html)
  SPEC.md           ← this specification
  TODO.md           ← incremental build plan with acceptance criteria
  CLAUDE.md         ← agent instructions and workflow rules
```

Development uses ES modules in `src/` for testability. `node build.js` (or `npm run build`)
produces a standalone `index.html` with all modules inlined — zero external dependencies.

---

## 9. Ships

### 9.1 Ship Entity

- Ships are classic Asteroids chevron/triangle wireframes, no fill
- Player ship: white stroke (`#FFFFFF`); enemy ship: dark red stroke (`#CC3333`)
- Each ship has: `x, y, vx, vy, heading, alive, thrustIntensity`, control booleans (`thrust, rotatingLeft, rotatingRight, braking, fire`), a `collisionRadius`, and an `owner` field (`'player'` or `'enemy'`)
- `owner` field determines visual style (stroke color, solid vs dashed lines) and is used for bullet collision filtering in later increments
- Ships use **Newtonian physics**: thrust accelerates in heading direction, drag always applies, braking decelerates opposite to velocity
- **Thrust ramp**: `thrustIntensity` (0.0–1.0) ramps toward 1.0 when thrusting and toward 0.0 when coasting, at `THRUST_RAMP_SPEED` per second. Thrust force is proportional: `THRUST_POWER * thrustIntensity * dt`. This means the engine spools up/down smoothly rather than snapping to full power.
- Speed capped at `MAX_SPEED`; a `MIN_SPEED` ensures the ship always drifts forward gently
- Constants: `THRUST_POWER`, `THRUST_RAMP_SPEED`, `DRAG`, `BRAKE_POWER`, `ROTATION_SPEED`, `MAX_SPEED`, `MIN_SPEED`

### 9.2 Controls

- **Classic Asteroids**: W/Up = thrust, A/Left = rotate left, D/Right = rotate right, S/Down = brake, Space = fire
- Case-insensitive key mapping
- Escape still opens/closes settings (no conflict)

### 9.3 Ship Rendering

- Player: white wireframe chevron (`strokeStyle = '#FFFFFF'`), `lineWidth ~1.5`
- Enemy: dark red wireframe (`strokeStyle = '#CC3333'`), dashed line pattern (`ctx.setLineDash([4, 4])`)
- Canvas state saved/restored (no transform leak)
- When thrusting, a flickering engine flame (randomized triangle) drawn behind the ship
- Ship `owner` field (`'player'` or `'enemy'`) determines stroke color, dash pattern, and collision filtering

### 9.4 Exhaust Trail

A fading rocket-exhaust trail behind each ship reinforces the sense of
speed and gives throttle feedback. The trail is drawn in **world space**
(inside the camera transform), so it drifts and rotates relative to the
screen-locked ship — providing a strong local motion cue.

- **Origin**: Trail points start at the ship's rear nozzle, not the center.
  Offset from `(x, y)` by `-cos(heading) * SHIP_SIZE * 0.5` in x and
  `-sin(heading) * SHIP_SIZE * 0.5` in y.
- **Always-on**: Points are recorded every frame. Each point stores the
  ship's current `thrustIntensity` float (0.0–1.0) for per-segment rendering.
- **Reads ship intensity directly**: The trail has no independent ramp state.
  `updateTrail` receives the ship's `thrustIntensity` value and stores it
  per-point. The ramp lives in the ship physics model (see §9.1).
- **Throttle feedback**: Width and opacity are interpolated per-segment
  between coasting and thrust values using the stored intensity:
  `width = BASE + (THRUST - BASE) * intensity`,
  `maxAlpha = BASE_OPACITY + (THRUST_OPACITY - BASE_OPACITY) * intensity`.
- **Data**: Ring buffer of recent nozzle positions
  (`{ x, y, intensity }`), max `TRAIL_MAX_LENGTH` entries
  (240 — ~4 seconds at 60 fps)
- **Per-ship color**: Each trail stores its own color. Player exhaust is
  blue (`rgb(80, 140, 255)`) and enemy exhaust is red (`rgb(255, 50, 30)`),
  evoking Star Wars faction colors. `createTrail(color)` accepts an RGB
  object; defaults to player blue.
- **Rendering**: Drawn as consecutive line segments with linearly
  decreasing alpha. Maximum opacity and width are interpolated per-segment
  using the point's `intensity`. Drawn inside camera transform, before
  the ship body.
- **Constants**: `TRAIL_MAX_LENGTH = 240`, `TRAIL_BASE_OPACITY = 0.2`,
  `TRAIL_THRUST_OPACITY = 0.6`, `TRAIL_BASE_WIDTH = 1`,
  `TRAIL_THRUST_WIDTH = 2.5`,
  `PLAYER_TRAIL_COLOR = { r: 80, g: 140, b: 255 }`,
  `ENEMY_TRAIL_COLOR = { r: 255, g: 50, b: 30 }`,
  `ENEMY_SHIP_COLOR = '#CC3333'`

---

## 10. Camera

### 10.1 Camera Transform

The camera follows the player ship, locking it at screen center. The world rotates
around the player — the ship always points "up" on screen.

Applied as a **canvas context transform** (not per-entity coordinate conversion):

```
ctx.save();
ctx.translate(viewportW / 2, viewportH / 2);  // screen center
ctx.rotate(-camera.rotation);                   // world rotates opposite to camera
ctx.translate(-camera.x, -camera.y);            // offset by camera world position
// ... draw all world-space entities ...
ctx.restore();
```

This means existing draw functions (e.g., `drawAsteroid`) work **unchanged** — they
already translate to their entity's `(x, y)`, and the camera transform is already on
the context.

### 10.2 Render Pipeline (with camera)

1. Clear canvas to black
2. Draw starfield (screen-space, before camera transform)
3. Apply camera transform
4. Draw asteroids (world-space)
5. Draw ship motion trails (world-space, behind ships)
6. Draw ships (world-space — player maps to screen center)
7. Draw bullets (world-space)
8. Reset camera transform
9. Draw end screen overlay + HUD text (screen-space, terminal phases only)
10. Draw settings menu icon

### 10.3 Viewport Bounds

`getViewportBounds(camera, viewportW, viewportH, margin)` returns the axis-aligned
bounding box (AABB) of the rotated viewport in world-space, with an optional padding
margin (default 0). The simulation computes its own spawn bounds from the tight
viewport AABB.

---

## 11. Bullets

- Created at ship's nose position, traveling at `BULLET_SPEED` in heading direction plus ship velocity (inherit momentum)
- Move linearly, tracked by `age`; expire after `BULLET_LIFETIME` (~2s)
- Rendered as small bright dots or short lines
- Fire rate limited by `FIRE_COOLDOWN` (~0.2s between shots)
- Bullets are **blocked by asteroids** — a bullet that contacts an asteroid (circle-circle: bullet position within asteroid's `collisionRadius`) is destroyed (removed), but the asteroid is unaffected (keeps drifting)
- `owner` field tracks which ship fired the bullet (for collision filtering)
- A ship's own bullets cannot hit itself

---

## 12. AI

### 12.1 AI Steering

- AI controls a ship using the same physics as the player (same thrust, drag, max speed)
- AI sets the same 5 control flags as keyboard input — the ship physics engine
  treats AI and player identically
- **Target prediction**: AI aims at where the target *will* be, not where it is:
  - `lookAheadTime = min(distance / PREDICTION_SPEED, MAX_PREDICTION_TIME)`
  - `predicted = target.pos + target.vel * lookAheadTime`
- **Rotation**: Turns toward predicted position with a small dead zone
  (`ROTATION_DEADZONE` ~0.05 rad / ~3°) to prevent oscillation
- **Thrust**: Engages when heading is within `THRUST_ANGLE` (~60°) of
  target direction — creates natural arcing pursuit paths
- **Brake**: Engages when NOT facing target AND speed exceeds
  `BRAKE_SPEED` — kills wrong-direction momentum after overshooting
- **State object**: `createAIState()` returns internal decision state
  (minimal for basic pursuit, expanded for combat/avoidance in later increments)
- **Constants** (exported from `ai.js`):
  `ROTATION_DEADZONE`, `THRUST_ANGLE`, `BRAKE_SPEED`,
  `PREDICTION_SPEED`, `MAX_PREDICTION_TIME`,
  `MIN_SPAWN_DISTANCE` (1000px), `MAX_SPAWN_DISTANCE` (1100px)

### 12.2 AI Combat

- AI sets `fire = true` when heading difference to predicted target is within
  `FIRE_ANGLE` (~0.15 rad / ~8.6°) AND distance to target < `MAX_FIRE_RANGE` (500px)
- Does not fire when either ship is dead (already handled by dead-ship guard)
- Fire cooldown handled identically to player — in `main.js`, not in `ai.js`.
  The AI module only sets the flag; `main.js` checks cooldown and creates bullets
- AI bullets use same `createBullet` with `owner: 'enemy'` and same physics

### 12.3 AI Obstacle Avoidance

Avoidance uses a **look-ahead cylinder** projected along the AI ship's
**predicted velocity** direction. The system avoids both asteroids and the
target ship (ramming is a mutual kill).

**Predicted velocity**: In Newtonian physics, the ship's heading and velocity
can differ significantly (the ship drifts due to momentum). A heading-based
look-ahead misses obstacles the ship is drifting toward sideways. The fix:
compute a predicted velocity that accounts for both current momentum and
current thrust input:

```
predictedVx = vx + cos(heading) * thrustPower * thrustIntensity * AVOID_PREDICT_TIME
predictedVy = vy + sin(heading) * thrustPower * thrustIntensity * AVOID_PREDICT_TIME
```

- **Coasting**: predicted direction ≈ current velocity (pure momentum)
- **Thrusting**: predicted direction shifts toward heading (where thrust is pushing)
- **Stationary** (speed < 1): falls back to heading direction as a safe default
- `AVOID_PREDICT_TIME` (0.3s) controls how far ahead to predict velocity change

**Algorithm** — `computeAvoidanceOffset(aiShip, obstacles)`:

1. Compute predicted velocity direction from current velocity + thrust input
2. For each obstacle `{ x, y, radius }`, compute the vector from AI to obstacle
3. Project onto predicted velocity axis → `ahead` (forward distance) and
   perpendicular axis → `lateral` (side distance)
4. **Threat detection** — two complementary methods per obstacle:
   - **Cylinder threat**: `ahead > 0`, `ahead < AVOID_LOOKAHEAD` (800px),
     `|lateral| < obstacle.radius + AVOID_MARGIN` (50px buffer).
     Urgency = `1 - ahead / AVOID_LOOKAHEAD`
   - **Proximity threat**: `distance < obstacle.radius + AVOID_PROXIMITY` (80px).
     Urgency = `1 - distance / proximityRadius`
   - Final urgency = `max(cylinderUrgency, proximityUrgency)` (linear — gives
     strong medium-range response so the AI reacts early, not just at close range)
5. For each threatening obstacle, compute a lateral steering offset:
   - Direction: perpendicular to predicted velocity, pushing away from obstacle
   - Strength: `AVOID_STRENGTH (2.5 rad) * urgency`
   - When lateral ≈ 0 (dead center), default to steering right to break symmetry
   - Proximity-only threats (not in cylinder) use angle-to-obstacle for steer direction
6. Sum all offsets → total `avoidanceOffset` (radians)

**Survival-first priority blending**:

Avoidance takes priority over pursuit — the AI's first objective is surviving,
and only pursues when safe. This prevents pursuit from pulling the AI through
obstacles.

- `computeAvoidanceOffset` returns both the steering offset and the maximum
  raw urgency across all threatening obstacles
- The pursuit component of heading is scaled down proportionally to threat:
  `pursuitInfluence = pursuitDiff * (1 - survivalWeight)`, where
  `survivalWeight = clamp(maxUrgency * AVOIDANCE_PRIORITY, 0, 1)`
- `AVOIDANCE_PRIORITY` (2) controls how aggressively pursuit is suppressed:
  at urgency ≈ 0.5 (moderate threat), pursuit is fully suppressed
- Final heading diff: `pursuitInfluence + avoidanceOffset`
- At zero threat: pure pursuit (survivalWeight = 0)
- At moderate+ threat: pure avoidance (survivalWeight = 1)
- Thrust is maintained when avoidance is active — the AI needs speed to
  curve around obstacles (braking removes dodge agility in Newtonian physics)
- Braking is suppressed during avoidance (only engages during pure pursuit
  when not facing target and no obstacles are threatening)
- Firing decision uses raw pursuit heading diff (unaffected by avoidance)

**Obstacle list** (built in `updateAI`):

- All asteroids → `{ x, y, radius: collisionRadius }`
- Target ship is **not** included — the AI's goal is to approach and shoot
  the target, not avoid it. Anti-ramming comes from bullet combat.

**Constants** (exported from `ai-reactive.js`):
`FIRE_ANGLE`, `MAX_FIRE_RANGE`, `AVOID_LOOKAHEAD` (800px), `AVOID_MARGIN` (50px),
`AVOID_STRENGTH` (2.5 rad), `AVOID_PROXIMITY` (80px), `AVOID_PREDICT_TIME` (0.3s),
`AVOIDANCE_PRIORITY` (2)

### 12.4 Pluggable AI Architecture

AI strategies are **pluggable** — different algorithms can be registered, swapped
at runtime via a settings dropdown, and compared side by side.

**Strategy interface** — every strategy exports an object with two methods:

```js
{
  createState()                                    → {}    // per-ship opaque state
  update(state, ship, target, asteroids, dt)        → void  // sets 5 control flags
}
```

- `createState()` returns an opaque state object for per-ship bookkeeping
- `update()` receives the ship, target, asteroids, and delta time, and sets
  the ship's 5 control flags (`thrust`, `rotatingLeft`, `rotatingRight`,
  `braking`, `fire`) — identical to how keyboard input works

**Strategy registry** (`ai-core.js`):

- `registerStrategy(name, strategy)` — registers a named strategy
- `getStrategy(name)` — returns a registered strategy by name
- `listStrategies()` — returns all registered strategy names

**Module structure**:

| Module | Role |
|--------|------|
| `ai-core.js` | Strategy registry (register, get, list) |
| `ai-reactive.js` | Reactive AI — the original pursuit/avoidance algorithm (§12.1–12.3) |
| `ai-predictive.js` | Predictive AI — trajectory simulation (§12.5) |
| `ai-predictive-optimized.js` | Predictive-Optimized AI — autonomous optimization clone (§12.7) |
| `ai.js` | Facade — registers strategies, re-exports for backward compatibility |

The `ai.js` facade imports both strategies, registers them, and re-exports
`spawnEnemyPosition`, `getStrategy`, `listStrategies`, and the reactive AI
functions for backward compatibility with existing code.

**Settings**: Per-ship intelligence dropdowns (see §14). `enemyIntelligence`
controls the enemy AI strategy; `playerIntelligence` controls whether the
player ship uses keyboard input or an AI strategy. Changing either dropdown
resets that ship's AI state. Persisted to `localStorage`.

### 12.5 Predictive AI (Trajectory Simulation)

The predictive AI uses **trajectory simulation** to choose the best action
each frame, instead of reactive rules.

**Algorithm** — each frame:

1. **Generate 9 candidate actions**:
   - **7 fixed-action candidates**: thrust+straight, thrust+left, thrust+right,
     coast+straight, coast+left, coast+right, brake — each applies a single
     action for the full simulation window
   - **Dynamic pursuit candidate**: adapts each step — rotates toward predicted
     target, thrusts when facing within 60°, brakes when not facing and speed > 50
   - **Brake-pursuit candidate**: brakes for `BRAKE_PURSUIT_STEPS` steps to kill
     bad momentum, then pursues. Only evaluated when ship speed > 50 px/s to
     prevent degenerate coast behavior when stationary
2. **Simulate forward ~1.5s** (15 steps × 0.1s) for each candidate:
   - Clone the AI ship's physics-relevant fields
   - Apply the candidate's control flags to the clone (dynamic candidates
     recompute controls each step using `simulatePursuitTrajectory`)
   - Run `updateShip()` physics for each step
   - Predict asteroid positions linearly: `pos + vel * t`
   - Check for collisions at each step
3. **Score each trajectory** (5 components):
   - **Time-decayed collision penalty**: Only the first collision counts
     (ship would be dead). Penalty = `COLLISION_BASE_PENALTY * e^(-COLLISION_DECAY * step)`.
     Early collisions penalize far more than distant-future ones.
   - **Distance to target**: `DISTANCE_WEIGHT * minDist` across the trajectory
     (minimum distance, not final step — rewards any close approach)
   - **Average aim bonus**: `AIM_BONUS * mean(cos(angleDiff))` averaged across
     all trajectory steps. Averaging avoids the "crossover artifact" where a
     ship passing through the target gets a negative aim reading at the single
     crossover point, despite being well-aimed for most of the trajectory.
   - **Approach rate**: `CLOSING_SPEED_WEIGHT * (initialDist - finalDist) / simTime`.
     Measures net distance closed rather than instantaneous velocity at a single
     point, making it immune to "overshoot terror" where passing through the
     target produces a massive negative closing speed.
   - **Fire opportunity bonus**: For each step aimed within `FIRE_ANGLE` and within
     `MAX_FIRE_RANGE`, adds `FIRE_OPPORTUNITY_BONUS * (1 - dist/MAX_FIRE_RANGE)`.
     Proximity scaling ensures close shots score higher, breaking circular orbits
     while not rewarding standing still at max range.
4. **Pick the best-scoring action** and apply its control flags to the real ship.
   For dynamic candidates, only the first step's action is applied (the AI
   re-evaluates every frame).
5. **Fire decision**: separate snap decision based on current aim geometry
   (same `FIRE_ANGLE` + `MAX_FIRE_RANGE` check as reactive AI)

**Performance**: 9 candidates × 15 steps × ~30 asteroids = ~4,050 distance
checks per frame. Trivial on modern hardware.

**Pure functions** (all testable without simulation state):

- `cloneShipForSim(ship)` — copies physics-relevant fields only
- `predictAsteroidAt(asteroid, t)` — linear extrapolation of position
- `defineCandidates()` — returns 7 fixed-action objects with control flag combos
- `simulateTrajectory(clone, action, steps, dt)` — runs physics forward with a fixed action
- `simulatePursuitTrajectory(clone, target, steps, dt, brakeSteps)` — runs physics
  forward with adaptive pursuit (rotates toward target each step)
- `scoreTrajectory(positions, target, asteroids, simDt)` — 5-component composite scoring
- `selectBestAction(ship, target, asteroids)` — orchestrator (evaluates all 9 candidates)

**Constants** (exported from `ai-predictive.js`):
`SIM_STEPS` (15), `SIM_DT` (0.1s), `COLLISION_BASE_PENALTY` (-10000),
`COLLISION_DECAY` (0.4), `DISTANCE_WEIGHT` (-8), `AIM_BONUS` (400),
`CLOSING_SPEED_WEIGHT` (8), `FIRE_OPPORTUNITY_BONUS` (300),
`BRAKE_PURSUIT_STEPS` (5)

### 12.6 AI Debug Logging

Structured telemetry output to the browser console for diagnosing AI behavior.
Toggled via a settings checkbox (default: off). Zero performance cost when disabled
— all logging functions are no-ops when the logger is not enabled.

**Activation**:

- Settings checkbox "AI Debug Log" (default off), persisted to `localStorage`
- Also accessible via `window.aiDebug.enable()` / `window.aiDebug.disable()`
  for quick toggling from the browser console

**Score capture** (`ai-predictive.js`):

- `selectBestAction` populates a module-level debug info object with all
  candidate names, scores, and the winner name
- `getLastDebugInfo()` exported — returns the last captured debug info
  (or `null` if no decision has been made yet)

**Debug logger** (`debug.js`):

- `createDebugLogger()` — returns a logger instance with `enable()`,
  `disable()`, `isEnabled()`, `logAIFrame(elapsed, enemy, player, debugInfo)`,
  and `logEvent(elapsed, type, data)`
- `logAIFrame` is rate-limited to every 0.5s, but always logs immediately
  on action change (detects when the formatted action string differs from
  the previous frame)
- `logEvent` always logs immediately (for fire, collision events)
- `fmtAction(ship)` — format helper that converts ship control flags to a
  compact 4-character string: `T` (thrust), `L` (left), `R` (right), `B` (brake),
  `_` for inactive. Example: `{ thrust: true, rotatingRight: true }` → `"T_R_"`
- When disabled: all functions are no-ops (zero cost)

**Log format**:

- Periodic: `[AI 1.20s] dist=342 action=T___ spd=180 hdg=0.50 pos=(100,-200) | T___:3090 TL__:-3299 T_R_:-3299 ____:-1900 _L__:-3219 __R_:-3219 ___B:-1900 PUR:3261 BRK:4010`
- Action change: `[AI 1.50s] CHANGE T___ → __RB dist=45`
- Fire event: `[FIRE 1.60s] enemy dist=180 angle=0.08`

**Main loop integration** (`main.js`):

- After AI update: calls `logAIFrame` with ship states + `getLastDebugInfo()`
- On bullet creation: calls `logEvent`

### 12.7 Predictive-Optimized AI

Experimental clone of the predictive AI (§12.5) designed for autonomous
iterative optimization. A separate development context runs a loop:

1. Run headless simulator with verbose logging
2. Analyze logs — identify behavioral problems and improvement opportunities
3. Write failing tests (RED) that specify the desired behavior
4. Modify `ai-predictive-optimized.js` to make tests pass (GREEN)
5. Repeat

**Decoupling guarantee**: `ai-predictive-optimized.js` duplicates all constants
locally (including `FIRE_ANGLE` and `MAX_FIRE_RANGE` which the original
predictive AI imports from `ai-reactive.js`). Changes to the optimized
variant cannot affect the original reactive, predictive, or any other module.
The only shared dependencies are `THRUST_POWER`, `SHIP_SIZE`, `updateShip`
from `ship.js`, `fmtAction` from `debug.js`, and `registerStrategy` from
`ai-core.js` (all stable infrastructure).

**Module**: `src/ai-predictive-optimized.js` — starts as a verbatim copy of
`ai-predictive.js` with renamed exports (`predictiveOptimizedStrategy`,
`createPredictiveOptimizedState`, `updatePredictiveOptimizedAI`).

**Registration**: The module self-registers as `'predictive-optimized'` in the
strategy registry at import time. `ai.js` triggers this via a bare
side-effect import (`import './ai-predictive-optimized.js'`). In the
production build, the module is wrapped in an IIFE to prevent name
collisions with the original predictive constants. Selectable via
Player/Enemy intelligence dropdowns.

**Tests**: `test/ai-predictive-optimized.test.js` — independent copy of the
predictive test suite, pointing at the optimized module. Can diverge freely as
the algorithm evolves.

---

## 13. Game State

### 13.1 Phases

- `'playing'` → `'ending'` (grace period) → `'playerWin'` / `'playerDead'` / `'draw'`
- First death triggers `'ending'` phase with a 1-second grace period (matches explosion duration)
- During grace period: collisions remain active (anti-kamikaze — stray bullets or asteroids can still kill the survivor)
- After grace period resolves to terminal phase based on who is alive:
  - Only enemy dead → `'playerWin'`
  - Only player dead → `'playerDead'`
  - Both dead → `'draw'`
- Terminal states are sticky (no transition back)
- On player death: camera freezes at death position
- On enemy death: camera continues following player
- Controls are disabled during terminal phases (ship stops responding to input)

### 13.2 Ship-Asteroid Collision

- Circle-circle collision using ship's `collisionRadius`
- Ship dies on asteroid contact (same death + explosion as bullet death)
- Applies to both player and enemy
- Asteroids are unaffected (keep drifting)

### 13.3 Bullet-Ship Collision

- `checkBulletShipHit(bullet, ship)`: point-circle test, `distance < ship.collisionRadius`
- Player bullets hit enemy only; enemy bullets hit player only (filtered by `owner`)
- One bullet = one kill → `ship.alive = false`
- Dead ships cannot be hit again
- `processBulletShipCollisions(bullets, playerShip, enemyShip)` returns `{ bullets, playerHit, enemyHit }` — pure function, caller handles death side effects

### 13.4 Explosion Effect

- Dual concentric expanding wireframe circles (outer + inner at 50% radius)
- Inner ring is slightly brighter than outer for depth
- Faction-colored: player explosion uses blue trail color `rgb(80, 140, 255)`, enemy uses red `rgb(255, 50, 30)`
- Duration: 1.0s, max radius: 60px, alpha fades linearly from 1.0 to 0.0
- Drawn in world-space (inside camera transform)

### 13.5 Death Behavior

- Dead ships stop updating (no AI, no physics, no input)
- Dead ships stop rendering (`drawShip` early-returns on `!alive`)
- Exhaust trail drains on death: oldest points removed at `TRAIL_DRAIN_RATE` (400 pts/s), trail shrinks and vanishes over ~0.6s
- Bullet firing already guarded by `ship.alive` check

### 13.6 Game State Module (`game.js`)

- `createGameState()` → `{ phase: 'playing', explosions: [], deathTimer: 0 }`
- `updateGameState(state, playerShip, enemyShip, dt)` — state machine:
  - `'playing'`: transitions to `'ending'` on first death, sets `deathTimer = GRACE_PERIOD` (1s)
  - `'ending'`: decrements `deathTimer` by `dt`; when expired, resolves to `'playerWin'`, `'playerDead'`, or `'draw'`
  - Terminal states (`'playerWin'`, `'playerDead'`, `'draw'`): no transitions (sticky)
- `clearSpawnZone(asteroids, ships)` — removes asteroids within `SPAWN_SAFE_RADIUS` (45px, 3× ship size) of any ship's position; returns new array
- Explosion lifecycle: `createExplosion(x, y, color)`, `updateExplosion`, `isExplosionDone`, `drawExplosion`

### 13.7 HUD and End Screen

- Screen-space text (drawn after camera reset)
- Text rendered using a custom vector-stroke font (line segments per character) matching the wireframe aesthetic — not browser `fillText`
- Each glyph defined as polylines on a 4×6 grid; character set: A–Z, 0–9, space, basic punctuation
- Faction-colored result text:
  - `'playerWin'`: "YOU WIN" in blue (`#508CFF`)
  - `'playerDead'`: "YOU LOST" in red (`#FF321E`)
  - `'draw'`: "DRAW" in white (`#FFFFFF`)
- "PRESS SPACE" shown below the result text (50% alpha)
- HUD and overlay only appear in terminal phases (not during `'playing'` or `'ending'`)
- End screen overlay: semi-transparent black (60% opacity) drawn behind HUD text
- During terminal phases: ships, trails, and bullets are hidden; asteroids remain visible through the overlay
- Space key restarts: ships respawn, bullets cleared, spawn zones cleared of asteroids, phase resets to `'playing'`
- Enemy spawns just off-screen (1000–1100px from player) with a random heading — both ships start on equal footing

### 13.8 AI-vs-AI Auto-Restart

- When `settings.playerIntelligence !== 'human'`, the game auto-restarts 2 seconds after a terminal phase is reached
- No user input needed — allows continuous AI-vs-AI observation

---

## 14. Per-Ship Intelligence Settings

Each ship has its own intelligence dropdown in the settings panel:

| Setting | Options | Default |
|---------|---------|---------|
| `playerIntelligence` | `'human'`, `'reactive'`, `'predictive'`, `'predictive-optimized'` | `'human'` |
| `enemyIntelligence` | `'reactive'`, `'predictive'`, `'predictive-optimized'` | `'predictive'` |

- When `playerIntelligence = 'human'`: keyboard controls player (current behavior)
- When `playerIntelligence = 'reactive'` or `'predictive'`: AI controls player ship, keyboard ignored
- Camera always follows the player ship (even when AI-controlled)
- Both settings persisted to `localStorage`
- Changing either dropdown takes effect immediately (no page reload)
- The headless simulator (§15) will set non-human values for both ships

---

## 15. Headless Simulator

A CLI-runnable simulation harness that exercises the full game logic (physics, AI,
collisions, spawning) without any browser, canvas, or rendering dependencies.
Runs at maximum CPU speed with controlled `dt`, producing structured logs and
aggregate statistics for detecting AI behavioral bugs, collision edge cases, and
balance issues at scale.

### 15.1 Architecture

The game logic is already cleanly separated from rendering:

| Layer | Modules | Browser-free? |
|-------|---------|---------------|
| Physics / AI / Collision | `ship.js`, `ai-predictive.js`, `ai-reactive.js`, `ai-core.js`, `physics.js`, `simulation.js`, `energy.js`, `bullet.js`, `asteroid.js`, `debug.js` | Yes |
| Camera (math) | `camera.js` (`createCamera`, `getViewportBounds`) | Yes |
| Rendering | `renderer.js`, `starfield.js`, draw functions, camera transforms | No (canvas) |
| Orchestration | `main.js` | No (DOM, rAF) |

The simulator replaces `main.js` with a headless loop that imports only the
browser-free modules. No stubs or mocks needed — just don't call `draw*` functions.

### 15.2 Simulation Loop

Each tick mirrors the browser's animation loop (SPEC §7), minus rendering:

1. Create ships, spawn initial asteroids (using `createSimulation`)
2. Per tick (fixed `dt`, default `1/60`):
   a. Apply AI for both ships (or input replay for player)
   b. `updateShip` for each ship
   c. Update bullets (move, expire, asteroid collisions)
   d. Check bullet-ship collisions (when implemented)
   e. Check ship-asteroid collisions (when implemented)
   f. `updateSimulation` (asteroid move, collide, recycle, spawn)
   g. Record events and frame state
3. Repeat for N ticks or until termination condition

### 15.3 Determinism

- **Fixed dt** ensures identical physics to browser at matching framerate
- All game logic uses `dt` as input, not wall-clock time
- `Math.random()` is the only source of non-determinism (asteroid shapes,
  spawn positions). A seeded PRNG can be injected for reproducible runs.
- Variable-dt robustness testing: sweep dt values (frame drops, 144Hz, 3x speed
  multiplier) to detect timing-sensitive bugs

### 15.4 Event Logging & Detectors

The simulator captures structured events and runs configurable detectors:

**Events** (per-frame or on occurrence):
- Action changes (with previous/new action, winner, scores)
- Bullet fires and hits
- Ship deaths (cause: bullet, asteroid, or none)
- Ship-asteroid proximity (near-miss tracking)
- AI score breakdowns (all candidate scores per evaluation)

**Detectors** (flag anomalies):
- **Oscillation**: action changes faster than `HOLD_TIME` → flag frame range
- **Asteroid pass-through**: ship within asteroid `collisionRadius` without death
- **Stuck states**: same action for >N seconds while target is alive
- **Orbit lock**: distance to target stable (±10%) for >N seconds
- **Score collapse**: all candidates score below threshold (no good option)

### 15.5 Aggregate Statistics

Run N games, collect:
- Win/loss ratio per AI strategy
- Average game duration
- Asteroid collision count per game
- Action distribution (% time in each action)
- Oscillation events per game
- Near-miss frequency

### 15.6 CLI Interface

```
node simulate.js                     # 100 games, default settings, summary only
node simulate.js --games 1000        # scale up
node simulate.js --ticks 3600        # 60s per game
node simulate.js --dt 0.05           # simulate 3x speed
node simulate.js --seed 42           # reproducible
node simulate.js --verbose           # per-game event log
node simulate.js --detect oscillation,passthrough  # specific detectors
node simulate.js --player-ai reactive --enemy-ai predictive  # strategy selection
node simulate.js --density 2.0       # double asteroid density
node simulate.js --speed 1.5         # 1.5x speed multiplier
node simulate.js --thrust 3000       # custom thrust power
```

Output: summary table to stdout, detailed logs to file if `--verbose`

---

## 16. Deep Reinforcement Learning

### 16.1 Overview

Third intelligence type alongside reactive and predictive. A neural network trained
via deep reinforcement learning (PPO) controls ships using the same pluggable strategy
interface (`{ createState, update }`) as the existing AI strategies.

**Architecture**:

```
Train (offline, Python)              Deploy (browser, JS)
───────────────────────              ────────────────────
Headless simulator (GameEnv)         ONNX Runtime Web (CDN)
        ↓                                   ↓
PPO (Stable Baselines3)             ai-neural.js
        ↓                           reads state → inference → 5 control flags
PyTorch model
        ↓ export
   policy.onnx (~1MB)    ────→    served as static asset alongside index.html
```

- **Training**: Python drives the headless simulator via a stdin/stdout JSON bridge.
  The simulator runs at max CPU speed with fixed dt — thousands of games per second.
- **Inference**: ONNX Runtime Web runs a single MLP forward pass (<1ms) each frame
  in the browser. Fully client-side, no backend services required.
- **Pluggable**: Registered as `'neural'` in the strategy registry. Selectable via
  the Player/Enemy intelligence dropdowns alongside `'reactive'` and `'predictive'`.

### 16.2 Observation Space

Ego-centric vector representation (~36 floats). Everything is relative to the
controlled ship's position and heading, providing translation and rotation invariance:

**Self state** (6 floats):

| Index | Feature | Range | Notes |
|-------|---------|-------|-------|
| 0 | Speed (normalized) | [0, 1] | `speed / MAX_SPEED` |
| 1 | Velocity angle relative to heading | [-1, 1] | `angleDiff / π` |
| 2 | Thrust intensity | [0, 1] | Ship's `thrustIntensity` ramp value |
| 3 | Rotation direction | {-1, 0, 1} | -1 left, 0 none, +1 right |
| 4 | Alive | {0, 1} | 1 if alive |
| 5 | Fire cooldown fraction | [0, 1] | `cooldown / FIRE_COOLDOWN` |

**Target state** (6 floats):

| Index | Feature | Range | Notes |
|-------|---------|-------|-------|
| 6 | Relative distance | [0, 1] | `dist / 1000`, clamped |
| 7 | Relative bearing | [-1, 1] | `bearing / π` (angle from heading to target) |
| 8 | Relative heading diff | [-1, 1] | `headingDiff / π` (target facing vs self) |
| 9 | Closing speed | [-1, 1] | `closingSpeed / MAX_SPEED` |
| 10 | Lateral speed | [-1, 1] | `lateralSpeed / MAX_SPEED` |
| 11 | Target alive | {0, 1} | 1 if alive |

**K nearest asteroids** (k=8, 3 floats each = 24 floats):

| Offset | Feature | Range | Notes |
|--------|---------|-------|-------|
| +0 | Relative distance | [0, 1] | `dist / 1000`, clamped |
| +1 | Relative bearing | [-1, 1] | `bearing / π` |
| +2 | Relative approach speed | [-1, 1] | `approachSpeed / 200` |

- Sorted by distance (nearest first)
- Zero-padded when fewer than k asteroids are within range
- Total observation size: 6 + 6 + 24 = **36 floats**

The observation builder is a shared pure-function module (`src/observation.js`)
used identically by both the training bridge and `ai-neural.js` in the browser.

### 16.3 Action Space

10 composite discrete movement actions mapped to the 5 control flags, plus a
separate binary fire decision:

**Movement actions** (mutually exclusive, index 0–9):

| Index | Action | thrust | rotateLeft | rotateRight | brake |
|-------|--------|--------|------------|-------------|-------|
| 0 | thrust-straight | ✓ | | | |
| 1 | thrust-left | ✓ | ✓ | | |
| 2 | thrust-right | ✓ | | ✓ | |
| 3 | coast-straight | | | | |
| 4 | coast-left | | ✓ | | |
| 5 | coast-right | | | ✓ | |
| 6 | brake-straight | | | | ✓ |
| 7 | brake-left | | ✓ | | ✓ |
| 8 | brake-right | | | ✓ | ✓ |
| 9 | no-op | | | | |

**Fire**: separate binary output (0 or 1), independent of movement. SB3's
`MultiDiscrete([10, 2])` action space produces 12 logits total: a 10-way
categorical for movement and a 2-way categorical for fire (fire/no-fire).
The ONNX export concatenates all 12 logits; browser inference splits them as
`argmax(logits[:10])` for movement and `argmax(logits[10:12])` for fire.

This two-headed structure matches the game's mechanics — movement and firing are
independent decisions made each frame.

### 16.4 Neural Strategy Module

`src/ai-neural.js` — pluggable strategy following the `{ createState, update }`
interface:

- **`createState()`**: Initializes an ONNX Runtime Web inference session, loads
  the model from `models/policy.onnx`, allocates input/output buffers. Returns
  `{ session, inputBuffer, ready }`.
- **`update(state, ship, target, asteroids, dt)`**: Builds observation vector
  via the shared `buildObservation()` → runs ONNX inference → reads movement
  action index (argmax of 10-way output) and fire probability (sigmoid output)
  → maps to the 5 control flags on the ship.
- **Network architecture**: 3 hidden layers × 256 units, ReLU activations.
  Two output heads: movement (10-way softmax) and fire (sigmoid). ~200K parameters.
- **ONNX Runtime Web**: Loaded via CDN `<script>` tag. This preserves the project's
  zero-bundled-dependency philosophy — the CDN dependency is optional and only
  needed when the `'neural'` intelligence option is selected.
- **Graceful fallback**: If no model file is available or ONNX Runtime fails to
  load, the strategy logs a console warning and delegates to the predictive strategy.

### 16.5 Training Environment (GameEnv)

A gym-style wrapper around the headless game simulation, exposing `reset()` and
`step()` methods for reinforcement learning:

- **`reset(config)`**: Initializes a new episode — spawns ships at configured
  distance and facing, populates asteroids, returns the initial observation
  (Float32Array from the observation builder).
- **`step(moveAction, fireAction)`**: Applies the agent's action (maps action
  index to control flags), ticks the simulation one step (fixed dt), updates
  the opponent via its configured policy, computes reward, checks termination
  conditions, returns `{ observation, reward, done, info }`.
- **Single-agent interface**: Only the controlled ship's actions are input.
  The opponent is part of the environment, controlled by a configurable policy
  (any registered strategy name, or `'self-play'` for a frozen policy copy).
- **HP system**: Ships track hit points (configurable, default 1 for the real game).
  Each bullet or asteroid hit decrements HP by 1. Ship dies when HP reaches 0.
  Higher HP during training provides more gradient signal per episode.
- **Episode termination**: Agent death, opponent death, or `maxTicks` reached.
- **Info dict**: `{ winner, ticksElapsed, hitsLanded, hitsTaken, asteroidsHit }`

### 16.6 Training-Mode Configuration

Episode parameters tunable per curriculum stage. These exist **only in the training
environment**, not in the shipped game:

| Parameter | Game value | Training default | Purpose |
|-----------|-----------|-----------------|---------|
| `shipHP` | 1 | 5 | More reward signal per episode — agent learns "getting hit is bad" gradually rather than instant death |
| `maxTicks` | Unlimited | 3600 (60s) | Prevents stalemate episodes from wasting compute |
| `asteroidDensity` | 1.0 | 0.0 (curriculum) | Start without obstacles, add later |
| `enemyPolicy` | N/A | `'static'` (curriculum) | `'static'` / `'reactive'` / `'predictive'` / `'self-play'` |
| `enemyShoots` | true | false (curriculum) | Disable enemy fire for early training stages |
| `spawnDistance` | 400–600 | 500 (fixed) | Consistent episode starts for stable learning |
| `spawnFacing` | Random | true | Both ships face each other — faster engagement, less wasted exploration |
| `rewardWeights` | N/A | See §16.7 | Per-component reward scaling |
| `frameSkip` | N/A | 2 | Simulate N ticks per RL step — halves IPC round-trips |
| `aiHoldTime` | 0.15 | 0.25 | Enemy AI decision interval in seconds — reduces AI compute |
| `aiSimSteps` | 15 | 10 | Enemy AI lookahead steps — reduces AI compute |

### 16.7 Reward Shaping

Dense per-step rewards accelerate learning. Sparse win/loss alone would require
orders of magnitude more episodes to learn basic behaviors.

**Per-step rewards**:

| Component | Value | Condition |
|-----------|-------|-----------|
| Survival | +0.001 | Always (while alive) |
| Aim alignment | +0.01 × cos(angle_to_target) | When distance < 600px |
| Closing distance | +0.01 × Δdistance / max_distance | When closing (positive Δ) |
| Hit landed | +1.0 | Bullet hits opponent |
| Got hit | -1.0 | Bullet or asteroid hits agent |
| Near-miss penalty | -0.1 × (1 - dist/danger_radius)² | danger_radius = 3× collisionRadius + 40px base |
| Fire discipline | -0.002 | When fire action is true |

**Terminal rewards**:

| Component | Value | Condition |
|-----------|-------|-----------|
| Episode win | +5.0 | Opponent HP reaches 0 |
| Episode loss | -5.0 | Agent HP reaches 0 |
| Draw | -2.0 | Both agent HP ≤ 0 AND opponent HP ≤ 0 (stacks with win+loss) |
| Episode timeout | -1.0 | maxTicks reached |

All reward component weights are configurable via `rewardWeights` in the training
config. The training script tunes them per curriculum stage.

### 16.8 Curriculum Design

Train in progressive stages, each building on the last. Promote to the next stage
when a performance threshold is met (e.g., >80% win rate over 1000 episodes).
Each stage loads the previous stage's trained weights as initialization.

| Stage | Asteroids | Enemy behavior | Enemy shoots | Ship HP | Goal |
|-------|-----------|----------------|-------------|---------|------|
| 1 | None | Static (doesn't move) | No | 10 | Learn thrust, aim, fire |
| 2 | None | Moves (reactive AI) | No | 10 | Learn lead targeting, pursuit |
| 3 | None | Moves (reactive AI) | Yes | 5 | Learn evasion + offense |
| 4 | None | Predictive AI | Yes | 3 | Learn to fight predictive enemy |
| 5 | Sparse (0.3×) | Predictive AI | Yes | 3 | Learn navigation while fighting |
| 6 | Normal (1.0×) | Predictive AI* | Yes | 1 | Learn the actual game |

*Stage 6 uses the predictive AI as a strong fixed opponent. True self-play
(policy pool with historical snapshots) requires a two-agent bridge extension
— deferred to a future increment.

**Design note**: Stage 4 was originally "predictive + sparse asteroids" but the
agent catastrophically forgot its combat skills when facing two new challenges
simultaneously. Splitting into stage 4 (predictive enemy only) and stage 5
(add asteroids) follows the one-new-challenge-at-a-time principle.

**Why curriculum matters**: Throwing the agent into the full game from scratch
requires it to simultaneously learn movement, aiming, evasion, and navigation.
Curriculum decomposition lets each skill build on the previous one, dramatically
reducing total training time.

### 16.9 Self-Play (Deferred)

**Status**: Deferred pending bridge protocol extension. Stage 6 currently uses
the predictive AI as a strong fixed opponent.

When implemented, self-play will prevent the agent from overfitting to a fixed
opponent's weaknesses:

- Maintain a **policy pool** of historical snapshots (frozen model weights)
- Every N training episodes, snapshot the current policy and add it to the pool
- Each episode's opponent is **sampled from the pool**, weighted toward recent
  snapshots (so the agent primarily trains against near-current skill levels)
- Prevents **strategy collapse** — the agent must generalize across opponent
  behaviors, not memorize exploits against one fixed policy
- Pool size capped at ~20 snapshots; oldest evicted when full
- Requires a two-agent bridge protocol or loading frozen ONNX models on the
  Node.js side — out of scope for the initial training scaffold

### 16.10 Training Tooling

Training runs can take many hours and win rates oscillate significantly. Three tools
address this:

#### Best-Model Checkpointing

During training, the best model seen (by rolling win rate) is saved automatically:

- Every 50 completed episodes, the current rolling win rate is compared to the best seen
- If it exceeds the previous best, the model is saved as `best.zip` + `best_meta.json`
  in the stage's checkpoint directory
- `best_meta.json` records: `{ win_rate, episodes, step, timestamp }`
- Training can be interrupted and resumed from the best model:
  `--checkpoint training/checkpoints/stage3/best.zip`
- The `final.zip` (saved at end of training) and `best.zip` (saved mid-training) coexist

#### JSONL Training Logs

Training metrics are logged to disk for analysis and live monitoring:

- Every ~10 seconds, a JSON line is appended to `training/logs/stageN.jsonl`
- Each line: `{ ts, step, episodes, win_rate, mean_reward, best_wr, stage }`
- On startup, existing entries from the JSONL file are loaded (preserves history across restarts)
- A `dashboard_data.js` file is also written (JS variable assignment for the dashboard)

#### Live Training Dashboard

A self-contained HTML file (`training/dashboard.html`) provides live visualization:

- Two Chart.js charts: Win Rate over time (with best WR overlay and 80% threshold line)
  and Mean Reward over time
- Header stats: Stage, Episodes, Steps, Current Win Rate, Best Win Rate
- Auto-refreshes every 15 seconds
- Dark theme, monospace font
- Served via `python -m http.server 8080 --directory training`
- Loads data from `logs/dashboard_data.js` via script tag injection (cache-busted)

#### Rolling Window Size

The rolling window for win rate calculation is configurable via `--window-size N`
(default 200). A larger window reduces measurement noise — with window=100, a 60%
true win-rate agent can randomly hit 80% on a lucky streak. Window=200 gives more
reliable promotion signals.

### 16.11 Python Training Bridge

Communication protocol between the Python training script and the Node.js GameEnv:

**Transport**: stdin/stdout JSON-lines protocol (one JSON object per line, newline-
delimited).

**Commands (Python → Node)**:

```json
{ "command": "reset", "config": { "shipHP": 5, "maxTicks": 3600, ... } }
{ "command": "step", "action": 3, "fire": 1 }
{ "command": "close" }
```

**Responses (Node → Python)**:

```json
{ "observation": [0.5, -0.3, ...], "reward": 0.0, "done": false, "info": {} }
{ "error": "Invalid action index" }
```

- Node process enters bridge mode via `node simulate.js --bridge`
- Multiple parallel Node processes for vectorized environments (one process per env,
  managed by the Python `SubprocVecEnv` wrapper)
- The Python side wraps this in a Gymnasium-compatible `SpaceDogfightEnv` class

### 16.12 Danger Zone Overlay

A debug visualization that renders the near-miss penalty field around each
asteroid as a red radial gradient. Helps tune reward weights and diagnose
agent behavior during training observation.

**Setting**: `showDangerZones` (boolean, default `false`) — checkbox in the
settings panel labeled "Danger Zones".

**Visualization**:
- Each asteroid gets a radial gradient from its surface (`collisionRadius`) to
  the danger zone edge (`NEAR_MISS_RADIUS_FACTOR × collisionRadius + DANGER_RADIUS_BASE`).
- Inner edge: `rgba(255, 0, 0, 0.25)` — outer edge: fully transparent.
- Composite operation `'lighter'` — overlapping zones stack additively,
  so dense asteroid clusters glow brighter red, matching how the reward
  system sums per-asteroid penalties.
- Zero render cost when the setting is off.

### 16.13 File Structure Additions

```
SpaceInvaders/
  src/
    ai-neural.js       ← neural strategy: ONNX inference, control flag mapping
    observation.js      ← shared observation builder (ego-centric vectors)
    reward.js           ← configurable dense reward function
    game-env.js         ← GameEnv class: gym-style reset/step interface
  models/
    policy.onnx         ← trained model weights (not in git — generated by training)
  training/
    requirements.txt    ← Python dependencies (stable-baselines3, gymnasium, onnx)
    env.py              ← Gymnasium wrapper (spawns Node.js bridge subprocess)
    train.py            ← PPO training script with curriculum stages
    export_onnx.py      ← Export trained PyTorch model to ONNX format
    config.yaml         ← Curriculum stage definitions and hyperparameters
    dashboard.html      ← Live training dashboard (Chart.js, auto-refresh)
    logs/               ← JSONL training logs + dashboard data (not in git)
```
