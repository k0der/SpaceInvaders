# Space Dogfight — Technical Specification

## Overview

A Star Wars-style dogfighting game built on top of a physics-driven asteroid field.
Two ships (player + AI enemy) fight among drifting, colliding asteroids. The player
ship is fixed at screen center with the world rotating around it — classic Asteroids
controls with Newtonian physics. The same asteroid field serves triple duty: combat
arena, AI-vs-AI screensaver, or classic asteroid screensaver (ships off).

## Technology

- **Single HTML file** (`index.html`) containing all HTML, CSS, and JavaScript
- **HTML5 Canvas 2D** for rendering
- **Zero dependencies** — vanilla JS, opens in any modern browser
- **No build step** required

## Development Process

- **Trunk-based development**: all work lands on `main` — no long-lived feature branches
- **TDD**: write failing tests (RED) → implement until green (GREEN) → refactor
- **Coverage audit**: before committing each increment, explicitly map every acceptance criterion to its test(s) and fill gaps
- **Build**: `node build.js` inlines ES modules from `src/` into a standalone `index.html`
- **Code quality**: follow SOLID principles and clean-code style — small focused functions, single responsibility, descriptive names, no magic numbers, code that is highly maintainable and testable
- **Mandatory human review**: At the end of every iteration, **stop and wait for the human developer to review and manually test** the implementation before proceeding. Do not start the next iteration until the human gives explicit approval. This is not optional.
- **Final test coverage review**: When development of an iteration is complete and all tests are passing, review the code for missing test coverage and add any needed tests before presenting the iteration for human review.

## Visual Style

- **Black background**, white vector-style line art
- **No fill** on asteroids — wireframe outlines only (1–2px stroke)
- Aesthetic: monochrome vector graphics, faithful to the original CRT look
- No textures, no gradients, no colors

---

## 1. Asteroids

### 1.1 Shape Generation

Each asteroid is a **randomly generated irregular polygon**:

- Vertex count: 8–14 vertices per asteroid
- Generated by walking around a circle in equal angular steps, with each vertex
  displaced radially by a random factor (0.6–1.0 of the base radius)
- Every asteroid is unique
- Shapes are generated once at spawn time and cached as a vertex list

### 1.2 Size Classes

Three size tiers with continuous variation within each:

| Class  | Radius Range (px) | Stroke Width |
|--------|-------------------|--------------|
| Large  | 50–80             | 2.0 px       |
| Medium | 25–49             | 1.5 px       |
| Small  | 10–24             | 1.0 px       |

Distribution: ~20% large, ~40% medium, ~40% small.

### 1.3 Movement

- Each asteroid has a **velocity vector** `(vx, vy)` assigned at spawn
- **Bigger asteroids move slower**: base speed is inversely proportional to radius
  - Large: 15–30 px/s
  - Medium: 30–60 px/s
  - Small: 60–120 px/s
- All speeds are multiplied by the user-configurable **speed multiplier** (default 1.0)
- Movement is frame-rate independent using delta-time

### 1.4 Rotation

- Each asteroid has a **constant angular velocity** assigned at spawn
- Rotation speed: random value between -0.5 and +0.5 radians/second
- Larger asteroids rotate more slowly (scaled inversely to radius)
- Rotation is purely visual; collision uses a bounding circle

### 1.5 Spawning & Despawning

- Asteroids **drift in from off-screen edges** and **drift out** the other side
- When an asteroid is fully off-screen (all vertices past the boundary + margin),
  it is removed
- New asteroids spawn just outside a random screen edge, aimed roughly toward the
  opposite side with some angular spread (±30°)
- The system maintains the **target asteroid count** (default 20, user-configurable)
  by spawning replacements as asteroids leave or are destroyed
- Spawning is staggered — no more than 1 new asteroid per 0.3 seconds to avoid
  clusters appearing at edges

### 1.6 Energy Homeostasis

The open boundary preferentially removes fast, light asteroids (they exit the
screen sooner after collisions), gradually draining the system's kinetic energy.
To compensate, the spawner acts as a feedback-controlled energy pump:

- At initialization, the average kinetic energy per asteroid is recorded as the
  baseline (KE = 0.5 × collisionRadius² × speed²)
- When spawning a replacement, the current total system KE is compared to the
  target (baseline × target count)
- If the system is below target, the spawn speed is boosted by
  `sqrt(targetKE / actualKE)`, capped at 1.5×
- If the system is at or above target, spawns use normal spec speeds
- This keeps the asteroid field's energy level constant indefinitely, regardless
  of collision history

---

## 2. Collision Physics

### 2.1 Detection

- **Circle-circle collision** using each asteroid's **effective collision radius**
- The collision radius is computed from the actual generated shape: the average vertex
  distance from center. This gives a tighter fit than the bounding radius, so asteroids
  only collide when their visible surfaces are close to touching.
- Check every pair each frame (with spatial optimization if needed for high counts)
- A collision is detected when `distance(centerA, centerB) < collisionRadiusA + collisionRadiusB`

### 2.2 Response — Elastic Collision

- Collisions are **fully elastic** (conserve kinetic energy and momentum)
- Mass is proportional to `radius^2` (area, simulating 2D mass)
- On collision:
  1. Separate overlapping asteroids so they no longer intersect
  2. Calculate new velocities using the 2D elastic collision formula:
     - `v1' = v1 - (2*m2/(m1+m2)) * dot(v1-v2, x1-x2) / |x1-x2|^2 * (x1-x2)`
     - `v2' = v2 - (2*m1/(m1+m2)) * dot(v2-v1, x2-x1) / |x2-x1|^2 * (x2-x1)`
  3. Apply a slight random perturbation (±2%) to post-collision velocities to
     prevent perfectly repeating patterns
- **Result**: small asteroids ricochet dramatically off large ones; two large
  asteroids gently nudge each other

---

## 3. Starfield Background

### 3.1 Parallax Layers

- Minimum **3 layers** of stars (configurable: 3–6 layers via settings)
- Each layer scrolls at a different speed to create depth:

| Layer | Dot Size  | Brightness   | Scroll Speed     | Star Count   |
|-------|-----------|--------------|------------------|--------------|
| Far   | 1 px      | 30–50% white | 2–5 px/s         | ~100 stars   |
| Mid   | 1–2 px    | 50–70% white | 8–15 px/s        | ~60 stars    |
| Near  | 2–3 px    | 70–100% white| 20–35 px/s       | ~30 stars    |

- Intermediate layers (if user adds more) interpolate between these values
- Stars scroll in a configurable direction (default: left, suggesting the
  "camera" is panning right through space)

#### Direction Modes

The star field direction is user-configurable with 5 modes:

- **left** (default): Stars drift leftward. Camera pans right through space.
- **right**: Stars drift rightward. Camera pans left.
- **up**: Stars drift upward. Camera descends.
- **down**: Stars drift downward. Camera ascends.
- **radial**: Stars emanate from the screen center outward in all directions,
  creating a "traveling through hyperspace" effect (like the Star Wars jump to
  lightspeed). Key properties:
  - **Perspective acceleration**: speed scales with distance from center —
    stars creep slowly near the center and accelerate toward the edges
  - **Brightness fade-in**: stars are dim near the center (far away) and
    brighten as they fly outward (closer to the viewer)
  - Stars respawn at a small offset from center (5–30px), not at the exact
    center point, so they emerge subtly rather than popping into view
  - Parallax is preserved — near-layer stars fly outward faster than far-layer
    stars

### 3.2 Twinkling

- Each star has a **base brightness** and a **twinkle phase** (random offset)
- Brightness oscillates sinusoidally: `brightness = base + amplitude * sin(time * frequency + phase)`
- Twinkle amplitude: 10–30% of base brightness (wider range for visual variety)
- Twinkle frequency: 0.3–3.0 Hz (wide range so stars feel independent, not synchronized)
- Phases must be well-distributed across the full cycle to avoid clusters of stars pulsing together
- The overall effect should look organic and natural — like real stars — not like a synchronized Christmas tree
- Only the far and mid layers twinkle; near-layer stars are steady

### 3.3 Star Recycling

- **Linear modes** (left/right/up/down): Stars that scroll off the exit edge
  are repositioned at the opposite (entry) edge with a new random position on
  the perpendicular axis
- **Radial mode**: Stars that exit any screen edge respawn at a small offset
  from center (5–30px) with a new random outward angle and dim brightness
- Star positions are initialized randomly across the full canvas at startup
- **Direction change**: When the user switches direction, all stars are
  redistributed randomly for the new mode — linear modes scatter across
  the full canvas, radial mode distributes at various distances from center
  with brightness matching distance

---

## 4. Render Pipeline

### 4.1 Draw Order (back to front)

1. Clear canvas to **black** (`#000000`)
2. Draw **star layers** (far to near)
3. Draw **asteroids** (no particular z-order needed — they're all in the same plane)

### 4.2 Asteroid Rendering

- `ctx.strokeStyle = '#FFFFFF'`
- `ctx.lineWidth` per size class (see table in 1.2)
- Draw using `beginPath()` → `moveTo()` → `lineTo()` loop → `closePath()` → `stroke()`
- Apply rotation via `ctx.translate(x, y)` → `ctx.rotate(angle)`

### 4.3 Performance

- Target: **60 FPS** on modern hardware
- Use `requestAnimationFrame` for the main loop
- Delta-time based updates (no fixed timestep)
- Canvas resolution matches `window.innerWidth * devicePixelRatio` for crisp lines
  on HiDPI displays

---

## 5. Settings Menu

### 5.1 Trigger & Appearance

- **Hamburger menu icon** (☰) in the top-left corner
- Icon is semi-transparent (30% opacity) and brightens on hover (80%)
- Clicking the icon opens a **translucent overlay panel** (dark background, ~80% opacity)
- Panel slides in from the left edge; icon swaps to a close symbol (✕)
- When panel is open, the close icon stays at full visibility (80% opacity)
- Panel **auto-hides after 4 seconds** of no mouse movement over it
- Menu icon auto-hides after 3 seconds of no mouse movement anywhere, reappears on
  mouse move
- Pressing **Escape** also closes the panel

### 5.2 Controls

| Setting              | Control  | Range                          | Default | Step |
|----------------------|----------|--------------------------------|---------|------|
| Asteroid Count       | Slider   | 5 – 50                        | 20      | 1    |
| Speed Multiplier     | Slider   | 0.2 – 3.0                     | 1.0     | 0.1  |
| Star Parallax Layers | Slider   | 3 – 6                         | 3       | 1    |
| Thrust Power         | Slider   | 100 – 2000                        | 900     | 50   |
| Star Field Direction | Select   | left / right / up / down / radial | left    | —    |

- Each slider shows its **current value** as a label
- Changes are applied **immediately** (live preview)
- When asteroid count is reduced, excess asteroids are allowed to drift off naturally
  (not removed abruptly)
- When asteroid count is increased, new ones begin spawning at the staggered rate
- Settings are persisted to `localStorage` so they survive page reload

### 5.3 Visual Style of Menu

- Monochrome to match the aesthetic — white text, white slider tracks on dark panel
- Font: system monospace (`'Courier New', monospace`)
- Minimal, clean layout

---

## 6. Responsive Behavior

- Canvas fills the **entire browser viewport** (`100vw x 100vh`)
- On window resize:
  - Canvas dimensions update immediately
  - Existing asteroids continue on their current trajectories
  - **Stars are redistributed** across the new canvas dimensions for the
    current direction mode (prevents clustering or off-screen stars after
    mobile screen rotation)
  - Star counts adjust proportionally to new area on next recycle
- No scrollbars, no overflow — `body { margin: 0; overflow: hidden; }`
- Works on both desktop and mobile (touch triggers gear icon visibility)

---

## 7. Animation Loop Summary

Each frame (`requestAnimationFrame` callback):

```
1. Calculate deltaTime
2. Update input state
3. Apply input to player ship (or AI input in ai-vs-ai mode)
4. Update AI for enemy ship (and player ship in ai-vs-ai mode)
5. Update ships (physics: thrust, drag, brake, rotation, position)
6. Update camera (follow player ship)
7. Update stars:
   a. Camera-relative parallax shift (when ships active)
   b. Update twinkle phase
   c. Wrap off-screen stars
8. Update asteroids:
   a. Move each by velocity * dt
   b. Rotate each by angular velocity * dt
   c. Remove asteroids outside viewport bounds
   d. Spawn new asteroids at viewport edges (respecting stagger timer)
9. Detect & resolve asteroid collisions
10. Update bullets (move, expire)
11. Check bullet-ship collisions
12. Check ship-asteroid collisions
13. Update game state (phase transitions, explosions)
14. Render:
    a. Clear canvas
    b. Draw star layers (screen-space)
    c. Apply camera transform
    d. Draw asteroids
    e. Draw ships + flames
    f. Draw bullets
    g. Reset camera transform
    h. Draw HUD (win/lose text)
    i. Draw settings menu icon (if visible)
```

When `shipMode = 'off'`, steps 2–6, 10–13 are skipped and the camera stays at origin
with no rotation. The starfield uses directional scroll mode instead of camera-relative.

---

## 8. File Structure

```
SpaceInvaders/
  src/
    main.js         ← entry point, integration, animation loop
    asteroid.js     ← asteroid entity (shape, rendering, movement)
    starfield.js    ← parallax star layers
    simulation.js   ← asteroid spawn/despawn, population management
    physics.js      ← collision detection and elastic response
    energy.js       ← kinetic energy computation and homeostasis
    settings.js     ← settings menu UI and persistence
    renderer.js     ← HiDPI canvas setup
    ship.js         ← ship entity: creation, Newtonian physics, rendering
    input.js        ← keyboard state tracking (WASD + arrows + space)
    camera.js       ← camera state, canvas transform, viewport bounds
    bullet.js       ← bullet entity: creation, movement, lifetime
    ai.js           ← AI steering, combat, and obstacle avoidance
    game.js         ← game state: phases, collisions, HUD, restart
  test/             ← Vitest test files (one per module)
  dev.html          ← development entry point (ES module imports)
  index.html        ← production build (single file, all JS inlined)
  build.js          ← custom bundler (strips imports, inlines into index.html)
  SPEC.md           ← this specification
  TODO.md           ← incremental build plan with acceptance criteria
  CLAUDE.md         ← agent instructions and workflow rules
```

Development uses ES modules in `src/` for testability. `node build.js` (or `npm run build`)
produces a standalone `index.html` with all modules inlined — zero external dependencies.

---

## 9. Ships

### 9.1 Ship Entity

- Ships are classic Asteroids chevron/triangle wireframes — white stroke, no fill
- Each ship has: `x, y, vx, vy, heading, alive`, control booleans (`thrust, rotatingLeft, rotatingRight, braking, fire`), and a `collisionRadius`
- Ships use **Newtonian physics**: thrust accelerates in heading direction, drag always applies, braking decelerates opposite to velocity
- Speed capped at `MAX_SPEED`; a `MIN_SPEED` ensures the ship always drifts forward gently
- Constants: `THRUST_POWER`, `DRAG`, `BRAKE_POWER`, `ROTATION_SPEED`, `MAX_SPEED`, `MIN_SPEED`

### 9.2 Controls

- **Classic Asteroids**: W/Up = thrust, A/Left = rotate left, D/Right = rotate right, S/Down = brake, Space = fire
- Case-insensitive key mapping
- Escape still opens/closes settings (no conflict)

### 9.3 Ship Rendering

- White wireframe chevron (`strokeStyle = '#FFFFFF'`), `lineWidth ~1.5`
- Canvas state saved/restored (no transform leak)
- When thrusting, a flickering engine flame (randomized triangle) drawn behind the ship
- Enemy ship visually distinguished (e.g., dashed lines or different shape)

---

## 10. Camera

### 10.1 Camera Transform

The camera follows the player ship, locking it at screen center. The world rotates
around the player — the ship always points "up" on screen.

Applied as a **canvas context transform** (not per-entity coordinate conversion):

```
ctx.save();
ctx.translate(viewportW / 2, viewportH / 2);  // screen center
ctx.rotate(-camera.rotation);                   // world rotates opposite to camera
ctx.translate(-camera.x, -camera.y);            // offset by camera world position
// ... draw all world-space entities ...
ctx.restore();
```

This means existing draw functions (e.g., `drawAsteroid`) work **unchanged** — they
already translate to their entity's `(x, y)`, and the camera transform is already on
the context.

### 10.2 Render Pipeline (with camera)

1. Clear canvas to black
2. Draw starfield (screen-space, before camera transform)
3. Apply camera transform
4. Draw asteroids (world-space)
5. Draw ships (world-space — player maps to screen center)
6. Draw bullets (world-space)
7. Reset camera transform
8. Draw HUD text (screen-space)
9. Draw settings menu icon

### 10.3 Viewport Bounds

`getViewportBounds(camera, viewportW, viewportH)` returns the axis-aligned bounding
box (AABB) of the rotated viewport in world-space, with a padding margin. Used for
asteroid spawn/despawn decisions.

---

## 11. Bullets

- Created at ship's nose position, traveling at `BULLET_SPEED` in heading direction plus ship velocity (inherit momentum)
- Move linearly, tracked by `age`; expire after `BULLET_LIFETIME` (~2s)
- Rendered as small bright dots or short lines
- Fire rate limited by `FIRE_COOLDOWN` (~0.2s between shots)
- Bullets do **not** interact with asteroids (pass through — dogfight focus)
- `owner` field tracks which ship fired the bullet (for collision filtering)
- A ship's own bullets cannot hit itself

---

## 12. AI

### 12.1 AI Steering

- AI controls a ship using the same physics as the player (same thrust, drag, max speed)
- Rotates toward target's **predicted position** (leads the target based on velocity)
- Thrusts when roughly facing target
- Brakes when overshooting

### 12.2 AI Combat

- Fires when aimed within an angular threshold of the target
- Respects same `FIRE_COOLDOWN` as player
- Does not fire when target is too far away

### 12.3 AI Obstacle Avoidance

- Steers away from nearby asteroids when a collision course is detected
- Avoidance and pursuit blend smoothly (no jittering between states)

---

## 13. Game State

### 13.1 Phases

- `'playing'` → `'playerWin'` (enemy dies) / `'playerDead'` (player dies)
- On player death: camera freezes at death position
- On enemy death: camera continues following player

### 13.2 Ship-Asteroid Collision

- Circle-circle collision using ship's `collisionRadius`
- Ship dies on asteroid contact (same death + explosion as bullet death)
- Applies to both player and enemy
- Asteroids are unaffected (keep drifting)

### 13.3 Bullet-Ship Collision

- Bullet within ship's `collisionRadius` = hit
- One bullet = one kill → `ship.alive = false`
- Explosion effect on death (expanding wireframe circle or particle burst)

### 13.4 HUD

- Screen-space text (drawn after camera reset)
- "YOU WIN" or "GAME OVER" centered on screen
- "Press ENTER to restart" below the result
- Enter or R key restarts: ships respawn, bullets cleared, phase resets

---

## 14. Ship Mode Setting

Three modes selectable from the settings panel:

| Mode | Description |
|------|-------------|
| `'player-vs-ai'` (default) | Player controls one ship, AI controls enemy |
| `'ai-vs-ai'` | Both ships AI-controlled. Camera follows one ship. Auto-respawn after 3s on death (infinite dogfight screensaver) |
| `'off'` | No ships, no bullets. Camera static at origin. Starfield reverts to directional scroll. Pure asteroid screensaver (original behavior) |

- Persisted to `localStorage`
- Mode switching works live without page reload
