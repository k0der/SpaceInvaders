# Asteroid Screensaver - Technical Specification

## Overview

A continuous, non-interactive animation inspired by the 1979 Atari Asteroids arcade game.
No player, no score, no game-over — just an endless field of drifting, tumbling,
colliding asteroids against a deep starfield. Designed to be mesmerizing and relaxing.

## Technology

- **Single HTML file** (`index.html`) containing all HTML, CSS, and JavaScript
- **HTML5 Canvas 2D** for rendering
- **Zero dependencies** — vanilla JS, opens in any modern browser
- **No build step** required

## Development Process

- **Trunk-based development**: all work lands on `main` — no long-lived feature branches
- **TDD**: write failing tests (RED) → implement until green (GREEN) → refactor
- **Coverage audit**: before committing each increment, explicitly map every acceptance criterion to its test(s) and fill gaps
- **Build**: `node build.js` inlines ES modules from `src/` into a standalone `index.html`
- **Mandatory human review**: At the end of every iteration, **stop and wait for the human developer to review and manually test** the implementation before proceeding. Do not start the next iteration until the human gives explicit approval. This is not optional.
- **Final test coverage review**: When development of an iteration is complete and all tests are passing, review the code for missing test coverage and add any needed tests before presenting the iteration for human review.

## Visual Style

- **Black background**, white vector-style line art
- **No fill** on asteroids — wireframe outlines only (1–2px stroke)
- Aesthetic: monochrome vector graphics, faithful to the original CRT look
- No textures, no gradients, no colors

---

## 1. Asteroids

### 1.1 Shape Generation

Each asteroid is a **randomly generated irregular polygon**:

- Vertex count: 8–14 vertices per asteroid
- Generated by walking around a circle in equal angular steps, with each vertex
  displaced radially by a random factor (0.6–1.0 of the base radius)
- Every asteroid is unique
- Shapes are generated once at spawn time and cached as a vertex list

### 1.2 Size Classes

Three size tiers with continuous variation within each:

| Class  | Radius Range (px) | Stroke Width |
|--------|-------------------|--------------|
| Large  | 50–80             | 2.0 px       |
| Medium | 25–49             | 1.5 px       |
| Small  | 10–24             | 1.0 px       |

Distribution: ~20% large, ~40% medium, ~40% small.

### 1.3 Movement

- Each asteroid has a **velocity vector** `(vx, vy)` assigned at spawn
- **Bigger asteroids move slower**: base speed is inversely proportional to radius
  - Large: 15–30 px/s
  - Medium: 30–60 px/s
  - Small: 60–120 px/s
- All speeds are multiplied by the user-configurable **speed multiplier** (default 1.0)
- Movement is frame-rate independent using delta-time

### 1.4 Rotation

- Each asteroid has a **constant angular velocity** assigned at spawn
- Rotation speed: random value between -0.5 and +0.5 radians/second
- Larger asteroids rotate more slowly (scaled inversely to radius)
- Rotation is purely visual; collision uses a bounding circle

### 1.5 Spawning & Despawning

- Asteroids **drift in from off-screen edges** and **drift out** the other side
- When an asteroid is fully off-screen (all vertices past the boundary + margin),
  it is removed
- New asteroids spawn just outside a random screen edge, aimed roughly toward the
  opposite side with some angular spread (±30°)
- The system maintains the **target asteroid count** (default 20, user-configurable)
  by spawning replacements as asteroids leave or are destroyed
- Spawning is staggered — no more than 1 new asteroid per 0.3 seconds to avoid
  clusters appearing at edges

---

## 2. Collision Physics

### 2.1 Detection

- **Circle-circle collision** using each asteroid's bounding radius
- Check every pair each frame (with spatial optimization if needed for high counts)
- A collision is detected when `distance(centerA, centerB) < radiusA + radiusB`

### 2.2 Response — Elastic Collision

- Collisions are **fully elastic** (conserve kinetic energy and momentum)
- Mass is proportional to `radius^2` (area, simulating 2D mass)
- On collision:
  1. Separate overlapping asteroids so they no longer intersect
  2. Calculate new velocities using the 2D elastic collision formula:
     - `v1' = v1 - (2*m2/(m1+m2)) * dot(v1-v2, x1-x2) / |x1-x2|^2 * (x1-x2)`
     - `v2' = v2 - (2*m1/(m1+m2)) * dot(v2-v1, x2-x1) / |x2-x1|^2 * (x2-x1)`
  3. Apply a slight random perturbation (±2%) to post-collision velocities to
     prevent perfectly repeating patterns
- **Result**: small asteroids ricochet dramatically off large ones; two large
  asteroids gently nudge each other

### 2.3 Collision Cooldown

- After two asteroids collide, they cannot collide with each other again for
  0.3 seconds (prevents rapid re-triggering from overlap)

---

## 3. Starfield Background

### 3.1 Parallax Layers

- Minimum **3 layers** of stars (configurable: 3–6 layers via settings)
- Each layer scrolls at a different speed to create depth:

| Layer | Dot Size  | Brightness   | Scroll Speed     | Star Count   |
|-------|-----------|--------------|------------------|--------------|
| Far   | 1 px      | 30–50% white | 2–5 px/s         | ~100 stars   |
| Mid   | 1–2 px    | 50–70% white | 8–15 px/s        | ~60 stars    |
| Near  | 2–3 px    | 70–100% white| 20–35 px/s       | ~30 stars    |

- Intermediate layers (if user adds more) interpolate between these values
- Stars scroll in a consistent direction (slowly drifting left by default,
  suggesting the "camera" is panning right through space)

### 3.2 Twinkling

- Each star has a **base brightness** and a **twinkle phase** (random offset)
- Brightness oscillates sinusoidally: `brightness = base + amplitude * sin(time * frequency + phase)`
- Twinkle amplitude: 10–20% of base brightness
- Twinkle frequency: 0.5–2.0 Hz (randomized per star)
- Only the far and mid layers twinkle; near-layer stars are steady

### 3.3 Star Recycling

- Stars that scroll off one edge are repositioned at the opposite edge with
  a new random vertical position
- Star positions are initialized randomly across the full canvas at startup

---

## 4. Render Pipeline

### 4.1 Draw Order (back to front)

1. Clear canvas to **black** (`#000000`)
2. Draw **star layers** (far to near)
3. Draw **asteroids** (no particular z-order needed — they're all in the same plane)

### 4.2 Asteroid Rendering

- `ctx.strokeStyle = '#FFFFFF'`
- `ctx.lineWidth` per size class (see table in 1.2)
- Draw using `beginPath()` → `moveTo()` → `lineTo()` loop → `closePath()` → `stroke()`
- Apply rotation via `ctx.translate(x, y)` → `ctx.rotate(angle)`

### 4.3 Performance

- Target: **60 FPS** on modern hardware
- Use `requestAnimationFrame` for the main loop
- Delta-time based updates (no fixed timestep)
- Canvas resolution matches `window.innerWidth * devicePixelRatio` for crisp lines
  on HiDPI displays

---

## 5. Settings Menu

### 5.1 Trigger & Appearance

- **Gear icon** in the bottom-right corner (rendered as a simple SVG/canvas drawn cog)
- Icon is semi-transparent (30% opacity) and brightens on hover (80%)
- Clicking the gear opens a **translucent overlay panel** (dark background, ~80% opacity)
- Panel slides in from the right edge
- Panel **auto-hides after 4 seconds** of no mouse movement over it
- Gear icon auto-hides after 3 seconds of no mouse movement anywhere, reappears on
  mouse move
- Pressing **Escape** also closes the panel

### 5.2 Controls

| Setting              | Control  | Range     | Default | Step |
|----------------------|----------|-----------|---------|------|
| Asteroid Count       | Slider   | 5 – 50   | 20      | 1    |
| Speed Multiplier     | Slider   | 0.2 – 3.0| 1.0     | 0.1  |
| Star Parallax Layers | Slider   | 3 – 6    | 3       | 1    |

- Each slider shows its **current value** as a label
- Changes are applied **immediately** (live preview)
- When asteroid count is reduced, excess asteroids are allowed to drift off naturally
  (not removed abruptly)
- When asteroid count is increased, new ones begin spawning at the staggered rate
- Settings are persisted to `localStorage` so they survive page reload

### 5.3 Visual Style of Menu

- Monochrome to match the aesthetic — white text, white slider tracks on dark panel
- Font: system monospace (`'Courier New', monospace`)
- Minimal, clean layout

---

## 6. Responsive Behavior

- Canvas fills the **entire browser viewport** (`100vw x 100vh`)
- On window resize:
  - Canvas dimensions update immediately
  - Existing asteroids and stars are NOT repositioned — they continue on their
    current trajectories
  - Star counts adjust proportionally to new area on next recycle
- No scrollbars, no overflow — `body { margin: 0; overflow: hidden; }`
- Works on both desktop and mobile (touch triggers gear icon visibility)

---

## 7. Animation Loop Summary

Each frame (`requestAnimationFrame` callback):

```
1. Calculate deltaTime
2. Update stars:
   a. Move each star by its layer's scroll speed * dt
   b. Update twinkle phase
   c. Recycle off-screen stars
3. Update asteroids:
   a. Move each by velocity * dt
   b. Rotate each by angular velocity * dt
   c. Remove off-screen asteroids
   d. Spawn new asteroids if count < target (respecting stagger timer)
4. Detect & resolve asteroid collisions
5. Render:
   a. Clear canvas
   b. Draw star layers (far → near)
   c. Draw asteroids
   d. Draw settings gear icon (if visible)
```

---

## 8. File Structure

```
SpaceInvaders/
  index.html    ← single file containing everything
  SPEC.md       ← this specification
```

Everything lives in `index.html` — HTML structure, CSS in a `<style>` block,
and all JavaScript in a `<script>` block. No external files.
